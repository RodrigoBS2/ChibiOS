
build/ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  00001fa0  00002034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fa0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000036d  0080015e  0080015e  00002092  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002092  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000020a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000768  00000000  00000000  000020e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014c52  00000000  00000000  0000284c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000442e  00000000  00000000  0001749e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005722  00000000  00000000  0001b8cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001500  00000000  00000000  00020ff0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f9e  00000000  00000000  000224f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006e2e  00000000  00000000  0002448e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009b8  00000000  00000000  0002b2bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4b c0       	rjmp	.+150    	; 0xc4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	86 c3       	rjmp	.+1804   	; 0x746 <__vector_14>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	b9 c3       	rjmp	.+1906   	; 0x7bc <__vector_18>
      4a:	00 00       	nop
      4c:	f5 c3       	rjmp	.+2026   	; 0x838 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2314>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2449>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e0 ea       	ldi	r30, 0xA0	; 160
      9e:	ff e1       	ldi	r31, 0x1F	; 31
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	ae 35       	cpi	r26, 0x5E	; 94
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	24 e0       	ldi	r18, 0x04	; 4
      ae:	ae e5       	ldi	r26, 0x5E	; 94
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	ab 3c       	cpi	r26, 0xCB	; 203
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 8a 0b 	call	0x1714	; 0x1714 <main>
      c0:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	0c d3       	rcall	.+1560   	; 0x6e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	88 e1       	ldi	r24, 0x18	; 24
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	0a d3       	rcall	.+1556   	; 0x6e2 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	95 d2       	rcall	.+1322   	; 0x5fa <sdInit>
      d0:	03 d3       	rcall	.+1542   	; 0x6d8 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	63 c3       	rjmp	.+1734   	; 0x79c <st_lld_init>

000000d6 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
      d6:	af 92       	push	r10
      d8:	bf 92       	push	r11
      da:	cf 92       	push	r12
      dc:	df 92       	push	r13
      de:	ef 92       	push	r14
      e0:	ff 92       	push	r15
      e2:	0f 93       	push	r16
      e4:	1f 93       	push	r17
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	ec 01       	movw	r28, r24
      ec:	6b 01       	movw	r12, r22
      ee:	8a 01       	movw	r16, r20
      f0:	8c 81       	ldd	r24, Y+4	; 0x04
      f2:	9d 81       	ldd	r25, Y+5	; 0x05
      f4:	84 17       	cp	r24, r20
      f6:	95 07       	cpc	r25, r21
      f8:	10 f4       	brcc	.+4      	; 0xfe <iq_read+0x28>
      fa:	0c 81       	ldd	r16, Y+4	; 0x04
      fc:	1d 81       	ldd	r17, Y+5	; 0x05
      fe:	6c 85       	ldd	r22, Y+12	; 0x0c
     100:	7d 85       	ldd	r23, Y+13	; 0x0d
     102:	e8 84       	ldd	r14, Y+8	; 0x08
     104:	f9 84       	ldd	r15, Y+9	; 0x09
     106:	e6 1a       	sub	r14, r22
     108:	f7 0a       	sbc	r15, r23
     10a:	0e 15       	cp	r16, r14
     10c:	1f 05       	cpc	r17, r15
     10e:	98 f1       	brcs	.+102    	; 0x176 <iq_read+0xa0>
     110:	e0 16       	cp	r14, r16
     112:	f1 06       	cpc	r15, r17
     114:	d0 f0       	brcs	.+52     	; 0x14a <iq_read+0x74>
     116:	a8 01       	movw	r20, r16
     118:	c6 01       	movw	r24, r12
     11a:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     11e:	8e 81       	ldd	r24, Y+6	; 0x06
     120:	9f 81       	ldd	r25, Y+7	; 0x07
     122:	9d 87       	std	Y+13, r25	; 0x0d
     124:	8c 87       	std	Y+12, r24	; 0x0c
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	80 1b       	sub	r24, r16
     12c:	91 0b       	sbc	r25, r17
     12e:	9d 83       	std	Y+5, r25	; 0x05
     130:	8c 83       	std	Y+4, r24	; 0x04
     132:	c8 01       	movw	r24, r16
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	ff 90       	pop	r15
     13e:	ef 90       	pop	r14
     140:	df 90       	pop	r13
     142:	cf 90       	pop	r12
     144:	bf 90       	pop	r11
     146:	af 90       	pop	r10
     148:	08 95       	ret
     14a:	a7 01       	movw	r20, r14
     14c:	c6 01       	movw	r24, r12
     14e:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     152:	58 01       	movw	r10, r16
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
     158:	6e 81       	ldd	r22, Y+6	; 0x06
     15a:	7f 81       	ldd	r23, Y+7	; 0x07
     15c:	a5 01       	movw	r20, r10
     15e:	c6 01       	movw	r24, r12
     160:	8e 0d       	add	r24, r14
     162:	9f 1d       	adc	r25, r15
     164:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     168:	8e 81       	ldd	r24, Y+6	; 0x06
     16a:	9f 81       	ldd	r25, Y+7	; 0x07
     16c:	a8 0e       	add	r10, r24
     16e:	b9 1e       	adc	r11, r25
     170:	bd 86       	std	Y+13, r11	; 0x0d
     172:	ac 86       	std	Y+12, r10	; 0x0c
     174:	d8 cf       	rjmp	.-80     	; 0x126 <iq_read+0x50>
     176:	a8 01       	movw	r20, r16
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     17e:	8c 85       	ldd	r24, Y+12	; 0x0c
     180:	9d 85       	ldd	r25, Y+13	; 0x0d
     182:	80 0f       	add	r24, r16
     184:	91 1f       	adc	r25, r17
     186:	9d 87       	std	Y+13, r25	; 0x0d
     188:	8c 87       	std	Y+12, r24	; 0x0c
     18a:	cd cf       	rjmp	.-102    	; 0x126 <iq_read+0x50>

0000018c <oq_write>:
     18c:	af 92       	push	r10
     18e:	bf 92       	push	r11
     190:	cf 92       	push	r12
     192:	df 92       	push	r13
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	ec 01       	movw	r28, r24
     1a2:	6b 01       	movw	r12, r22
     1a4:	8a 01       	movw	r16, r20
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	9d 81       	ldd	r25, Y+5	; 0x05
     1aa:	84 17       	cp	r24, r20
     1ac:	95 07       	cpc	r25, r21
     1ae:	10 f4       	brcc	.+4      	; 0x1b4 <oq_write+0x28>
     1b0:	0c 81       	ldd	r16, Y+4	; 0x04
     1b2:	1d 81       	ldd	r17, Y+5	; 0x05
     1b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     1b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     1b8:	e8 84       	ldd	r14, Y+8	; 0x08
     1ba:	f9 84       	ldd	r15, Y+9	; 0x09
     1bc:	e8 1a       	sub	r14, r24
     1be:	f9 0a       	sbc	r15, r25
     1c0:	0e 15       	cp	r16, r14
     1c2:	1f 05       	cpc	r17, r15
     1c4:	98 f1       	brcs	.+102    	; 0x22c <oq_write+0xa0>
     1c6:	e0 16       	cp	r14, r16
     1c8:	f1 06       	cpc	r15, r17
     1ca:	d0 f0       	brcs	.+52     	; 0x200 <oq_write+0x74>
     1cc:	a8 01       	movw	r20, r16
     1ce:	b6 01       	movw	r22, r12
     1d0:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     1d4:	8e 81       	ldd	r24, Y+6	; 0x06
     1d6:	9f 81       	ldd	r25, Y+7	; 0x07
     1d8:	9b 87       	std	Y+11, r25	; 0x0b
     1da:	8a 87       	std	Y+10, r24	; 0x0a
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	80 1b       	sub	r24, r16
     1e2:	91 0b       	sbc	r25, r17
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04
     1e8:	c8 01       	movw	r24, r16
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret
     200:	a7 01       	movw	r20, r14
     202:	b6 01       	movw	r22, r12
     204:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     208:	58 01       	movw	r10, r16
     20a:	ae 18       	sub	r10, r14
     20c:	bf 08       	sbc	r11, r15
     20e:	b6 01       	movw	r22, r12
     210:	6e 0d       	add	r22, r14
     212:	7f 1d       	adc	r23, r15
     214:	a5 01       	movw	r20, r10
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f 81       	ldd	r25, Y+7	; 0x07
     21a:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     21e:	8e 81       	ldd	r24, Y+6	; 0x06
     220:	9f 81       	ldd	r25, Y+7	; 0x07
     222:	a8 0e       	add	r10, r24
     224:	b9 1e       	adc	r11, r25
     226:	bb 86       	std	Y+11, r11	; 0x0b
     228:	aa 86       	std	Y+10, r10	; 0x0a
     22a:	d8 cf       	rjmp	.-80     	; 0x1dc <oq_write+0x50>
     22c:	a8 01       	movw	r20, r16
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <memcpy>
     234:	8a 85       	ldd	r24, Y+10	; 0x0a
     236:	9b 85       	ldd	r25, Y+11	; 0x0b
     238:	80 0f       	add	r24, r16
     23a:	91 1f       	adc	r25, r17
     23c:	9b 87       	std	Y+11, r25	; 0x0b
     23e:	8a 87       	std	Y+10, r24	; 0x0a
     240:	cd cf       	rjmp	.-102    	; 0x1dc <oq_write+0x50>

00000242 <iqObjectInit>:
     242:	af 92       	push	r10
     244:	bf 92       	push	r11
     246:	cf 92       	push	r12
     248:	df 92       	push	r13
     24a:	ef 92       	push	r14
     24c:	ff 92       	push	r15
     24e:	0f 93       	push	r16
     250:	1f 93       	push	r17
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	ec 01       	movw	r28, r24
     258:	7b 01       	movw	r14, r22
     25a:	6a 01       	movw	r12, r20
     25c:	59 01       	movw	r10, r18
     25e:	1d d7       	rcall	.+3642   	; 0x109a <chThdQueueObjectInit>
     260:	1d 82       	std	Y+5, r1	; 0x05
     262:	1c 82       	std	Y+4, r1	; 0x04
     264:	ff 82       	std	Y+7, r15	; 0x07
     266:	ee 82       	std	Y+6, r14	; 0x06
     268:	fd 86       	std	Y+13, r15	; 0x0d
     26a:	ec 86       	std	Y+12, r14	; 0x0c
     26c:	fb 86       	std	Y+11, r15	; 0x0b
     26e:	ea 86       	std	Y+10, r14	; 0x0a
     270:	ec 0c       	add	r14, r12
     272:	fd 1c       	adc	r15, r13
     274:	f9 86       	std	Y+9, r15	; 0x09
     276:	e8 86       	std	Y+8, r14	; 0x08
     278:	bf 86       	std	Y+15, r11	; 0x0f
     27a:	ae 86       	std	Y+14, r10	; 0x0e
     27c:	19 8b       	std	Y+17, r17	; 0x11
     27e:	08 8b       	std	Y+16, r16	; 0x10
     280:	df 91       	pop	r29
     282:	cf 91       	pop	r28
     284:	1f 91       	pop	r17
     286:	0f 91       	pop	r16
     288:	ff 90       	pop	r15
     28a:	ef 90       	pop	r14
     28c:	df 90       	pop	r13
     28e:	cf 90       	pop	r12
     290:	bf 90       	pop	r11
     292:	af 90       	pop	r10
     294:	08 95       	ret

00000296 <iqPutI>:
     296:	fc 01       	movw	r30, r24
     298:	a2 85       	ldd	r26, Z+10	; 0x0a
     29a:	b3 85       	ldd	r27, Z+11	; 0x0b
     29c:	84 85       	ldd	r24, Z+12	; 0x0c
     29e:	95 85       	ldd	r25, Z+13	; 0x0d
     2a0:	a8 17       	cp	r26, r24
     2a2:	b9 07       	cpc	r27, r25
     2a4:	e1 f0       	breq	.+56     	; 0x2de <iqPutI+0x48>
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	95 81       	ldd	r25, Z+5	; 0x05
     2aa:	01 96       	adiw	r24, 0x01	; 1
     2ac:	95 83       	std	Z+5, r25	; 0x05
     2ae:	84 83       	std	Z+4, r24	; 0x04
     2b0:	cd 01       	movw	r24, r26
     2b2:	01 96       	adiw	r24, 0x01	; 1
     2b4:	93 87       	std	Z+11, r25	; 0x0b
     2b6:	82 87       	std	Z+10, r24	; 0x0a
     2b8:	6c 93       	st	X, r22
     2ba:	22 85       	ldd	r18, Z+10	; 0x0a
     2bc:	33 85       	ldd	r19, Z+11	; 0x0b
     2be:	80 85       	ldd	r24, Z+8	; 0x08
     2c0:	91 85       	ldd	r25, Z+9	; 0x09
     2c2:	28 17       	cp	r18, r24
     2c4:	39 07       	cpc	r19, r25
     2c6:	20 f0       	brcs	.+8      	; 0x2d0 <iqPutI+0x3a>
     2c8:	86 81       	ldd	r24, Z+6	; 0x06
     2ca:	97 81       	ldd	r25, Z+7	; 0x07
     2cc:	93 87       	std	Z+11, r25	; 0x0b
     2ce:	82 87       	std	Z+10, r24	; 0x0a
     2d0:	cf 01       	movw	r24, r30
     2d2:	60 e0       	ldi	r22, 0x00	; 0
     2d4:	70 e0       	ldi	r23, 0x00	; 0
     2d6:	04 d7       	rcall	.+3592   	; 0x10e0 <chThdDequeueNextI>
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	08 95       	ret
     2de:	84 81       	ldd	r24, Z+4	; 0x04
     2e0:	95 81       	ldd	r25, Z+5	; 0x05
     2e2:	89 2b       	or	r24, r25
     2e4:	01 f3       	breq	.-64     	; 0x2a6 <iqPutI+0x10>
     2e6:	8f ef       	ldi	r24, 0xFF	; 255
     2e8:	9f ef       	ldi	r25, 0xFF	; 255
     2ea:	08 95       	ret

000002ec <iqGetTimeout>:
     2ec:	0f 93       	push	r16
     2ee:	1f 93       	push	r17
     2f0:	cf 93       	push	r28
     2f2:	df 93       	push	r29
     2f4:	ec 01       	movw	r28, r24
     2f6:	8b 01       	movw	r16, r22
     2f8:	f8 94       	cli
     2fa:	05 c0       	rjmp	.+10     	; 0x306 <iqGetTimeout+0x1a>
     2fc:	b8 01       	movw	r22, r16
     2fe:	ce 01       	movw	r24, r28
     300:	d2 d6       	rcall	.+3492   	; 0x10a6 <chThdEnqueueTimeoutS>
     302:	97 fd       	sbrc	r25, 7
     304:	27 c0       	rjmp	.+78     	; 0x354 <iqGetTimeout+0x68>
     306:	8c 81       	ldd	r24, Y+4	; 0x04
     308:	9d 81       	ldd	r25, Y+5	; 0x05
     30a:	89 2b       	or	r24, r25
     30c:	b9 f3       	breq	.-18     	; 0x2fc <iqGetTimeout+0x10>
     30e:	8c 81       	ldd	r24, Y+4	; 0x04
     310:	9d 81       	ldd	r25, Y+5	; 0x05
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9d 83       	std	Y+5, r25	; 0x05
     316:	8c 83       	std	Y+4, r24	; 0x04
     318:	ec 85       	ldd	r30, Y+12	; 0x0c
     31a:	fd 85       	ldd	r31, Y+13	; 0x0d
     31c:	cf 01       	movw	r24, r30
     31e:	01 96       	adiw	r24, 0x01	; 1
     320:	9d 87       	std	Y+13, r25	; 0x0d
     322:	8c 87       	std	Y+12, r24	; 0x0c
     324:	10 81       	ld	r17, Z
     326:	28 85       	ldd	r18, Y+8	; 0x08
     328:	39 85       	ldd	r19, Y+9	; 0x09
     32a:	82 17       	cp	r24, r18
     32c:	93 07       	cpc	r25, r19
     32e:	20 f0       	brcs	.+8      	; 0x338 <iqGetTimeout+0x4c>
     330:	8e 81       	ldd	r24, Y+6	; 0x06
     332:	9f 81       	ldd	r25, Y+7	; 0x07
     334:	9d 87       	std	Y+13, r25	; 0x0d
     336:	8c 87       	std	Y+12, r24	; 0x0c
     338:	ee 85       	ldd	r30, Y+14	; 0x0e
     33a:	ff 85       	ldd	r31, Y+15	; 0x0f
     33c:	30 97       	sbiw	r30, 0x00	; 0
     33e:	11 f0       	breq	.+4      	; 0x344 <iqGetTimeout+0x58>
     340:	ce 01       	movw	r24, r28
     342:	09 95       	icall
     344:	78 94       	sei
     346:	81 2f       	mov	r24, r17
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	1f 91       	pop	r17
     350:	0f 91       	pop	r16
     352:	08 95       	ret
     354:	78 94       	sei
     356:	df 91       	pop	r29
     358:	cf 91       	pop	r28
     35a:	1f 91       	pop	r17
     35c:	0f 91       	pop	r16
     35e:	08 95       	ret

00000360 <iqReadTimeout>:
     360:	6f 92       	push	r6
     362:	7f 92       	push	r7
     364:	8f 92       	push	r8
     366:	9f 92       	push	r9
     368:	af 92       	push	r10
     36a:	bf 92       	push	r11
     36c:	cf 92       	push	r12
     36e:	df 92       	push	r13
     370:	ef 92       	push	r14
     372:	ff 92       	push	r15
     374:	0f 93       	push	r16
     376:	1f 93       	push	r17
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	6c 01       	movw	r12, r24
     37e:	7b 01       	movw	r14, r22
     380:	3a 01       	movw	r6, r20
     382:	49 01       	movw	r8, r18
     384:	fc 01       	movw	r30, r24
     386:	a6 84       	ldd	r10, Z+14	; 0x0e
     388:	b7 84       	ldd	r11, Z+15	; 0x0f
     38a:	f8 94       	cli
     38c:	41 15       	cp	r20, r1
     38e:	51 05       	cpc	r21, r1
     390:	b9 f0       	breq	.+46     	; 0x3c0 <iqReadTimeout+0x60>
     392:	8a 01       	movw	r16, r20
     394:	a8 01       	movw	r20, r16
     396:	b7 01       	movw	r22, r14
     398:	c6 01       	movw	r24, r12
     39a:	9d de       	rcall	.-710    	; 0xd6 <iq_read>
     39c:	ec 01       	movw	r28, r24
     39e:	89 2b       	or	r24, r25
     3a0:	21 f1       	breq	.+72     	; 0x3ea <iqReadTimeout+0x8a>
     3a2:	a1 14       	cp	r10, r1
     3a4:	b1 04       	cpc	r11, r1
     3a6:	19 f0       	breq	.+6      	; 0x3ae <iqReadTimeout+0x4e>
     3a8:	c6 01       	movw	r24, r12
     3aa:	f5 01       	movw	r30, r10
     3ac:	09 95       	icall
     3ae:	78 94       	sei
     3b0:	0c 1b       	sub	r16, r28
     3b2:	1d 0b       	sbc	r17, r29
     3b4:	ec 0e       	add	r14, r28
     3b6:	fd 1e       	adc	r15, r29
     3b8:	f8 94       	cli
     3ba:	01 15       	cp	r16, r1
     3bc:	11 05       	cpc	r17, r1
     3be:	51 f7       	brne	.-44     	; 0x394 <iqReadTimeout+0x34>
     3c0:	00 e0       	ldi	r16, 0x00	; 0
     3c2:	10 e0       	ldi	r17, 0x00	; 0
     3c4:	78 94       	sei
     3c6:	c3 01       	movw	r24, r6
     3c8:	80 1b       	sub	r24, r16
     3ca:	91 0b       	sbc	r25, r17
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	08 95       	ret
     3ea:	b4 01       	movw	r22, r8
     3ec:	c6 01       	movw	r24, r12
     3ee:	5b d6       	rcall	.+3254   	; 0x10a6 <chThdEnqueueTimeoutS>
     3f0:	89 2b       	or	r24, r25
     3f2:	81 f2       	breq	.-96     	; 0x394 <iqReadTimeout+0x34>
     3f4:	e7 cf       	rjmp	.-50     	; 0x3c4 <iqReadTimeout+0x64>

000003f6 <oqObjectInit>:
     3f6:	af 92       	push	r10
     3f8:	bf 92       	push	r11
     3fa:	cf 92       	push	r12
     3fc:	df 92       	push	r13
     3fe:	ef 92       	push	r14
     400:	ff 92       	push	r15
     402:	0f 93       	push	r16
     404:	1f 93       	push	r17
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	ec 01       	movw	r28, r24
     40c:	5b 01       	movw	r10, r22
     40e:	7a 01       	movw	r14, r20
     410:	69 01       	movw	r12, r18
     412:	43 d6       	rcall	.+3206   	; 0x109a <chThdQueueObjectInit>
     414:	fd 82       	std	Y+5, r15	; 0x05
     416:	ec 82       	std	Y+4, r14	; 0x04
     418:	bf 82       	std	Y+7, r11	; 0x07
     41a:	ae 82       	std	Y+6, r10	; 0x06
     41c:	bd 86       	std	Y+13, r11	; 0x0d
     41e:	ac 86       	std	Y+12, r10	; 0x0c
     420:	bb 86       	std	Y+11, r11	; 0x0b
     422:	aa 86       	std	Y+10, r10	; 0x0a
     424:	ea 0c       	add	r14, r10
     426:	fb 1c       	adc	r15, r11
     428:	f9 86       	std	Y+9, r15	; 0x09
     42a:	e8 86       	std	Y+8, r14	; 0x08
     42c:	df 86       	std	Y+15, r13	; 0x0f
     42e:	ce 86       	std	Y+14, r12	; 0x0e
     430:	19 8b       	std	Y+17, r17	; 0x11
     432:	08 8b       	std	Y+16, r16	; 0x10
     434:	df 91       	pop	r29
     436:	cf 91       	pop	r28
     438:	1f 91       	pop	r17
     43a:	0f 91       	pop	r16
     43c:	ff 90       	pop	r15
     43e:	ef 90       	pop	r14
     440:	df 90       	pop	r13
     442:	cf 90       	pop	r12
     444:	bf 90       	pop	r11
     446:	af 90       	pop	r10
     448:	08 95       	ret

0000044a <oqPutTimeout>:
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
     456:	f6 2e       	mov	r15, r22
     458:	8a 01       	movw	r16, r20
     45a:	f8 94       	cli
     45c:	05 c0       	rjmp	.+10     	; 0x468 <oqPutTimeout+0x1e>
     45e:	b8 01       	movw	r22, r16
     460:	ce 01       	movw	r24, r28
     462:	21 d6       	rcall	.+3138   	; 0x10a6 <chThdEnqueueTimeoutS>
     464:	97 fd       	sbrc	r25, 7
     466:	2a c0       	rjmp	.+84     	; 0x4bc <oqPutTimeout+0x72>
     468:	8c 81       	ldd	r24, Y+4	; 0x04
     46a:	9d 81       	ldd	r25, Y+5	; 0x05
     46c:	89 2b       	or	r24, r25
     46e:	b9 f3       	breq	.-18     	; 0x45e <oqPutTimeout+0x14>
     470:	8c 81       	ldd	r24, Y+4	; 0x04
     472:	9d 81       	ldd	r25, Y+5	; 0x05
     474:	01 97       	sbiw	r24, 0x01	; 1
     476:	9d 83       	std	Y+5, r25	; 0x05
     478:	8c 83       	std	Y+4, r24	; 0x04
     47a:	ea 85       	ldd	r30, Y+10	; 0x0a
     47c:	fb 85       	ldd	r31, Y+11	; 0x0b
     47e:	cf 01       	movw	r24, r30
     480:	01 96       	adiw	r24, 0x01	; 1
     482:	9b 87       	std	Y+11, r25	; 0x0b
     484:	8a 87       	std	Y+10, r24	; 0x0a
     486:	f0 82       	st	Z, r15
     488:	2a 85       	ldd	r18, Y+10	; 0x0a
     48a:	3b 85       	ldd	r19, Y+11	; 0x0b
     48c:	88 85       	ldd	r24, Y+8	; 0x08
     48e:	99 85       	ldd	r25, Y+9	; 0x09
     490:	28 17       	cp	r18, r24
     492:	39 07       	cpc	r19, r25
     494:	20 f0       	brcs	.+8      	; 0x49e <oqPutTimeout+0x54>
     496:	8e 81       	ldd	r24, Y+6	; 0x06
     498:	9f 81       	ldd	r25, Y+7	; 0x07
     49a:	9b 87       	std	Y+11, r25	; 0x0b
     49c:	8a 87       	std	Y+10, r24	; 0x0a
     49e:	ee 85       	ldd	r30, Y+14	; 0x0e
     4a0:	ff 85       	ldd	r31, Y+15	; 0x0f
     4a2:	30 97       	sbiw	r30, 0x00	; 0
     4a4:	11 f0       	breq	.+4      	; 0x4aa <oqPutTimeout+0x60>
     4a6:	ce 01       	movw	r24, r28
     4a8:	09 95       	icall
     4aa:	78 94       	sei
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	df 91       	pop	r29
     4b2:	cf 91       	pop	r28
     4b4:	1f 91       	pop	r17
     4b6:	0f 91       	pop	r16
     4b8:	ff 90       	pop	r15
     4ba:	08 95       	ret
     4bc:	78 94       	sei
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	08 95       	ret

000004ca <oqGetI>:
     4ca:	cf 93       	push	r28
     4cc:	fc 01       	movw	r30, r24
     4ce:	a4 85       	ldd	r26, Z+12	; 0x0c
     4d0:	b5 85       	ldd	r27, Z+13	; 0x0d
     4d2:	82 85       	ldd	r24, Z+10	; 0x0a
     4d4:	93 85       	ldd	r25, Z+11	; 0x0b
     4d6:	8a 17       	cp	r24, r26
     4d8:	9b 07       	cpc	r25, r27
     4da:	e1 f0       	breq	.+56     	; 0x514 <oqGetI+0x4a>
     4dc:	84 81       	ldd	r24, Z+4	; 0x04
     4de:	95 81       	ldd	r25, Z+5	; 0x05
     4e0:	01 96       	adiw	r24, 0x01	; 1
     4e2:	95 83       	std	Z+5, r25	; 0x05
     4e4:	84 83       	std	Z+4, r24	; 0x04
     4e6:	cd 01       	movw	r24, r26
     4e8:	01 96       	adiw	r24, 0x01	; 1
     4ea:	95 87       	std	Z+13, r25	; 0x0d
     4ec:	84 87       	std	Z+12, r24	; 0x0c
     4ee:	cc 91       	ld	r28, X
     4f0:	20 85       	ldd	r18, Z+8	; 0x08
     4f2:	31 85       	ldd	r19, Z+9	; 0x09
     4f4:	82 17       	cp	r24, r18
     4f6:	93 07       	cpc	r25, r19
     4f8:	40 f4       	brcc	.+16     	; 0x50a <oqGetI+0x40>
     4fa:	cf 01       	movw	r24, r30
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	ef d5       	rcall	.+3038   	; 0x10e0 <chThdDequeueNextI>
     502:	8c 2f       	mov	r24, r28
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	cf 91       	pop	r28
     508:	08 95       	ret
     50a:	86 81       	ldd	r24, Z+6	; 0x06
     50c:	97 81       	ldd	r25, Z+7	; 0x07
     50e:	95 87       	std	Z+13, r25	; 0x0d
     510:	84 87       	std	Z+12, r24	; 0x0c
     512:	f3 cf       	rjmp	.-26     	; 0x4fa <oqGetI+0x30>
     514:	84 81       	ldd	r24, Z+4	; 0x04
     516:	95 81       	ldd	r25, Z+5	; 0x05
     518:	89 2b       	or	r24, r25
     51a:	01 f3       	breq	.-64     	; 0x4dc <oqGetI+0x12>
     51c:	8f ef       	ldi	r24, 0xFF	; 255
     51e:	9f ef       	ldi	r25, 0xFF	; 255
     520:	f2 cf       	rjmp	.-28     	; 0x506 <oqGetI+0x3c>

00000522 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     522:	6f 92       	push	r6
     524:	7f 92       	push	r7
     526:	8f 92       	push	r8
     528:	9f 92       	push	r9
     52a:	af 92       	push	r10
     52c:	bf 92       	push	r11
     52e:	cf 92       	push	r12
     530:	df 92       	push	r13
     532:	ef 92       	push	r14
     534:	ff 92       	push	r15
     536:	0f 93       	push	r16
     538:	1f 93       	push	r17
     53a:	cf 93       	push	r28
     53c:	df 93       	push	r29
     53e:	6c 01       	movw	r12, r24
     540:	7b 01       	movw	r14, r22
     542:	3a 01       	movw	r6, r20
     544:	49 01       	movw	r8, r18
  qnotify_t nfy = oqp->q_notify;
     546:	fc 01       	movw	r30, r24
     548:	a6 84       	ldd	r10, Z+14	; 0x0e
     54a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     54c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     54e:	41 15       	cp	r20, r1
     550:	51 05       	cpc	r21, r1
     552:	b9 f0       	breq	.+46     	; 0x582 <oqWriteTimeout+0x60>
     554:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     556:	a8 01       	movw	r20, r16
     558:	b7 01       	movw	r22, r14
     55a:	c6 01       	movw	r24, r12
     55c:	17 de       	rcall	.-978    	; 0x18c <oq_write>
     55e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     560:	89 2b       	or	r24, r25
     562:	21 f1       	breq	.+72     	; 0x5ac <oqWriteTimeout+0x8a>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     564:	a1 14       	cp	r10, r1
     566:	b1 04       	cpc	r11, r1
     568:	19 f0       	breq	.+6      	; 0x570 <oqWriteTimeout+0x4e>
        nfy(oqp);
     56a:	c6 01       	movw	r24, r12
     56c:	f5 01       	movw	r30, r10
     56e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     570:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     572:	0c 1b       	sub	r16, r28
     574:	1d 0b       	sbc	r17, r29
      bp += done;
     576:	ec 0e       	add	r14, r28
     578:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     57a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     57c:	01 15       	cp	r16, r1
     57e:	11 05       	cpc	r17, r1
     580:	51 f7       	brne	.-44     	; 0x556 <oqWriteTimeout+0x34>
     582:	00 e0       	ldi	r16, 0x00	; 0
     584:	10 e0       	ldi	r17, 0x00	; 0
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     586:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     588:	c3 01       	movw	r24, r6
     58a:	80 1b       	sub	r24, r16
     58c:	91 0b       	sbc	r25, r17
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	1f 91       	pop	r17
     594:	0f 91       	pop	r16
     596:	ff 90       	pop	r15
     598:	ef 90       	pop	r14
     59a:	df 90       	pop	r13
     59c:	cf 90       	pop	r12
     59e:	bf 90       	pop	r11
     5a0:	af 90       	pop	r10
     5a2:	9f 90       	pop	r9
     5a4:	8f 90       	pop	r8
     5a6:	7f 90       	pop	r7
     5a8:	6f 90       	pop	r6
     5aa:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     5ac:	b4 01       	movw	r22, r8
     5ae:	c6 01       	movw	r24, r12
     5b0:	7a d5       	rcall	.+2804   	; 0x10a6 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     5b2:	89 2b       	or	r24, r25
     5b4:	81 f2       	breq	.-96     	; 0x556 <oqWriteTimeout+0x34>
     5b6:	e7 cf       	rjmp	.-50     	; 0x586 <oqWriteTimeout+0x64>

000005b8 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     5b8:	05 96       	adiw	r24, 0x05	; 5
     5ba:	d2 ce       	rjmp	.-604    	; 0x360 <iqReadTimeout>

000005bc <_read>:
     5bc:	2f ef       	ldi	r18, 0xFF	; 255
     5be:	3f ef       	ldi	r19, 0xFF	; 255
     5c0:	05 96       	adiw	r24, 0x05	; 5
     5c2:	ce ce       	rjmp	.-612    	; 0x360 <iqReadTimeout>

000005c4 <_writet>:
     5c4:	47 96       	adiw	r24, 0x17	; 23
     5c6:	ad cf       	rjmp	.-166    	; 0x522 <oqWriteTimeout>

000005c8 <_write>:
     5c8:	2f ef       	ldi	r18, 0xFF	; 255
     5ca:	3f ef       	ldi	r19, 0xFF	; 255
     5cc:	47 96       	adiw	r24, 0x17	; 23
     5ce:	a9 cf       	rjmp	.-174    	; 0x522 <oqWriteTimeout>

000005d0 <_gett>:
     5d0:	05 96       	adiw	r24, 0x05	; 5
     5d2:	8c ce       	rjmp	.-744    	; 0x2ec <iqGetTimeout>

000005d4 <_get>:
     5d4:	6f ef       	ldi	r22, 0xFF	; 255
     5d6:	7f ef       	ldi	r23, 0xFF	; 255
     5d8:	05 96       	adiw	r24, 0x05	; 5
     5da:	88 ce       	rjmp	.-752    	; 0x2ec <iqGetTimeout>

000005dc <_putt>:
     5dc:	47 96       	adiw	r24, 0x17	; 23
     5de:	35 cf       	rjmp	.-406    	; 0x44a <oqPutTimeout>

000005e0 <_put>:
     5e0:	4f ef       	ldi	r20, 0xFF	; 255
     5e2:	5f ef       	ldi	r21, 0xFF	; 255
     5e4:	47 96       	adiw	r24, 0x17	; 23
     5e6:	31 cf       	rjmp	.-414    	; 0x44a <oqPutTimeout>

000005e8 <_ctl>:
     5e8:	61 30       	cpi	r22, 0x01	; 1
     5ea:	71 05       	cpc	r23, r1
     5ec:	19 f0       	breq	.+6      	; 0x5f4 <_ctl+0xc>
     5ee:	8c ee       	ldi	r24, 0xEC	; 236
     5f0:	9f ef       	ldi	r25, 0xFF	; 255
     5f2:	08 95       	ret
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	08 95       	ret

000005fa <sdInit>:
     5fa:	55 c1       	rjmp	.+682    	; 0x8a6 <sd_lld_init>

000005fc <sdObjectInit>:
     5fc:	cf 92       	push	r12
     5fe:	df 92       	push	r13
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
     60e:	6b 01       	movw	r12, r22
     610:	7a 01       	movw	r14, r20
     612:	24 e0       	ldi	r18, 0x04	; 4
     614:	31 e0       	ldi	r19, 0x01	; 1
     616:	fc 01       	movw	r30, r24
     618:	21 93       	st	Z+, r18
     61a:	31 93       	st	Z+, r19
     61c:	cf 01       	movw	r24, r30
     61e:	41 d7       	rcall	.+3714   	; 0x14a2 <chEvtObjectInit>
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	8c 83       	std	Y+4, r24	; 0x04
     624:	be 01       	movw	r22, r28
     626:	67 5d       	subi	r22, 0xD7	; 215
     628:	7f 4f       	sbci	r23, 0xFF	; 255
     62a:	8e 01       	movw	r16, r28
     62c:	96 01       	movw	r18, r12
     62e:	40 e1       	ldi	r20, 0x10	; 16
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	ce 01       	movw	r24, r28
     634:	05 96       	adiw	r24, 0x05	; 5
     636:	05 de       	rcall	.-1014   	; 0x242 <iqObjectInit>
     638:	be 01       	movw	r22, r28
     63a:	67 5c       	subi	r22, 0xC7	; 199
     63c:	7f 4f       	sbci	r23, 0xFF	; 255
     63e:	97 01       	movw	r18, r14
     640:	40 e1       	ldi	r20, 0x10	; 16
     642:	50 e0       	ldi	r21, 0x00	; 0
     644:	ce 01       	movw	r24, r28
     646:	47 96       	adiw	r24, 0x17	; 23
     648:	d6 de       	rcall	.-596    	; 0x3f6 <oqObjectInit>
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	ff 90       	pop	r15
     654:	ef 90       	pop	r14
     656:	df 90       	pop	r13
     658:	cf 90       	pop	r12
     65a:	08 95       	ret

0000065c <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	ec 01       	movw	r28, r24
     664:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     666:	89 85       	ldd	r24, Y+9	; 0x09
     668:	9a 85       	ldd	r25, Y+10	; 0x0a
     66a:	89 2b       	or	r24, r25
     66c:	51 f0       	breq	.+20     	; 0x682 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     66e:	61 2f       	mov	r22, r17
     670:	ce 01       	movw	r24, r28
     672:	05 96       	adiw	r24, 0x05	; 5
     674:	10 de       	rcall	.-992    	; 0x296 <iqPutI>
     676:	97 fd       	sbrc	r25, 7
     678:	0e c0       	rjmp	.+28     	; 0x696 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     67a:	df 91       	pop	r29
     67c:	cf 91       	pop	r28
     67e:	1f 91       	pop	r17
     680:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     682:	64 e0       	ldi	r22, 0x04	; 4
     684:	ce 01       	movw	r24, r28
     686:	02 96       	adiw	r24, 0x02	; 2
     688:	26 d7       	rcall	.+3660   	; 0x14d6 <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     68a:	61 2f       	mov	r22, r17
     68c:	ce 01       	movw	r24, r28
     68e:	05 96       	adiw	r24, 0x05	; 5
     690:	02 de       	rcall	.-1020   	; 0x296 <iqPutI>
     692:	97 ff       	sbrs	r25, 7
     694:	f2 cf       	rjmp	.-28     	; 0x67a <sdIncomingDataI+0x1e>
     696:	60 e0       	ldi	r22, 0x00	; 0
     698:	ce 01       	movw	r24, r28
     69a:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	19 c7       	rjmp	.+3634   	; 0x14d6 <chEvtBroadcastFlagsI>

000006a4 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
     6ac:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     6ae:	47 96       	adiw	r24, 0x17	; 23
     6b0:	0c df       	rcall	.-488    	; 0x4ca <oqGetI>
     6b2:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     6b4:	97 fd       	sbrc	r25, 7
     6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     6b8:	ce 01       	movw	r24, r28
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	08 95       	ret
     6c4:	68 e0       	ldi	r22, 0x08	; 8
     6c6:	c8 01       	movw	r24, r16
     6c8:	02 96       	adiw	r24, 0x02	; 2
     6ca:	05 d7       	rcall	.+3594   	; 0x14d6 <chEvtBroadcastFlagsI>
     6cc:	ce 01       	movw	r24, r28
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	1f 91       	pop	r17
     6d4:	0f 91       	pop	r16
     6d6:	08 95       	ret

000006d8 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6d8:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6dc:	1d ba       	out	0x1d, r1	; 29
     6de:	08 95       	ret

000006e0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
     6e0:	08 95       	ret

000006e2 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6e2:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6e4:	80 81       	ld	r24, Z
     6e6:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6e8:	81 81       	ldd	r24, Z+1	; 0x01
     6ea:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ec:	82 81       	ldd	r24, Z+2	; 0x02
     6ee:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6f0:	83 81       	ldd	r24, Z+3	; 0x03
     6f2:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6f4:	84 81       	ldd	r24, Z+4	; 0x04
     6f6:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6f8:	85 81       	ldd	r24, Z+5	; 0x05
     6fa:	8a b9       	out	0x0a, r24	; 10
     6fc:	08 95       	ret

000006fe <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
     6fe:	fc 01       	movw	r30, r24

  switch (mode) {
     700:	42 30       	cpi	r20, 0x02	; 2
     702:	c9 f0       	breq	.+50     	; 0x736 <_pal_lld_setgroupmode+0x38>
     704:	98 f0       	brcs	.+38     	; 0x72c <_pal_lld_setgroupmode+0x2e>
     706:	45 30       	cpi	r20, 0x05	; 5
     708:	b1 f0       	breq	.+44     	; 0x736 <_pal_lld_setgroupmode+0x38>
     70a:	46 30       	cpi	r20, 0x06	; 6
     70c:	21 f4       	brne	.+8      	; 0x716 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
     70e:	81 81       	ldd	r24, Z+1	; 0x01
     710:	68 2b       	or	r22, r24
     712:	61 83       	std	Z+1, r22	; 0x01
     714:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     716:	43 30       	cpi	r20, 0x03	; 3
     718:	e9 f7       	brne	.-6      	; 0x714 <_pal_lld_setgroupmode+0x16>
    port->dir &= ~mask;
    port->out &= ~mask;
    break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
     71a:	81 81       	ldd	r24, Z+1	; 0x01
     71c:	96 2f       	mov	r25, r22
     71e:	90 95       	com	r25
     720:	89 23       	and	r24, r25
     722:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
     724:	82 81       	ldd	r24, Z+2	; 0x02
     726:	68 2b       	or	r22, r24
     728:	62 83       	std	Z+2, r22	; 0x02
    break;
     72a:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     72c:	44 23       	and	r20, r20
     72e:	19 f0       	breq	.+6      	; 0x736 <_pal_lld_setgroupmode+0x38>
     730:	41 30       	cpi	r20, 0x01	; 1
     732:	99 f3       	breq	.-26     	; 0x71a <_pal_lld_setgroupmode+0x1c>
     734:	08 95       	ret
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
     736:	81 81       	ldd	r24, Z+1	; 0x01
     738:	60 95       	com	r22
     73a:	86 23       	and	r24, r22
     73c:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
     73e:	82 81       	ldd	r24, Z+2	; 0x02
     740:	68 23       	and	r22, r24
     742:	62 83       	std	Z+2, r22	; 0x02
    break;
     744:	08 95       	ret

00000746 <__vector_14>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
     746:	1f 92       	push	r1
     748:	0f 92       	push	r0
     74a:	0f b6       	in	r0, 0x3f	; 63
     74c:	0f 92       	push	r0
     74e:	11 24       	eor	r1, r1
     750:	2f 93       	push	r18
     752:	3f 93       	push	r19
     754:	4f 93       	push	r20
     756:	5f 93       	push	r21
     758:	6f 93       	push	r22
     75a:	7f 93       	push	r23
     75c:	8f 93       	push	r24
     75e:	9f 93       	push	r25
     760:	af 93       	push	r26
     762:	bf 93       	push	r27
     764:	ef 93       	push	r30
     766:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     76e:	b7 d0       	rcall	.+366    	; 0x8de <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     770:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     774:	a4 d2       	rcall	.+1352   	; 0xcbe <chSchIsPreemptionRequired>
     776:	81 11       	cpse	r24, r1
     778:	b2 d2       	rcall	.+1380   	; 0xcde <chSchDoPreemption>
}
     77a:	ff 91       	pop	r31
     77c:	ef 91       	pop	r30
     77e:	bf 91       	pop	r27
     780:	af 91       	pop	r26
     782:	9f 91       	pop	r25
     784:	8f 91       	pop	r24
     786:	7f 91       	pop	r23
     788:	6f 91       	pop	r22
     78a:	5f 91       	pop	r21
     78c:	4f 91       	pop	r20
     78e:	3f 91       	pop	r19
     790:	2f 91       	pop	r18
     792:	0f 90       	pop	r0
     794:	0f be       	out	0x3f, r0	; 63
     796:	0f 90       	pop	r0
     798:	1f 90       	pop	r1
     79a:	18 95       	reti

0000079c <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators.               */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.       */
     79c:	82 e0       	ldi	r24, 0x02	; 2
     79e:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.  */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.  */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.       */
     7a0:	85 bd       	out	0x25, r24	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
     7a2:	9f e7       	ldi	r25, 0x7F	; 127
     7a4:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.  */
     7a6:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.  */
     7a8:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare. */
     7aa:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
     7ae:	08 95       	ret

000007b0 <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     7b0:	e1 ec       	ldi	r30, 0xC1	; 193
     7b2:	f0 e0       	ldi	r31, 0x00	; 0
     7b4:	80 81       	ld	r24, Z
     7b6:	80 62       	ori	r24, 0x20	; 32
     7b8:	80 83       	st	Z, r24
     7ba:	08 95       	ret

000007bc <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     7bc:	1f 92       	push	r1
     7be:	0f 92       	push	r0
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	0f 92       	push	r0
     7c4:	11 24       	eor	r1, r1
     7c6:	2f 93       	push	r18
     7c8:	3f 93       	push	r19
     7ca:	4f 93       	push	r20
     7cc:	5f 93       	push	r21
     7ce:	6f 93       	push	r22
     7d0:	7f 93       	push	r23
     7d2:	8f 93       	push	r24
     7d4:	9f 93       	push	r25
     7d6:	af 93       	push	r26
     7d8:	bf 93       	push	r27
     7da:	ef 93       	push	r30
     7dc:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>

  sra = UCSR0A;
     7e4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7e8:	98 2f       	mov	r25, r24
     7ea:	9c 71       	andi	r25, 0x1C	; 28
     7ec:	41 f0       	breq	.+16     	; 0x7fe <__vector_18+0x42>
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7ee:	82 fd       	sbrc	r24, 2
     7f0:	21 c0       	rjmp	.+66     	; 0x834 <__DATA_REGION_LENGTH__+0x34>
     7f2:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7f4:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
     7f6:	60 64       	ori	r22, 0x40	; 64
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7f8:	89 e3       	ldi	r24, 0x39	; 57
     7fa:	94 e0       	ldi	r25, 0x04	; 4
     7fc:	6c d6       	rcall	.+3288   	; 0x14d6 <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7fe:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     802:	87 e3       	ldi	r24, 0x37	; 55
     804:	94 e0       	ldi	r25, 0x04	; 4
     806:	2a df       	rcall	.-428    	; 0x65c <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     808:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     80c:	58 d2       	rcall	.+1200   	; 0xcbe <chSchIsPreemptionRequired>
     80e:	81 11       	cpse	r24, r1
     810:	66 d2       	rcall	.+1228   	; 0xcde <chSchDoPreemption>
}
     812:	ff 91       	pop	r31
     814:	ef 91       	pop	r30
     816:	bf 91       	pop	r27
     818:	af 91       	pop	r26
     81a:	9f 91       	pop	r25
     81c:	8f 91       	pop	r24
     81e:	7f 91       	pop	r23
     820:	6f 91       	pop	r22
     822:	5f 91       	pop	r21
     824:	4f 91       	pop	r20
     826:	3f 91       	pop	r19
     828:	2f 91       	pop	r18
     82a:	0f 90       	pop	r0
     82c:	0f be       	out	0x3f, r0	; 63
     82e:	0f 90       	pop	r0
     830:	1f 90       	pop	r1
     832:	18 95       	reti
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     834:	60 e2       	ldi	r22, 0x20	; 32
     836:	de cf       	rjmp	.-68     	; 0x7f4 <__vector_18+0x38>

00000838 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     838:	1f 92       	push	r1
     83a:	0f 92       	push	r0
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	0f 92       	push	r0
     840:	11 24       	eor	r1, r1
     842:	2f 93       	push	r18
     844:	3f 93       	push	r19
     846:	4f 93       	push	r20
     848:	5f 93       	push	r21
     84a:	6f 93       	push	r22
     84c:	7f 93       	push	r23
     84e:	8f 93       	push	r24
     850:	9f 93       	push	r25
     852:	af 93       	push	r26
     854:	bf 93       	push	r27
     856:	ef 93       	push	r30
     858:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     860:	87 e3       	ldi	r24, 0x37	; 55
     862:	94 e0       	ldi	r25, 0x04	; 4
     864:	1f df       	rcall	.-450    	; 0x6a4 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     866:	97 fd       	sbrc	r25, 7
     868:	18 c0       	rjmp	.+48     	; 0x89a <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     86a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     86e:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     872:	25 d2       	rcall	.+1098   	; 0xcbe <chSchIsPreemptionRequired>
     874:	81 11       	cpse	r24, r1
     876:	33 d2       	rcall	.+1126   	; 0xcde <chSchDoPreemption>
}
     878:	ff 91       	pop	r31
     87a:	ef 91       	pop	r30
     87c:	bf 91       	pop	r27
     87e:	af 91       	pop	r26
     880:	9f 91       	pop	r25
     882:	8f 91       	pop	r24
     884:	7f 91       	pop	r23
     886:	6f 91       	pop	r22
     888:	5f 91       	pop	r21
     88a:	4f 91       	pop	r20
     88c:	3f 91       	pop	r19
     88e:	2f 91       	pop	r18
     890:	0f 90       	pop	r0
     892:	0f be       	out	0x3f, r0	; 63
     894:	0f 90       	pop	r0
     896:	1f 90       	pop	r1
     898:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     89a:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     89e:	8f 7d       	andi	r24, 0xDF	; 223
     8a0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8a4:	e4 cf       	rjmp	.-56     	; 0x86e <__vector_19+0x36>

000008a6 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     8a6:	48 ed       	ldi	r20, 0xD8	; 216
     8a8:	53 e0       	ldi	r21, 0x03	; 3
     8aa:	60 e0       	ldi	r22, 0x00	; 0
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	87 e3       	ldi	r24, 0x37	; 55
     8b0:	94 e0       	ldi	r25, 0x04	; 4
     8b2:	a4 ce       	rjmp	.-696    	; 0x5fc <sdObjectInit>

000008b4 <chSysInit>:
    /* Registry header, access to this list depends on the current
       kernel configuration.*/
    rqp = REG_HEADER(oip);

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	c0 e8       	ldi	r28, 0x80	; 128
     8ba:	d4 e0       	ldi	r29, 0x04	; 4
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	88 83       	st	Y, r24
     8c0:	1a 82       	std	Y+2, r1	; 0x02
     8c2:	19 82       	std	Y+1, r1	; 0x01
     8c4:	2d d6       	rcall	.+3162   	; 0x1520 <__core_init>
     8c6:	6d d6       	rcall	.+3290   	; 0x15a2 <__heap_init>
     8c8:	61 e2       	ldi	r22, 0x21	; 33
     8ca:	71 e0       	ldi	r23, 0x01	; 1
     8cc:	83 e8       	ldi	r24, 0x83	; 131
     8ce:	94 e0       	ldi	r25, 0x04	; 4
     8d0:	56 d2       	rcall	.+1196   	; 0xd7e <chInstanceObjectInit>
     8d2:	82 e0       	ldi	r24, 0x02	; 2
     8d4:	88 83       	st	Y, r24
     8d6:	78 94       	sei
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     8de:	68 c0       	rjmp	.+208    	; 0x9b0 <chVTDoTickI>

000008e0 <chVTDoSetI>:
    dlp = dlp->next;
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
     8e0:	cf 93       	push	r28
     8e2:	df 93       	push	r29
     8e4:	dc 01       	movw	r26, r24
     8e6:	19 96       	adiw	r26, 0x09	; 9
     8e8:	3c 93       	st	X, r19
     8ea:	2e 93       	st	-X, r18
     8ec:	18 97       	sbiw	r26, 0x08	; 8
     8ee:	17 96       	adiw	r26, 0x07	; 7
     8f0:	5c 93       	st	X, r21
     8f2:	4e 93       	st	-X, r20
     8f4:	16 97       	sbiw	r26, 0x06	; 6
     8f6:	1b 96       	adiw	r26, 0x0b	; 11
     8f8:	1c 92       	st	X, r1
     8fa:	1e 92       	st	-X, r1
     8fc:	1a 97       	sbiw	r26, 0x0a	; 10
     8fe:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <ch0+0x7>
     902:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <ch0+0x8>
     906:	24 81       	ldd	r18, Z+4	; 0x04
     908:	35 81       	ldd	r19, Z+5	; 0x05
     90a:	26 17       	cp	r18, r22
     90c:	37 07       	cpc	r19, r23
     90e:	50 f4       	brcc	.+20     	; 0x924 <__stack+0x25>
     910:	62 1b       	sub	r22, r18
     912:	73 0b       	sbc	r23, r19
     914:	01 90       	ld	r0, Z+
     916:	f0 81       	ld	r31, Z
     918:	e0 2d       	mov	r30, r0
     91a:	24 81       	ldd	r18, Z+4	; 0x04
     91c:	35 81       	ldd	r19, Z+5	; 0x05
     91e:	26 17       	cp	r18, r22
     920:	37 07       	cpc	r19, r23
     922:	b0 f3       	brcs	.-20     	; 0x910 <__stack+0x11>
     924:	15 96       	adiw	r26, 0x05	; 5
     926:	7c 93       	st	X, r23
     928:	6e 93       	st	-X, r22
     92a:	14 97       	sbiw	r26, 0x04	; 4
     92c:	11 96       	adiw	r26, 0x01	; 1
     92e:	fc 93       	st	X, r31
     930:	ee 93       	st	-X, r30
     932:	c2 81       	ldd	r28, Z+2	; 0x02
     934:	d3 81       	ldd	r29, Z+3	; 0x03
     936:	13 96       	adiw	r26, 0x03	; 3
     938:	dc 93       	st	X, r29
     93a:	ce 93       	st	-X, r28
     93c:	12 97       	sbiw	r26, 0x02	; 2
     93e:	b9 83       	std	Y+1, r27	; 0x01
     940:	a8 83       	st	Y, r26
     942:	b3 83       	std	Z+3, r27	; 0x03
     944:	a2 83       	std	Z+2, r26	; 0x02
     946:	84 81       	ldd	r24, Z+4	; 0x04
     948:	95 81       	ldd	r25, Z+5	; 0x05
     94a:	86 1b       	sub	r24, r22
     94c:	97 0b       	sbc	r25, r23
     94e:	95 83       	std	Z+5, r25	; 0x05
     950:	84 83       	std	Z+4, r24	; 0x04
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	9f ef       	ldi	r25, 0xFF	; 255
     956:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <ch0+0xc>
     95a:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <ch0+0xb>
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	08 95       	ret

00000964 <chVTDoResetI>:
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	fc 01       	movw	r30, r24
     96a:	a0 81       	ld	r26, Z
     96c:	b1 81       	ldd	r27, Z+1	; 0x01
     96e:	14 96       	adiw	r26, 0x04	; 4
     970:	2d 91       	ld	r18, X+
     972:	3c 91       	ld	r19, X
     974:	15 97       	sbiw	r26, 0x05	; 5
     976:	84 81       	ldd	r24, Z+4	; 0x04
     978:	95 81       	ldd	r25, Z+5	; 0x05
     97a:	82 0f       	add	r24, r18
     97c:	93 1f       	adc	r25, r19
     97e:	15 96       	adiw	r26, 0x05	; 5
     980:	9c 93       	st	X, r25
     982:	8e 93       	st	-X, r24
     984:	14 97       	sbiw	r26, 0x04	; 4
     986:	c2 81       	ldd	r28, Z+2	; 0x02
     988:	d3 81       	ldd	r29, Z+3	; 0x03
     98a:	b9 83       	std	Y+1, r27	; 0x01
     98c:	a8 83       	st	Y, r26
     98e:	a0 81       	ld	r26, Z
     990:	b1 81       	ldd	r27, Z+1	; 0x01
     992:	13 96       	adiw	r26, 0x03	; 3
     994:	dc 93       	st	X, r29
     996:	ce 93       	st	-X, r28
     998:	12 97       	sbiw	r26, 0x02	; 2
     99a:	11 82       	std	Z+1, r1	; 0x01
     99c:	10 82       	st	Z, r1
     99e:	8f ef       	ldi	r24, 0xFF	; 255
     9a0:	9f ef       	ldi	r25, 0xFF	; 255
     9a2:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <ch0+0xc>
     9a6:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <ch0+0xb>
     9aa:	df 91       	pop	r29
     9ac:	cf 91       	pop	r28
     9ae:	08 95       	ret

000009b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     9b0:	0f 93       	push	r16
     9b2:	1f 93       	push	r17
     9b4:	cf 93       	push	r28
     9b6:	df 93       	push	r29
  virtual_timers_list_t *vtlp = &currcore->vtlist;

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
     9b8:	80 91 90 04 	lds	r24, 0x0490	; 0x800490 <ch0+0xd>
     9bc:	90 91 91 04 	lds	r25, 0x0491	; 0x800491 <ch0+0xe>
     9c0:	01 96       	adiw	r24, 0x01	; 1
     9c2:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <ch0+0xe>
     9c6:	80 93 90 04 	sts	0x0490, r24	; 0x800490 <ch0+0xd>
 *
 * @notapi
 */
static inline bool ch_dlist_notempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp != dlhp->next);
     9ca:	c0 91 8a 04 	lds	r28, 0x048A	; 0x80048a <ch0+0x7>
     9ce:	d0 91 8b 04 	lds	r29, 0x048B	; 0x80048b <ch0+0x8>
  if (ch_dlist_notempty(&vtlp->dlist)) {
     9d2:	44 e0       	ldi	r20, 0x04	; 4
     9d4:	ca 38       	cpi	r28, 0x8A	; 138
     9d6:	d4 07       	cpc	r29, r20
     9d8:	41 f1       	breq	.+80     	; 0xa2a <chVTDoTickI+0x7a>
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
     9da:	8c 81       	ldd	r24, Y+4	; 0x04
     9dc:	9d 81       	ldd	r25, Y+5	; 0x05
     9de:	01 97       	sbiw	r24, 0x01	; 1
     9e0:	9d 83       	std	Y+5, r25	; 0x05
     9e2:	8c 83       	std	Y+4, r24	; 0x04
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     9e4:	0f ef       	ldi	r16, 0xFF	; 255
     9e6:	1f ef       	ldi	r17, 0xFF	; 255
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     9e8:	1e c0       	rjmp	.+60     	; 0xa26 <chVTDoTickI+0x76>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     9ea:	ea 81       	ldd	r30, Y+2	; 0x02
     9ec:	fb 81       	ldd	r31, Y+3	; 0x03
     9ee:	88 81       	ld	r24, Y
     9f0:	99 81       	ldd	r25, Y+1	; 0x01
     9f2:	91 83       	std	Z+1, r25	; 0x01
     9f4:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     9f6:	a8 81       	ld	r26, Y
     9f8:	b9 81       	ldd	r27, Y+1	; 0x01
     9fa:	13 96       	adiw	r26, 0x03	; 3
     9fc:	fc 93       	st	X, r31
     9fe:	ee 93       	st	-X, r30
     a00:	12 97       	sbiw	r26, 0x02	; 2
      /* Triggered timer.*/
      vtp = (virtual_timer_t *)vtlp->dlist.next;

      /* Removing the element from the delta list, marking it as not armed.*/
      (void) ch_dlist_dequeue(&vtp->dlist);
      vtp->dlist.next = NULL;
     a02:	19 82       	std	Y+1, r1	; 0x01
     a04:	18 82       	st	Y, r1

      chSysUnlockFromISR();
      vtp->func(vtp, vtp->par);
     a06:	68 85       	ldd	r22, Y+8	; 0x08
     a08:	79 85       	ldd	r23, Y+9	; 0x09
     a0a:	ee 81       	ldd	r30, Y+6	; 0x06
     a0c:	ff 81       	ldd	r31, Y+7	; 0x07
     a0e:	ce 01       	movw	r24, r28
     a10:	09 95       	icall
      chSysLockFromISR();

      /* If a reload is defined the timer needs to be restarted.*/
      if (vtp->reload > (sysinterval_t)0) {
     a12:	8a 85       	ldd	r24, Y+10	; 0x0a
     a14:	9b 85       	ldd	r25, Y+11	; 0x0b
     a16:	00 97       	sbiw	r24, 0x00	; 0
     a18:	69 f4       	brne	.+26     	; 0xa34 <chVTDoTickI+0x84>
     a1a:	c0 91 8a 04 	lds	r28, 0x048A	; 0x80048a <ch0+0x7>
     a1e:	d0 91 8b 04 	lds	r29, 0x048B	; 0x80048b <ch0+0x8>
     a22:	8c 81       	ldd	r24, Y+4	; 0x04
     a24:	9d 81       	ldd	r25, Y+5	; 0x05
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
  if (ch_dlist_notempty(&vtlp->dlist)) {
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a26:	89 2b       	or	r24, r25
     a28:	01 f3       	breq	.-64     	; 0x9ea <chVTDoTickI+0x3a>
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	1f 91       	pop	r17
     a30:	0f 91       	pop	r16
     a32:	08 95       	ret
     a34:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <ch0+0x7>
     a38:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <ch0+0x8>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a3c:	24 81       	ldd	r18, Z+4	; 0x04
     a3e:	35 81       	ldd	r19, Z+5	; 0x05
     a40:	28 17       	cp	r18, r24
     a42:	39 07       	cpc	r19, r25
     a44:	50 f4       	brcc	.+20     	; 0xa5a <chVTDoTickI+0xaa>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     a46:	82 1b       	sub	r24, r18
     a48:	93 0b       	sbc	r25, r19
    dlp = dlp->next;
     a4a:	01 90       	ld	r0, Z+
     a4c:	f0 81       	ld	r31, Z
     a4e:	e0 2d       	mov	r30, r0
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a50:	24 81       	ldd	r18, Z+4	; 0x04
     a52:	35 81       	ldd	r19, Z+5	; 0x05
     a54:	28 17       	cp	r18, r24
     a56:	39 07       	cpc	r19, r25
     a58:	b0 f3       	brcs	.-20     	; 0xa46 <chVTDoTickI+0x96>
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     a5a:	9d 83       	std	Y+5, r25	; 0x05
     a5c:	8c 83       	std	Y+4, r24	; 0x04
  dlp->next       = dlhp;
     a5e:	f9 83       	std	Y+1, r31	; 0x01
     a60:	e8 83       	st	Y, r30
  dlp->prev       = dlp->next->prev;
     a62:	a2 81       	ldd	r26, Z+2	; 0x02
     a64:	b3 81       	ldd	r27, Z+3	; 0x03
     a66:	bb 83       	std	Y+3, r27	; 0x03
     a68:	aa 83       	std	Y+2, r26	; 0x02
  dlp->prev->next = dlp;
     a6a:	cd 93       	st	X+, r28
     a6c:	dc 93       	st	X, r29
  dlhp->prev      = dlp;
     a6e:	d3 83       	std	Z+3, r29	; 0x03
     a70:	c2 83       	std	Z+2, r28	; 0x02

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     a72:	24 81       	ldd	r18, Z+4	; 0x04
     a74:	35 81       	ldd	r19, Z+5	; 0x05
     a76:	a9 01       	movw	r20, r18
     a78:	48 1b       	sub	r20, r24
     a7a:	59 0b       	sbc	r21, r25
     a7c:	55 83       	std	Z+5, r21	; 0x05
     a7e:	44 83       	std	Z+4, r20	; 0x04

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     a80:	10 93 8f 04 	sts	0x048F, r17	; 0x80048f <ch0+0xc>
     a84:	00 93 8e 04 	sts	0x048E, r16	; 0x80048e <ch0+0xb>
     a88:	c8 cf       	rjmp	.-112    	; 0xa1a <chVTDoTickI+0x6a>

00000a8a <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     a8a:	cf 93       	push	r28
     a8c:	df 93       	push	r29
     a8e:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     a90:	1f 96       	adiw	r26, 0x0f	; 15
     a92:	8c 91       	ld	r24, X
     a94:	1f 97       	sbiw	r26, 0x0f	; 15
     a96:	84 30       	cpi	r24, 0x04	; 4
     a98:	f1 f1       	breq	.+124    	; 0xb16 <__sch_wakeup+0x8c>
     a9a:	80 f5       	brcc	.+96     	; 0xafc <__sch_wakeup+0x72>
     a9c:	88 23       	and	r24, r24
     a9e:	59 f1       	breq	.+86     	; 0xaf6 <__sch_wakeup+0x6c>
     aa0:	83 30       	cpi	r24, 0x03	; 3
     aa2:	31 f4       	brne	.+12     	; 0xab0 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     aa4:	52 96       	adiw	r26, 0x12	; 18
     aa6:	ed 91       	ld	r30, X+
     aa8:	fc 91       	ld	r31, X
     aaa:	53 97       	sbiw	r26, 0x13	; 19
     aac:	11 82       	std	Z+1, r1	; 0x01
     aae:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     ab0:	8f ef       	ldi	r24, 0xFF	; 255
     ab2:	9f ef       	ldi	r25, 0xFF	; 255
     ab4:	53 96       	adiw	r26, 0x13	; 19
     ab6:	9c 93       	st	X, r25
     ab8:	8e 93       	st	-X, r24
     aba:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     abc:	1f 96       	adiw	r26, 0x0f	; 15
     abe:	1c 92       	st	X, r1
     ac0:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     ac2:	1b 96       	adiw	r26, 0x0b	; 11
     ac4:	ed 91       	ld	r30, X+
     ac6:	fc 91       	ld	r31, X
     ac8:	1c 97       	sbiw	r26, 0x0c	; 12
     aca:	14 96       	adiw	r26, 0x04	; 4
     acc:	9c 91       	ld	r25, X
     ace:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     ad0:	01 90       	ld	r0, Z+
     ad2:	f0 81       	ld	r31, Z
     ad4:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     ad6:	84 81       	ldd	r24, Z+4	; 0x04
     ad8:	89 17       	cp	r24, r25
     ada:	d0 f7       	brcc	.-12     	; 0xad0 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     adc:	11 96       	adiw	r26, 0x01	; 1
     ade:	fc 93       	st	X, r31
     ae0:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ae2:	c2 81       	ldd	r28, Z+2	; 0x02
     ae4:	d3 81       	ldd	r29, Z+3	; 0x03
     ae6:	13 96       	adiw	r26, 0x03	; 3
     ae8:	dc 93       	st	X, r29
     aea:	ce 93       	st	-X, r28
     aec:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     aee:	b9 83       	std	Y+1, r27	; 0x01
     af0:	a8 83       	st	Y, r26
  pqp->prev     = p;
     af2:	b3 83       	std	Z+3, r27	; 0x03
     af4:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     afc:	87 30       	cpi	r24, 0x07	; 7
     afe:	59 f0       	breq	.+22     	; 0xb16 <__sch_wakeup+0x8c>
     b00:	8c 30       	cpi	r24, 0x0C	; 12
     b02:	49 f0       	breq	.+18     	; 0xb16 <__sch_wakeup+0x8c>
     b04:	85 30       	cpi	r24, 0x05	; 5
     b06:	a1 f6       	brne	.-88     	; 0xab0 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     b08:	52 96       	adiw	r26, 0x12	; 18
     b0a:	ed 91       	ld	r30, X+
     b0c:	fc 91       	ld	r31, X
     b0e:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     b10:	84 81       	ldd	r24, Z+4	; 0x04
     b12:	8f 5f       	subi	r24, 0xFF	; 255
     b14:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     b16:	12 96       	adiw	r26, 0x02	; 2
     b18:	ed 91       	ld	r30, X+
     b1a:	fc 91       	ld	r31, X
     b1c:	13 97       	sbiw	r26, 0x03	; 3
     b1e:	8d 91       	ld	r24, X+
     b20:	9c 91       	ld	r25, X
     b22:	11 97       	sbiw	r26, 0x01	; 1
     b24:	91 83       	std	Z+1, r25	; 0x01
     b26:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     b28:	cd 91       	ld	r28, X+
     b2a:	dc 91       	ld	r29, X
     b2c:	11 97       	sbiw	r26, 0x01	; 1
     b2e:	fb 83       	std	Y+3, r31	; 0x03
     b30:	ea 83       	std	Y+2, r30	; 0x02
     b32:	be cf       	rjmp	.-132    	; 0xab0 <__sch_wakeup+0x26>

00000b34 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b3a:	1f 96       	adiw	r26, 0x0f	; 15
     b3c:	1c 92       	st	X, r1
     b3e:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b40:	1b 96       	adiw	r26, 0x0b	; 11
     b42:	ed 91       	ld	r30, X+
     b44:	fc 91       	ld	r31, X
     b46:	1c 97       	sbiw	r26, 0x0c	; 12
     b48:	14 96       	adiw	r26, 0x04	; 4
     b4a:	2c 91       	ld	r18, X
     b4c:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b4e:	01 90       	ld	r0, Z+
     b50:	f0 81       	ld	r31, Z
     b52:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b54:	94 81       	ldd	r25, Z+4	; 0x04
     b56:	92 17       	cp	r25, r18
     b58:	d0 f7       	brcc	.-12     	; 0xb4e <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     b5a:	11 96       	adiw	r26, 0x01	; 1
     b5c:	fc 93       	st	X, r31
     b5e:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     b60:	c2 81       	ldd	r28, Z+2	; 0x02
     b62:	d3 81       	ldd	r29, Z+3	; 0x03
     b64:	13 96       	adiw	r26, 0x03	; 3
     b66:	dc 93       	st	X, r29
     b68:	ce 93       	st	-X, r28
     b6a:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     b6c:	b9 83       	std	Y+1, r27	; 0x01
     b6e:	a8 83       	st	Y, r26
  pqp->prev     = p;
     b70:	b3 83       	std	Z+3, r27	; 0x03
     b72:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     b74:	cd 01       	movw	r24, r26
     b76:	df 91       	pop	r29
     b78:	cf 91       	pop	r28
     b7a:	08 95       	ret

00000b7c <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     b80:	e3 e8       	ldi	r30, 0x83	; 131
     b82:	f4 e0       	ldi	r31, 0x04	; 4
     b84:	65 81       	ldd	r22, Z+5	; 0x05
     b86:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     b88:	db 01       	movw	r26, r22
     b8a:	1f 96       	adiw	r26, 0x0f	; 15
     b8c:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     b8e:	80 81       	ld	r24, Z
     b90:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     b92:	ec 01       	movw	r28, r24
     b94:	a8 81       	ld	r26, Y
     b96:	b9 81       	ldd	r27, Y+1	; 0x01
     b98:	b1 83       	std	Z+1, r27	; 0x01
     b9a:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     b9c:	13 96       	adiw	r26, 0x03	; 3
     b9e:	fc 93       	st	X, r31
     ba0:	ee 93       	st	-X, r30
     ba2:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     ba4:	21 e0       	ldi	r18, 0x01	; 1
     ba6:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     ba8:	96 83       	std	Z+6, r25	; 0x06
     baa:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     bac:	0e d5       	rcall	.+2588   	; 0x15ca <_port_switch>
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     bb4:	ff 92       	push	r15
     bb6:	0f 93       	push	r16
     bb8:	1f 93       	push	r17
     bba:	cf 93       	push	r28
     bbc:	df 93       	push	r29
     bbe:	cd b7       	in	r28, 0x3d	; 61
     bc0:	de b7       	in	r29, 0x3e	; 62
     bc2:	2c 97       	sbiw	r28, 0x0c	; 12
     bc4:	0f b6       	in	r0, 0x3f	; 63
     bc6:	f8 94       	cli
     bc8:	de bf       	out	0x3e, r29	; 62
     bca:	0f be       	out	0x3f, r0	; 63
     bcc:	cd bf       	out	0x3d, r28	; 61
     bce:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     bd0:	00 91 88 04 	lds	r16, 0x0488	; 0x800488 <ch0+0x5>
     bd4:	10 91 89 04 	lds	r17, 0x0489	; 0x800489 <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     bd8:	6f 3f       	cpi	r22, 0xFF	; 255
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	78 07       	cpc	r23, r24
     bde:	f1 f0       	breq	.+60     	; 0xc1c <chSchGoSleepTimeoutS+0x68>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     be0:	98 01       	movw	r18, r16
     be2:	45 e4       	ldi	r20, 0x45	; 69
     be4:	55 e0       	ldi	r21, 0x05	; 5
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	7a de       	rcall	.-780    	; 0x8e0 <chVTDoSetI>
    chSchGoSleepS(newstate);
     bec:	8f 2d       	mov	r24, r15
     bee:	c6 df       	rcall	.-116    	; 0xb7c <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     bf0:	89 81       	ldd	r24, Y+1	; 0x01
     bf2:	9a 81       	ldd	r25, Y+2	; 0x02
     bf4:	89 2b       	or	r24, r25
     bf6:	19 f0       	breq	.+6      	; 0xbfe <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     bf8:	ce 01       	movw	r24, r28
     bfa:	01 96       	adiw	r24, 0x01	; 1
     bfc:	b3 de       	rcall	.-666    	; 0x964 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     bfe:	f8 01       	movw	r30, r16
     c00:	82 89       	ldd	r24, Z+18	; 0x12
     c02:	93 89       	ldd	r25, Z+19	; 0x13
     c04:	2c 96       	adiw	r28, 0x0c	; 12
     c06:	0f b6       	in	r0, 0x3f	; 63
     c08:	f8 94       	cli
     c0a:	de bf       	out	0x3e, r29	; 62
     c0c:	0f be       	out	0x3f, r0	; 63
     c0e:	cd bf       	out	0x3d, r28	; 61
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	1f 91       	pop	r17
     c16:	0f 91       	pop	r16
     c18:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     c1a:	08 95       	ret
     c1c:	8f 2d       	mov	r24, r15
     c1e:	ae df       	rcall	.-164    	; 0xb7c <chSchGoSleepS>
     c20:	ee cf       	rjmp	.-36     	; 0xbfe <chSchGoSleepTimeoutS+0x4a>

00000c22 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     c28:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
     c2c:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     c30:	53 96       	adiw	r26, 0x13	; 19
     c32:	7c 93       	st	X, r23
     c34:	6e 93       	st	-X, r22
     c36:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     c38:	14 96       	adiw	r26, 0x04	; 4
     c3a:	2c 91       	ld	r18, X
     c3c:	14 97       	sbiw	r26, 0x04	; 4
     c3e:	8c 81       	ldd	r24, Y+4	; 0x04
     c40:	82 17       	cp	r24, r18
     c42:	e8 f0       	brcs	.+58     	; 0xc7e <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c44:	1f 96       	adiw	r26, 0x0f	; 15
     c46:	1c 92       	st	X, r1
     c48:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     c4a:	1b 96       	adiw	r26, 0x0b	; 11
     c4c:	ed 91       	ld	r30, X+
     c4e:	fc 91       	ld	r31, X
     c50:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c52:	01 90       	ld	r0, Z+
     c54:	f0 81       	ld	r31, Z
     c56:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     c58:	94 81       	ldd	r25, Z+4	; 0x04
     c5a:	92 17       	cp	r25, r18
     c5c:	d0 f7       	brcc	.-12     	; 0xc52 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     c5e:	11 96       	adiw	r26, 0x01	; 1
     c60:	fc 93       	st	X, r31
     c62:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     c64:	c2 81       	ldd	r28, Z+2	; 0x02
     c66:	d3 81       	ldd	r29, Z+3	; 0x03
     c68:	13 96       	adiw	r26, 0x03	; 3
     c6a:	dc 93       	st	X, r29
     c6c:	ce 93       	st	-X, r28
     c6e:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     c70:	b9 83       	std	Y+1, r27	; 0x01
     c72:	a8 83       	st	Y, r26
  pqp->prev     = p;
     c74:	b3 83       	std	Z+3, r27	; 0x03
     c76:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c7e:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     c80:	eb 85       	ldd	r30, Y+11	; 0x0b
     c82:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c84:	01 90       	ld	r0, Z+
     c86:	f0 81       	ld	r31, Z
     c88:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     c8a:	94 81       	ldd	r25, Z+4	; 0x04
     c8c:	89 17       	cp	r24, r25
     c8e:	d0 f3       	brcs	.-12     	; 0xc84 <chSchWakeupS+0x62>
     c90:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     c92:	f9 83       	std	Y+1, r31	; 0x01
     c94:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     c96:	a2 81       	ldd	r26, Z+2	; 0x02
     c98:	b3 81       	ldd	r27, Z+3	; 0x03
     c9a:	bb 83       	std	Y+3, r27	; 0x03
     c9c:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     c9e:	cd 93       	st	X+, r28
     ca0:	dc 93       	st	X, r29
  pqp->prev     = p;
     ca2:	d3 83       	std	Z+3, r29	; 0x03
     ca4:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     ca6:	21 e0       	ldi	r18, 0x01	; 1
     ca8:	fc 01       	movw	r30, r24
     caa:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     cac:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <ch0+0x6>
     cb0:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     cb4:	be 01       	movw	r22, r28
     cb6:	89 d4       	rcall	.+2322   	; 0x15ca <_port_switch>
  }
}
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	08 95       	ret

00000cbe <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     cbe:	a0 91 83 04 	lds	r26, 0x0483	; 0x800483 <ch0>
     cc2:	b0 91 84 04 	lds	r27, 0x0484	; 0x800484 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     cc6:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
     cca:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	14 96       	adiw	r26, 0x04	; 4
     cd2:	2c 91       	ld	r18, X
     cd4:	94 81       	ldd	r25, Z+4	; 0x04
     cd6:	92 17       	cp	r25, r18
     cd8:	08 f0       	brcs	.+2      	; 0xcdc <chSchIsPreemptionRequired+0x1e>
     cda:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     cdc:	08 95       	ret

00000cde <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     ce2:	a0 91 88 04 	lds	r26, 0x0488	; 0x800488 <ch0+0x5>
     ce6:	b0 91 89 04 	lds	r27, 0x0489	; 0x800489 <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     cea:	40 91 83 04 	lds	r20, 0x0483	; 0x800483 <ch0>
     cee:	50 91 84 04 	lds	r21, 0x0484	; 0x800484 <ch0+0x1>

  pqp->next       = p->next;
     cf2:	ea 01       	movw	r28, r20
     cf4:	e8 81       	ld	r30, Y
     cf6:	f9 81       	ldd	r31, Y+1	; 0x01
     cf8:	f0 93 84 04 	sts	0x0484, r31	; 0x800484 <ch0+0x1>
     cfc:	e0 93 83 04 	sts	0x0483, r30	; 0x800483 <ch0>
  pqp->next->prev = pqp;
     d00:	83 e8       	ldi	r24, 0x83	; 131
     d02:	94 e0       	ldi	r25, 0x04	; 4
     d04:	93 83       	std	Z+3, r25	; 0x03
     d06:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
     d0c:	50 93 89 04 	sts	0x0489, r21	; 0x800489 <ch0+0x6>
     d10:	40 93 88 04 	sts	0x0488, r20	; 0x800488 <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     d14:	1f 96       	adiw	r26, 0x0f	; 15
     d16:	1c 92       	st	X, r1
     d18:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     d1a:	1b 96       	adiw	r26, 0x0b	; 11
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X
     d20:	1c 97       	sbiw	r26, 0x0c	; 12
     d22:	14 96       	adiw	r26, 0x04	; 4
     d24:	2c 91       	ld	r18, X
     d26:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     d28:	01 90       	ld	r0, Z+
     d2a:	f0 81       	ld	r31, Z
     d2c:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     d2e:	94 81       	ldd	r25, Z+4	; 0x04
     d30:	29 17       	cp	r18, r25
     d32:	d0 f3       	brcs	.-12     	; 0xd28 <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
     d34:	11 96       	adiw	r26, 0x01	; 1
     d36:	fc 93       	st	X, r31
     d38:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     d3a:	82 81       	ldd	r24, Z+2	; 0x02
     d3c:	93 81       	ldd	r25, Z+3	; 0x03
     d3e:	13 96       	adiw	r26, 0x03	; 3
     d40:	9c 93       	st	X, r25
     d42:	8e 93       	st	-X, r24
     d44:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     d46:	ec 01       	movw	r28, r24
     d48:	b9 83       	std	Y+1, r27	; 0x01
     d4a:	a8 83       	st	Y, r26
  pqp->prev     = p;
     d4c:	b3 83       	std	Z+3, r27	; 0x03
     d4e:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     d50:	bd 01       	movw	r22, r26
     d52:	ca 01       	movw	r24, r20
     d54:	3a d4       	rcall	.+2164   	; 0x15ca <_port_switch>
}
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	08 95       	ret

00000d5c <chSchPreemption>:
 * @special
 */
void chSchPreemption(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     d5c:	a0 91 83 04 	lds	r26, 0x0483	; 0x800483 <ch0>
     d60:	b0 91 84 04 	lds	r27, 0x0484	; 0x800484 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     d64:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
     d68:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
    if (likely(p1 >= p2)) {
      __sch_reschedule_behind();
    }
  }
#else /* CH_CFG_TIME_QUANTUM == 0 */
  if (likely(p1 > p2)) {
     d6c:	14 96       	adiw	r26, 0x04	; 4
     d6e:	9c 91       	ld	r25, X
     d70:	84 81       	ldd	r24, Z+4	; 0x04
     d72:	89 17       	cp	r24, r25
     d74:	08 f0       	brcs	.+2      	; 0xd78 <chSchPreemption+0x1c>
     d76:	08 95       	ret
    __sch_reschedule_ahead();
     d78:	b2 cf       	rjmp	.-156    	; 0xcde <chSchDoPreemption>

00000d7a <chSchRescheduleS>:
     d7a:	f0 cf       	rjmp	.-32     	; 0xd5c <chSchPreemption>

00000d7c <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
     d7c:	ff cf       	rjmp	.-2      	; 0xd7c <__idle_thread>

00000d7e <chInstanceObjectInit>:
 * @param[in] oicp      pointer to an @p os_instance_config_t object
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
     d7e:	df 92       	push	r13
     d80:	ef 92       	push	r14
     d82:	ff 92       	push	r15
     d84:	0f 93       	push	r16
     d86:	1f 93       	push	r17
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
     d90:	2b 97       	sbiw	r28, 0x0b	; 11
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	de bf       	out	0x3e, r29	; 62
     d98:	0f be       	out	0x3f, r0	; 63
     d9a:	cd bf       	out	0x3d, r28	; 61
     d9c:	8c 01       	movw	r16, r24
     d9e:	7b 01       	movw	r14, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
     da0:	90 93 82 04 	sts	0x0482, r25	; 0x800482 <ch_system+0x2>
     da4:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
     da8:	fc 01       	movw	r30, r24
     daa:	14 8e       	std	Z+28, r1	; 0x1c
     dac:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
     dae:	72 a3       	std	Z+34, r23	; 0x22
     db0:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
     db2:	dd 24       	eor	r13, r13
     db4:	d3 94       	inc	r13
     db6:	d0 92 ca 04 	sts	0x04CA, r13	; 0x8004ca <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
     dba:	91 83       	std	Z+1, r25	; 0x01
     dbc:	80 83       	st	Z, r24
  pqp->prev = pqp;
     dbe:	93 83       	std	Z+3, r25	; 0x03
     dc0:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
     dc2:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
     dc4:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
     dc6:	90 8f       	std	Z+24, r25	; 0x18
     dc8:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
     dca:	92 8f       	std	Z+26, r25	; 0x1a
     dcc:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
     dce:	15 8e       	std	Z+29, r1	; 0x1d
     dd0:	16 8e       	std	Z+30, r1	; 0x1e
     dd2:	17 8e       	std	Z+31, r1	; 0x1f
     dd4:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
     dd6:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
     dd8:	90 87       	std	Z+8, r25	; 0x08
     dda:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
     ddc:	92 87       	std	Z+10, r25	; 0x0a
     dde:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
     de0:	8f ef       	ldi	r24, 0xFF	; 255
     de2:	9f ef       	ldi	r25, 0xFF	; 255
     de4:	94 87       	std	Z+12, r25	; 0x0c
     de6:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
     de8:	16 86       	std	Z+14, r1	; 0x0e
     dea:	15 86       	std	Z+13, r1	; 0x0d
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
     dec:	20 91 90 04 	lds	r18, 0x0490	; 0x800490 <ch0+0xd>
     df0:	30 91 91 04 	lds	r19, 0x0491	; 0x800491 <ch0+0xe>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
     df4:	27 87       	std	Z+15, r18	; 0x0f
     df6:	30 8b       	std	Z+16, r19	; 0x10
     df8:	11 8a       	std	Z+17, r1	; 0x11
     dfa:	12 8a       	std	Z+18, r1	; 0x12
     dfc:	13 8a       	std	Z+19, r1	; 0x13
     dfe:	14 8a       	std	Z+20, r1	; 0x14
     e00:	15 8a       	std	Z+21, r1	; 0x15
     e02:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
     e04:	ef 5b       	subi	r30, 0xBF	; 191
     e06:	ff 4f       	sbci	r31, 0xFF	; 255
     e08:	11 82       	std	Z+1, r1	; 0x01
     e0a:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
     e0c:	b8 01       	movw	r22, r16
     e0e:	6d 5d       	subi	r22, 0xDD	; 221
     e10:	7f 4f       	sbci	r23, 0xFF	; 255
     e12:	20 e8       	ldi	r18, 0x80	; 128
     e14:	43 e3       	ldi	r20, 0x33	; 51
     e16:	51 e0       	ldi	r21, 0x01	; 1
     e18:	c8 01       	movw	r24, r16
     e1a:	2a d0       	rcall	.+84     	; 0xe70 <__thd_object_init>
     e1c:	f8 01       	movw	r30, r16
     e1e:	96 83       	std	Z+6, r25	; 0x06
     e20:	85 83       	std	Z+5, r24	; 0x05
  oip->rlist.current->wabase = oicp->mainthread_base;
  oip->rlist.current->waend  = oicp->mainthread_end;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
     e22:	fc 01       	movw	r30, r24
     e24:	d7 86       	std	Z+15, r13	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
     e26:	87 e2       	ldi	r24, 0x27	; 39
     e28:	91 e0       	ldi	r25, 0x01	; 1
     e2a:	9a 83       	std	Y+2, r25	; 0x02
     e2c:	89 83       	std	Y+1, r24	; 0x01
     e2e:	f7 01       	movw	r30, r14
     e30:	82 81       	ldd	r24, Z+2	; 0x02
     e32:	93 81       	ldd	r25, Z+3	; 0x03
     e34:	9c 83       	std	Y+4, r25	; 0x04
     e36:	8b 83       	std	Y+3, r24	; 0x03
     e38:	84 81       	ldd	r24, Z+4	; 0x04
     e3a:	95 81       	ldd	r25, Z+5	; 0x05
     e3c:	9e 83       	std	Y+6, r25	; 0x06
     e3e:	8d 83       	std	Y+5, r24	; 0x05
     e40:	df 82       	std	Y+7, r13	; 0x07
     e42:	8e eb       	ldi	r24, 0xBE	; 190
     e44:	96 e0       	ldi	r25, 0x06	; 6
     e46:	99 87       	std	Y+9, r25	; 0x09
     e48:	88 87       	std	Y+8, r24	; 0x08
     e4a:	1b 86       	std	Y+11, r1	; 0x0b
     e4c:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	9e d0       	rcall	.+316    	; 0xf90 <chThdCreateI>
  }
#endif
}
     e54:	2b 96       	adiw	r28, 0x0b	; 11
     e56:	0f b6       	in	r0, 0x3f	; 63
     e58:	f8 94       	cli
     e5a:	de bf       	out	0x3e, r29	; 62
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	cd bf       	out	0x3d, r28	; 61
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	ff 90       	pop	r15
     e6a:	ef 90       	pop	r14
     e6c:	df 90       	pop	r13
     e6e:	08 95       	ret

00000e70 <__thd_object_init>:
 *
 * @param[in] tqp       pointer to a @p threads_queue_t object
 *
 * @dispose
 */
void chThdQueueObjectDispose(threads_queue_t *tqp) {
     e70:	cf 93       	push	r28
     e72:	df 93       	push	r29
     e74:	fb 01       	movw	r30, r22
     e76:	24 83       	std	Z+4, r18	; 0x04
     e78:	32 e0       	ldi	r19, 0x02	; 2
     e7a:	37 87       	std	Z+15, r19	; 0x0f
     e7c:	10 8a       	std	Z+16, r1	; 0x10
     e7e:	94 87       	std	Z+12, r25	; 0x0c
     e80:	83 87       	std	Z+11, r24	; 0x0b
     e82:	25 8f       	std	Z+29, r18	; 0x1d
     e84:	14 8e       	std	Z+28, r1	; 0x1c
     e86:	13 8e       	std	Z+27, r1	; 0x1b
     e88:	12 8e       	std	Z+26, r1	; 0x1a
     e8a:	21 e0       	ldi	r18, 0x01	; 1
     e8c:	21 8b       	std	Z+17, r18	; 0x11
     e8e:	56 87       	std	Z+14, r21	; 0x0e
     e90:	45 87       	std	Z+13, r20	; 0x0d
     e92:	9b 01       	movw	r18, r22
     e94:	29 5f       	subi	r18, 0xF9	; 249
     e96:	3f 4f       	sbci	r19, 0xFF	; 255
     e98:	ac 01       	movw	r20, r24
     e9a:	49 5e       	subi	r20, 0xE9	; 233
     e9c:	5f 4f       	sbci	r21, 0xFF	; 255
     e9e:	50 87       	std	Z+8, r21	; 0x08
     ea0:	47 83       	std	Z+7, r20	; 0x07
     ea2:	ec 01       	movw	r28, r24
     ea4:	a9 8d       	ldd	r26, Y+25	; 0x19
     ea6:	ba 8d       	ldd	r27, Y+26	; 0x1a
     ea8:	b2 87       	std	Z+10, r27	; 0x0a
     eaa:	a1 87       	std	Z+9, r26	; 0x09
     eac:	2d 93       	st	X+, r18
     eae:	3c 93       	st	X, r19
     eb0:	3a 8f       	std	Y+26, r19	; 0x1a
     eb2:	29 8f       	std	Y+25, r18	; 0x19
     eb4:	cb 01       	movw	r24, r22
     eb6:	44 96       	adiw	r24, 0x14	; 20
     eb8:	95 8b       	std	Z+21, r25	; 0x15
     eba:	84 8b       	std	Z+20, r24	; 0x14
     ebc:	02 96       	adiw	r24, 0x02	; 2
     ebe:	97 8b       	std	Z+23, r25	; 0x17
     ec0:	86 8b       	std	Z+22, r24	; 0x16
     ec2:	91 8f       	std	Z+25, r25	; 0x19
     ec4:	80 8f       	std	Z+24, r24	; 0x18
     ec6:	cb 01       	movw	r24, r22
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	08 95       	ret

00000ece <chThdCreateSuspendedI>:
     ece:	cf 93       	push	r28
     ed0:	df 93       	push	r29
     ed2:	dc 01       	movw	r26, r24
     ed4:	14 96       	adiw	r26, 0x04	; 4
     ed6:	2d 91       	ld	r18, X+
     ed8:	3c 91       	ld	r19, X
     eda:	15 97       	sbiw	r26, 0x05	; 5
     edc:	f9 01       	movw	r30, r18
     ede:	7e 97       	sbiw	r30, 0x1e	; 30
     ee0:	e9 01       	movw	r28, r18
     ee2:	e3 97       	sbiw	r28, 0x33	; 51
     ee4:	d6 83       	std	Z+6, r29	; 0x06
     ee6:	c5 83       	std	Z+5, r28	; 0x05
     ee8:	17 96       	adiw	r26, 0x07	; 7
     eea:	8c 91       	ld	r24, X
     eec:	17 97       	sbiw	r26, 0x07	; 7
     eee:	8a 8b       	std	Y+18, r24	; 0x12
     ef0:	18 96       	adiw	r26, 0x08	; 8
     ef2:	8c 91       	ld	r24, X
     ef4:	18 97       	sbiw	r26, 0x08	; 8
     ef6:	89 8b       	std	Y+17, r24	; 0x11
     ef8:	19 96       	adiw	r26, 0x09	; 9
     efa:	8c 91       	ld	r24, X
     efc:	19 97       	sbiw	r26, 0x09	; 9
     efe:	88 8b       	std	Y+16, r24	; 0x10
     f00:	1a 96       	adiw	r26, 0x0a	; 10
     f02:	8c 91       	ld	r24, X
     f04:	1a 97       	sbiw	r26, 0x0a	; 10
     f06:	8f 87       	std	Y+15, r24	; 0x0f
     f08:	84 e1       	ldi	r24, 0x14	; 20
     f0a:	9b e0       	ldi	r25, 0x0B	; 11
     f0c:	9b 8b       	std	Y+19, r25	; 0x13
     f0e:	8c 8b       	std	Y+20, r24	; 0x14
     f10:	16 96       	adiw	r26, 0x06	; 6
     f12:	8c 91       	ld	r24, X
     f14:	16 97       	sbiw	r26, 0x06	; 6
     f16:	4d 91       	ld	r20, X+
     f18:	5c 91       	ld	r21, X
     f1a:	84 83       	std	Z+4, r24	; 0x04
     f1c:	92 e0       	ldi	r25, 0x02	; 2
     f1e:	97 87       	std	Z+15, r25	; 0x0f
     f20:	10 8a       	std	Z+16, r1	; 0x10
     f22:	63 e8       	ldi	r22, 0x83	; 131
     f24:	74 e0       	ldi	r23, 0x04	; 4
     f26:	74 87       	std	Z+12, r23	; 0x0c
     f28:	63 87       	std	Z+11, r22	; 0x0b
     f2a:	85 8f       	std	Z+29, r24	; 0x1d
     f2c:	14 8e       	std	Z+28, r1	; 0x1c
     f2e:	13 8e       	std	Z+27, r1	; 0x1b
     f30:	12 8e       	std	Z+26, r1	; 0x1a
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	81 8b       	std	Z+17, r24	; 0x11
     f36:	56 87       	std	Z+14, r21	; 0x0e
     f38:	45 87       	std	Z+13, r20	; 0x0d
     f3a:	d9 01       	movw	r26, r18
     f3c:	57 97       	sbiw	r26, 0x17	; 23
     f3e:	8a e9       	ldi	r24, 0x9A	; 154
     f40:	94 e0       	ldi	r25, 0x04	; 4
     f42:	11 96       	adiw	r26, 0x01	; 1
     f44:	9c 93       	st	X, r25
     f46:	8e 93       	st	-X, r24
     f48:	eb 01       	movw	r28, r22
     f4a:	89 8d       	ldd	r24, Y+25	; 0x19
     f4c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f4e:	13 96       	adiw	r26, 0x03	; 3
     f50:	9c 93       	st	X, r25
     f52:	8e 93       	st	-X, r24
     f54:	12 97       	sbiw	r26, 0x02	; 2
     f56:	ec 01       	movw	r28, r24
     f58:	b9 83       	std	Y+1, r27	; 0x01
     f5a:	a8 83       	st	Y, r26
     f5c:	eb 01       	movw	r28, r22
     f5e:	ba 8f       	std	Y+26, r27	; 0x1a
     f60:	a9 8f       	std	Y+25, r26	; 0x19
     f62:	1d 96       	adiw	r26, 0x0d	; 13
     f64:	0b 2e       	mov	r0, r27
     f66:	11 96       	adiw	r26, 0x01	; 1
     f68:	0c 92       	st	X, r0
     f6a:	11 97       	sbiw	r26, 0x01	; 1
     f6c:	ac 93       	st	X, r26
     f6e:	12 96       	adiw	r26, 0x02	; 2
     f70:	0b 2e       	mov	r0, r27
     f72:	11 96       	adiw	r26, 0x01	; 1
     f74:	0c 92       	st	X, r0
     f76:	11 97       	sbiw	r26, 0x01	; 1
     f78:	ac 93       	st	X, r26
     f7a:	0a 2e       	mov	r0, r26
     f7c:	1b 2e       	mov	r1, r27
     f7e:	13 96       	adiw	r26, 0x03	; 3
     f80:	1c 92       	st	X, r1
     f82:	0e 92       	st	-X, r0
     f84:	11 24       	eor	r1, r1
     f86:	12 97       	sbiw	r26, 0x02	; 2
     f88:	cf 01       	movw	r24, r30
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	08 95       	ret

00000f90 <chThdCreateI>:
     f90:	9e df       	rcall	.-196    	; 0xece <chThdCreateSuspendedI>
     f92:	d0 cd       	rjmp	.-1120   	; 0xb34 <chSchReadyI>

00000f94 <chThdCreateStatic>:
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	f8 94       	cli
     f9e:	6e 51       	subi	r22, 0x1E	; 30
     fa0:	71 09       	sbc	r23, r1
     fa2:	ec 01       	movw	r28, r24
     fa4:	c6 0f       	add	r28, r22
     fa6:	d7 1f       	adc	r29, r23
     fa8:	fe 01       	movw	r30, r28
     faa:	75 97       	sbiw	r30, 0x15	; 21
     fac:	fe 83       	std	Y+6, r31	; 0x06
     fae:	ed 83       	std	Y+5, r30	; 0x05
     fb0:	22 8b       	std	Z+18, r18	; 0x12
     fb2:	31 8b       	std	Z+17, r19	; 0x11
     fb4:	00 8b       	std	Z+16, r16	; 0x10
     fb6:	17 87       	std	Z+15, r17	; 0x0f
     fb8:	84 e1       	ldi	r24, 0x14	; 20
     fba:	9b e0       	ldi	r25, 0x0B	; 11
     fbc:	93 8b       	std	Z+19, r25	; 0x13
     fbe:	84 8b       	std	Z+20, r24	; 0x14
     fc0:	4c 83       	std	Y+4, r20	; 0x04
     fc2:	82 e0       	ldi	r24, 0x02	; 2
     fc4:	8f 87       	std	Y+15, r24	; 0x0f
     fc6:	18 8a       	std	Y+16, r1	; 0x10
     fc8:	e3 e8       	ldi	r30, 0x83	; 131
     fca:	f4 e0       	ldi	r31, 0x04	; 4
     fcc:	fc 87       	std	Y+12, r31	; 0x0c
     fce:	eb 87       	std	Y+11, r30	; 0x0b
     fd0:	4d 8f       	std	Y+29, r20	; 0x1d
     fd2:	1c 8e       	std	Y+28, r1	; 0x1c
     fd4:	1b 8e       	std	Y+27, r1	; 0x1b
     fd6:	1a 8e       	std	Y+26, r1	; 0x1a
     fd8:	81 e0       	ldi	r24, 0x01	; 1
     fda:	89 8b       	std	Y+17, r24	; 0x11
     fdc:	8c e2       	ldi	r24, 0x2C	; 44
     fde:	91 e0       	ldi	r25, 0x01	; 1
     fe0:	9e 87       	std	Y+14, r25	; 0x0e
     fe2:	8d 87       	std	Y+13, r24	; 0x0d
     fe4:	ce 01       	movw	r24, r28
     fe6:	07 96       	adiw	r24, 0x07	; 7
     fe8:	2a e9       	ldi	r18, 0x9A	; 154
     fea:	34 e0       	ldi	r19, 0x04	; 4
     fec:	38 87       	std	Y+8, r19	; 0x08
     fee:	2f 83       	std	Y+7, r18	; 0x07
     ff0:	a1 8d       	ldd	r26, Z+25	; 0x19
     ff2:	b2 8d       	ldd	r27, Z+26	; 0x1a
     ff4:	ba 87       	std	Y+10, r27	; 0x0a
     ff6:	a9 87       	std	Y+9, r26	; 0x09
     ff8:	8d 93       	st	X+, r24
     ffa:	9c 93       	st	X, r25
     ffc:	92 8f       	std	Z+26, r25	; 0x1a
     ffe:	81 8f       	std	Z+25, r24	; 0x19
    1000:	0d 96       	adiw	r24, 0x0d	; 13
    1002:	9d 8b       	std	Y+21, r25	; 0x15
    1004:	8c 8b       	std	Y+20, r24	; 0x14
    1006:	02 96       	adiw	r24, 0x02	; 2
    1008:	9f 8b       	std	Y+23, r25	; 0x17
    100a:	8e 8b       	std	Y+22, r24	; 0x16
    100c:	99 8f       	std	Y+25, r25	; 0x19
    100e:	88 8f       	std	Y+24, r24	; 0x18
    1010:	60 e0       	ldi	r22, 0x00	; 0
    1012:	70 e0       	ldi	r23, 0x00	; 0
    1014:	ce 01       	movw	r24, r28
    1016:	05 de       	rcall	.-1014   	; 0xc22 <chSchWakeupS>
    1018:	78 94       	sei
    101a:	ce 01       	movw	r24, r28
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	08 95       	ret

00001026 <chThdExitS>:
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
    1032:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
    1036:	9b 8b       	std	Y+19, r25	; 0x13
    1038:	8a 8b       	std	Y+18, r24	; 0x12
    103a:	8e 01       	movw	r16, r28
    103c:	0c 5e       	subi	r16, 0xEC	; 236
    103e:	1f 4f       	sbci	r17, 0xFF	; 255
    1040:	8c 89       	ldd	r24, Y+20	; 0x14
    1042:	9d 89       	ldd	r25, Y+21	; 0x15
    1044:	08 17       	cp	r16, r24
    1046:	19 07       	cpc	r17, r25
    1048:	59 f0       	breq	.+22     	; 0x1060 <chThdExitS+0x3a>
    104a:	fc 01       	movw	r30, r24
    104c:	20 81       	ld	r18, Z
    104e:	31 81       	ldd	r19, Z+1	; 0x01
    1050:	3d 8b       	std	Y+21, r19	; 0x15
    1052:	2c 8b       	std	Y+20, r18	; 0x14
    1054:	6f dd       	rcall	.-1314   	; 0xb34 <chSchReadyI>
    1056:	8c 89       	ldd	r24, Y+20	; 0x14
    1058:	9d 89       	ldd	r25, Y+21	; 0x15
    105a:	80 17       	cp	r24, r16
    105c:	91 07       	cpc	r25, r17
    105e:	a9 f7       	brne	.-22     	; 0x104a <chThdExitS+0x24>
    1060:	89 89       	ldd	r24, Y+17	; 0x11
    1062:	81 11       	cpse	r24, r1
    1064:	0c c0       	rjmp	.+24     	; 0x107e <chThdExitS+0x58>
    1066:	e9 85       	ldd	r30, Y+9	; 0x09
    1068:	fa 85       	ldd	r31, Y+10	; 0x0a
    106a:	8f 81       	ldd	r24, Y+7	; 0x07
    106c:	98 85       	ldd	r25, Y+8	; 0x08
    106e:	91 83       	std	Z+1, r25	; 0x01
    1070:	80 83       	st	Z, r24
    1072:	af 81       	ldd	r26, Y+7	; 0x07
    1074:	b8 85       	ldd	r27, Y+8	; 0x08
    1076:	13 96       	adiw	r26, 0x03	; 3
    1078:	fc 93       	st	X, r31
    107a:	ee 93       	st	-X, r30
    107c:	12 97       	sbiw	r26, 0x02	; 2
    107e:	8f e0       	ldi	r24, 0x0F	; 15
    1080:	df 91       	pop	r29
    1082:	cf 91       	pop	r28
    1084:	1f 91       	pop	r17
    1086:	0f 91       	pop	r16
    1088:	79 cd       	rjmp	.-1294   	; 0xb7c <chSchGoSleepS>

0000108a <chThdExit>:
    108a:	f8 94       	cli
    108c:	cc cf       	rjmp	.-104    	; 0x1026 <chThdExitS>

0000108e <chThdSleep>:
    108e:	f8 94       	cli
    1090:	bc 01       	movw	r22, r24
    1092:	88 e0       	ldi	r24, 0x08	; 8
    1094:	8f dd       	rcall	.-1250   	; 0xbb4 <chSchGoSleepTimeoutS>
    1096:	78 94       	sei
    1098:	08 95       	ret

0000109a <chThdQueueObjectInit>:
    109a:	fc 01       	movw	r30, r24
    109c:	91 83       	std	Z+1, r25	; 0x01
    109e:	80 83       	st	Z, r24
    10a0:	93 83       	std	Z+3, r25	; 0x03
    10a2:	82 83       	std	Z+2, r24	; 0x02
    10a4:	08 95       	ret

000010a6 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    10a6:	cf 93       	push	r28
    10a8:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    10aa:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
    10ae:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    10b2:	61 15       	cp	r22, r1
    10b4:	71 05       	cpc	r23, r1
    10b6:	79 f0       	breq	.+30     	; 0x10d6 <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    10b8:	91 83       	std	Z+1, r25	; 0x01
    10ba:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    10bc:	ec 01       	movw	r28, r24
    10be:	aa 81       	ldd	r26, Y+2	; 0x02
    10c0:	bb 81       	ldd	r27, Y+3	; 0x03
    10c2:	b3 83       	std	Z+3, r27	; 0x03
    10c4:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    10c6:	ed 93       	st	X+, r30
    10c8:	fc 93       	st	X, r31
  qp->prev      = p;
    10ca:	fb 83       	std	Y+3, r31	; 0x03
    10cc:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    10ce:	84 e0       	ldi	r24, 0x04	; 4
}
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    10d4:	6f cd       	rjmp	.-1314   	; 0xbb4 <chSchGoSleepTimeoutS>
}
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	08 95       	ret

000010e0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    10e6:	80 81       	ld	r24, Z
    10e8:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    10ea:	e8 17       	cp	r30, r24
    10ec:	f9 07       	cpc	r31, r25
    10ee:	71 f0       	breq	.+28     	; 0x110c <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    10f0:	ec 01       	movw	r28, r24
    10f2:	a8 81       	ld	r26, Y
    10f4:	b9 81       	ldd	r27, Y+1	; 0x01
    10f6:	b1 83       	std	Z+1, r27	; 0x01
    10f8:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    10fa:	13 96       	adiw	r26, 0x03	; 3
    10fc:	fc 93       	st	X, r31
    10fe:	ee 93       	st	-X, r30
    1100:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1102:	7b 8b       	std	Y+19, r23	; 0x13
    1104:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    110a:	14 cd       	rjmp	.-1496   	; 0xb34 <chSchReadyI>
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	08 95       	ret

00001112 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1112:	fc 01       	movw	r30, r24
    1114:	91 83       	std	Z+1, r25	; 0x01
    1116:	80 83       	st	Z, r24
    1118:	93 83       	std	Z+3, r25	; 0x03
    111a:	82 83       	std	Z+2, r24	; 0x02
    111c:	15 82       	std	Z+5, r1	; 0x05
    111e:	14 82       	std	Z+4, r1	; 0x04
    1120:	08 95       	ret

00001122 <chMtxLockS>:
    1122:	0f 93       	push	r16
    1124:	1f 93       	push	r17
    1126:	cf 93       	push	r28
    1128:	df 93       	push	r29
    112a:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
    112e:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
    1132:	dc 01       	movw	r26, r24
    1134:	14 96       	adiw	r26, 0x04	; 4
    1136:	ed 91       	ld	r30, X+
    1138:	fc 91       	ld	r31, X
    113a:	15 97       	sbiw	r26, 0x05	; 5
    113c:	30 97       	sbiw	r30, 0x00	; 0
    113e:	09 f4       	brne	.+2      	; 0x1142 <chMtxLockS+0x20>
    1140:	a8 c0       	rjmp	.+336    	; 0x1292 <chMtxLockS+0x170>
    1142:	8c 01       	movw	r16, r24
    1144:	8c 81       	ldd	r24, Y+4	; 0x04
    1146:	94 81       	ldd	r25, Z+4	; 0x04
    1148:	98 17       	cp	r25, r24
    114a:	48 f4       	brcc	.+18     	; 0x115e <chMtxLockS+0x3c>
    114c:	84 83       	std	Z+4, r24	; 0x04
    114e:	87 85       	ldd	r24, Z+15	; 0x0f
    1150:	86 30       	cpi	r24, 0x06	; 6
    1152:	09 f4       	brne	.+2      	; 0x1156 <chMtxLockS+0x34>
    1154:	63 c0       	rjmp	.+198    	; 0x121c <chMtxLockS+0xfa>
    1156:	87 30       	cpi	r24, 0x07	; 7
    1158:	89 f1       	breq	.+98     	; 0x11bc <chMtxLockS+0x9a>
    115a:	88 23       	and	r24, r24
    115c:	f1 f0       	breq	.+60     	; 0x119a <chMtxLockS+0x78>
    115e:	f8 01       	movw	r30, r16
    1160:	04 c0       	rjmp	.+8      	; 0x116a <chMtxLockS+0x48>
    1162:	24 81       	ldd	r18, Z+4	; 0x04
    1164:	9c 81       	ldd	r25, Y+4	; 0x04
    1166:	29 17       	cp	r18, r25
    1168:	30 f0       	brcs	.+12     	; 0x1176 <chMtxLockS+0x54>
    116a:	01 90       	ld	r0, Z+
    116c:	f0 81       	ld	r31, Z
    116e:	e0 2d       	mov	r30, r0
    1170:	0e 17       	cp	r16, r30
    1172:	1f 07       	cpc	r17, r31
    1174:	b1 f7       	brne	.-20     	; 0x1162 <chMtxLockS+0x40>
    1176:	f9 83       	std	Y+1, r31	; 0x01
    1178:	e8 83       	st	Y, r30
    117a:	a2 81       	ldd	r26, Z+2	; 0x02
    117c:	b3 81       	ldd	r27, Z+3	; 0x03
    117e:	bb 83       	std	Y+3, r27	; 0x03
    1180:	aa 83       	std	Y+2, r26	; 0x02
    1182:	cd 93       	st	X+, r28
    1184:	dc 93       	st	X, r29
    1186:	d3 83       	std	Z+3, r29	; 0x03
    1188:	c2 83       	std	Z+2, r28	; 0x02
    118a:	1b 8b       	std	Y+19, r17	; 0x13
    118c:	0a 8b       	std	Y+18, r16	; 0x12
    118e:	86 e0       	ldi	r24, 0x06	; 6
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	1f 91       	pop	r17
    1196:	0f 91       	pop	r16
    1198:	f1 cc       	rjmp	.-1566   	; 0xb7c <chSchGoSleepS>
    119a:	22 81       	ldd	r18, Z+2	; 0x02
    119c:	33 81       	ldd	r19, Z+3	; 0x03
    119e:	80 81       	ld	r24, Z
    11a0:	91 81       	ldd	r25, Z+1	; 0x01
    11a2:	d9 01       	movw	r26, r18
    11a4:	8d 93       	st	X+, r24
    11a6:	9c 93       	st	X, r25
    11a8:	80 81       	ld	r24, Z
    11aa:	91 81       	ldd	r25, Z+1	; 0x01
    11ac:	dc 01       	movw	r26, r24
    11ae:	13 96       	adiw	r26, 0x03	; 3
    11b0:	3c 93       	st	X, r19
    11b2:	2e 93       	st	-X, r18
    11b4:	12 97       	sbiw	r26, 0x02	; 2
    11b6:	cf 01       	movw	r24, r30
    11b8:	bd dc       	rcall	.-1670   	; 0xb34 <chSchReadyI>
    11ba:	d1 cf       	rjmp	.-94     	; 0x115e <chMtxLockS+0x3c>
    11bc:	22 81       	ldd	r18, Z+2	; 0x02
    11be:	33 81       	ldd	r19, Z+3	; 0x03
    11c0:	80 81       	ld	r24, Z
    11c2:	91 81       	ldd	r25, Z+1	; 0x01
    11c4:	d9 01       	movw	r26, r18
    11c6:	8d 93       	st	X+, r24
    11c8:	9c 93       	st	X, r25
    11ca:	80 81       	ld	r24, Z
    11cc:	91 81       	ldd	r25, Z+1	; 0x01
    11ce:	dc 01       	movw	r26, r24
    11d0:	13 96       	adiw	r26, 0x03	; 3
    11d2:	3c 93       	st	X, r19
    11d4:	2e 93       	st	-X, r18
    11d6:	12 97       	sbiw	r26, 0x02	; 2
    11d8:	22 89       	ldd	r18, Z+18	; 0x12
    11da:	33 89       	ldd	r19, Z+19	; 0x13
    11dc:	a9 01       	movw	r20, r18
    11de:	06 c0       	rjmp	.+12     	; 0x11ec <chMtxLockS+0xca>
    11e0:	da 01       	movw	r26, r20
    11e2:	14 96       	adiw	r26, 0x04	; 4
    11e4:	9c 91       	ld	r25, X
    11e6:	84 81       	ldd	r24, Z+4	; 0x04
    11e8:	98 17       	cp	r25, r24
    11ea:	30 f0       	brcs	.+12     	; 0x11f8 <chMtxLockS+0xd6>
    11ec:	da 01       	movw	r26, r20
    11ee:	4d 91       	ld	r20, X+
    11f0:	5c 91       	ld	r21, X
    11f2:	24 17       	cp	r18, r20
    11f4:	35 07       	cpc	r19, r21
    11f6:	a1 f7       	brne	.-24     	; 0x11e0 <chMtxLockS+0xbe>
    11f8:	51 83       	std	Z+1, r21	; 0x01
    11fa:	40 83       	st	Z, r20
    11fc:	da 01       	movw	r26, r20
    11fe:	12 96       	adiw	r26, 0x02	; 2
    1200:	8d 91       	ld	r24, X+
    1202:	9c 91       	ld	r25, X
    1204:	13 97       	sbiw	r26, 0x03	; 3
    1206:	93 83       	std	Z+3, r25	; 0x03
    1208:	82 83       	std	Z+2, r24	; 0x02
    120a:	dc 01       	movw	r26, r24
    120c:	ed 93       	st	X+, r30
    120e:	fc 93       	st	X, r31
    1210:	da 01       	movw	r26, r20
    1212:	13 96       	adiw	r26, 0x03	; 3
    1214:	fc 93       	st	X, r31
    1216:	ee 93       	st	-X, r30
    1218:	12 97       	sbiw	r26, 0x02	; 2
    121a:	a1 cf       	rjmp	.-190    	; 0x115e <chMtxLockS+0x3c>
    121c:	22 81       	ldd	r18, Z+2	; 0x02
    121e:	33 81       	ldd	r19, Z+3	; 0x03
    1220:	80 81       	ld	r24, Z
    1222:	91 81       	ldd	r25, Z+1	; 0x01
    1224:	d9 01       	movw	r26, r18
    1226:	8d 93       	st	X+, r24
    1228:	9c 93       	st	X, r25
    122a:	80 81       	ld	r24, Z
    122c:	91 81       	ldd	r25, Z+1	; 0x01
    122e:	dc 01       	movw	r26, r24
    1230:	13 96       	adiw	r26, 0x03	; 3
    1232:	3c 93       	st	X, r19
    1234:	2e 93       	st	-X, r18
    1236:	12 97       	sbiw	r26, 0x02	; 2
    1238:	22 89       	ldd	r18, Z+18	; 0x12
    123a:	33 89       	ldd	r19, Z+19	; 0x13
    123c:	a9 01       	movw	r20, r18
    123e:	06 c0       	rjmp	.+12     	; 0x124c <chMtxLockS+0x12a>
    1240:	da 01       	movw	r26, r20
    1242:	14 96       	adiw	r26, 0x04	; 4
    1244:	9c 91       	ld	r25, X
    1246:	84 81       	ldd	r24, Z+4	; 0x04
    1248:	98 17       	cp	r25, r24
    124a:	30 f0       	brcs	.+12     	; 0x1258 <chMtxLockS+0x136>
    124c:	da 01       	movw	r26, r20
    124e:	4d 91       	ld	r20, X+
    1250:	5c 91       	ld	r21, X
    1252:	24 17       	cp	r18, r20
    1254:	35 07       	cpc	r19, r21
    1256:	a1 f7       	brne	.-24     	; 0x1240 <chMtxLockS+0x11e>
    1258:	51 83       	std	Z+1, r21	; 0x01
    125a:	40 83       	st	Z, r20
    125c:	da 01       	movw	r26, r20
    125e:	12 96       	adiw	r26, 0x02	; 2
    1260:	8d 91       	ld	r24, X+
    1262:	9c 91       	ld	r25, X
    1264:	13 97       	sbiw	r26, 0x03	; 3
    1266:	93 83       	std	Z+3, r25	; 0x03
    1268:	82 83       	std	Z+2, r24	; 0x02
    126a:	dc 01       	movw	r26, r24
    126c:	ed 93       	st	X+, r30
    126e:	fc 93       	st	X, r31
    1270:	da 01       	movw	r26, r20
    1272:	13 96       	adiw	r26, 0x03	; 3
    1274:	fc 93       	st	X, r31
    1276:	ee 93       	st	-X, r30
    1278:	12 97       	sbiw	r26, 0x02	; 2
    127a:	02 88       	ldd	r0, Z+18	; 0x12
    127c:	f3 89       	ldd	r31, Z+19	; 0x13
    127e:	e0 2d       	mov	r30, r0
    1280:	04 80       	ldd	r0, Z+4	; 0x04
    1282:	f5 81       	ldd	r31, Z+5	; 0x05
    1284:	e0 2d       	mov	r30, r0
    1286:	8c 81       	ldd	r24, Y+4	; 0x04
    1288:	94 81       	ldd	r25, Z+4	; 0x04
    128a:	98 17       	cp	r25, r24
    128c:	08 f4       	brcc	.+2      	; 0x1290 <chMtxLockS+0x16e>
    128e:	5e cf       	rjmp	.-324    	; 0x114c <chMtxLockS+0x2a>
    1290:	66 cf       	rjmp	.-308    	; 0x115e <chMtxLockS+0x3c>
    1292:	fc 01       	movw	r30, r24
    1294:	d5 83       	std	Z+5, r29	; 0x05
    1296:	c4 83       	std	Z+4, r28	; 0x04
    1298:	2b 8d       	ldd	r18, Y+27	; 0x1b
    129a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    129c:	37 83       	std	Z+7, r19	; 0x07
    129e:	26 83       	std	Z+6, r18	; 0x06
    12a0:	9c 8f       	std	Y+28, r25	; 0x1c
    12a2:	8b 8f       	std	Y+27, r24	; 0x1b
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	1f 91       	pop	r17
    12aa:	0f 91       	pop	r16
    12ac:	08 95       	ret

000012ae <chMtxLock>:
    12ae:	f8 94       	cli
    12b0:	38 df       	rcall	.-400    	; 0x1122 <chMtxLockS>
    12b2:	78 94       	sei
    12b4:	08 95       	ret

000012b6 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	ec 01       	movw	r28, r24
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    12bc:	40 91 88 04 	lds	r20, 0x0488	; 0x800488 <ch0+0x5>
    12c0:	50 91 89 04 	lds	r21, 0x0489	; 0x800489 <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    12c4:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    12c6:	ee 81       	ldd	r30, Y+6	; 0x06
    12c8:	ff 81       	ldd	r31, Y+7	; 0x07
    12ca:	da 01       	movw	r26, r20
    12cc:	5c 96       	adiw	r26, 0x1c	; 28
    12ce:	fc 93       	st	X, r31
    12d0:	ee 93       	st	-X, r30
    12d2:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    12d4:	a8 81       	ld	r26, Y
    12d6:	b9 81       	ldd	r27, Y+1	; 0x01
    12d8:	a8 17       	cp	r26, r24
    12da:	b9 07       	cpc	r27, r25
    12dc:	a1 f1       	breq	.+104    	; 0x1346 <chMtxUnlock+0x90>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    12de:	da 01       	movw	r26, r20
    12e0:	5d 96       	adiw	r26, 0x1d	; 29
    12e2:	2c 91       	ld	r18, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    12e4:	30 97       	sbiw	r30, 0x00	; 0
    12e6:	79 f0       	breq	.+30     	; 0x1306 <chMtxUnlock+0x50>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    12e8:	a0 81       	ld	r26, Z
    12ea:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    12ec:	ea 17       	cp	r30, r26
    12ee:	fb 07       	cpc	r31, r27
    12f0:	29 f0       	breq	.+10     	; 0x12fc <chMtxUnlock+0x46>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
    12f2:	14 96       	adiw	r26, 0x04	; 4
    12f4:	9c 91       	ld	r25, X
    12f6:	29 17       	cp	r18, r25
    12f8:	08 f4       	brcc	.+2      	; 0x12fc <chMtxUnlock+0x46>
    12fa:	29 2f       	mov	r18, r25
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    12fc:	06 80       	ldd	r0, Z+6	; 0x06
    12fe:	f7 81       	ldd	r31, Z+7	; 0x07
    1300:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1302:	30 97       	sbiw	r30, 0x00	; 0
    1304:	89 f7       	brne	.-30     	; 0x12e8 <chMtxUnlock+0x32>
    1306:	fe 01       	movw	r30, r28
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1308:	da 01       	movw	r26, r20
    130a:	14 96       	adiw	r26, 0x04	; 4
    130c:	2c 93       	st	X, r18
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    130e:	a8 81       	ld	r26, Y
    1310:	b9 81       	ldd	r27, Y+1	; 0x01

  qp->next       = p->next;
    1312:	cd 91       	ld	r28, X+
    1314:	dc 91       	ld	r29, X
    1316:	11 97       	sbiw	r26, 0x01	; 1
    1318:	d1 83       	std	Z+1, r29	; 0x01
    131a:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    131c:	fb 83       	std	Y+3, r31	; 0x03
    131e:	ea 83       	std	Y+2, r30	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    1320:	b5 83       	std	Z+5, r27	; 0x05
    1322:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    1324:	5b 96       	adiw	r26, 0x1b	; 27
    1326:	8d 91       	ld	r24, X+
    1328:	9c 91       	ld	r25, X
    132a:	5c 97       	sbiw	r26, 0x1c	; 28
    132c:	97 83       	std	Z+7, r25	; 0x07
    132e:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    1330:	5c 96       	adiw	r26, 0x1c	; 28
    1332:	fc 93       	st	X, r31
    1334:	ee 93       	st	-X, r30
    1336:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1338:	cd 01       	movw	r24, r26
    133a:	fc db       	rcall	.-2056   	; 0xb34 <chSchReadyI>
      chSchRescheduleS();
    133c:	1e dd       	rcall	.-1476   	; 0xd7a <chSchRescheduleS>
    133e:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1340:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret
    1346:	15 96       	adiw	r26, 0x05	; 5
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    1348:	1c 92       	st	X, r1
    134a:	1e 92       	st	-X, r1
    134c:	14 97       	sbiw	r26, 0x04	; 4
    134e:	78 94       	sei
    1350:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    1352:	cf 91       	pop	r28
    1354:	08 95       	ret

00001356 <chMtxUnlockS>:
    1356:	cf 93       	push	r28
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    1358:	df 93       	push	r29
    135a:	ec 01       	movw	r28, r24
    135c:	40 91 88 04 	lds	r20, 0x0488	; 0x800488 <ch0+0x5>
    1360:	50 91 89 04 	lds	r21, 0x0489	; 0x800489 <ch0+0x6>
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    1364:	ee 81       	ldd	r30, Y+6	; 0x06
    1366:	ff 81       	ldd	r31, Y+7	; 0x07
    1368:	da 01       	movw	r26, r20
    136a:	5c 96       	adiw	r26, 0x1c	; 28
    136c:	fc 93       	st	X, r31
    136e:	ee 93       	st	-X, r30
    1370:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1372:	a8 81       	ld	r26, Y
    1374:	b9 81       	ldd	r27, Y+1	; 0x01
    1376:	a8 17       	cp	r26, r24
    1378:	b9 07       	cpc	r27, r25
    137a:	61 f1       	breq	.+88     	; 0x13d4 <chMtxUnlockS+0x7e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    137c:	da 01       	movw	r26, r20
    137e:	5d 96       	adiw	r26, 0x1d	; 29
    1380:	2c 91       	ld	r18, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1382:	30 97       	sbiw	r30, 0x00	; 0
    1384:	79 f0       	breq	.+30     	; 0x13a4 <chMtxUnlockS+0x4e>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    1386:	a0 81       	ld	r26, Z
    1388:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    138a:	ea 17       	cp	r30, r26
    138c:	fb 07       	cpc	r31, r27
    138e:	29 f0       	breq	.+10     	; 0x139a <chMtxUnlockS+0x44>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
    1390:	14 96       	adiw	r26, 0x04	; 4
    1392:	9c 91       	ld	r25, X
    1394:	29 17       	cp	r18, r25
    1396:	08 f4       	brcc	.+2      	; 0x139a <chMtxUnlockS+0x44>
    1398:	29 2f       	mov	r18, r25
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    139a:	06 80       	ldd	r0, Z+6	; 0x06
    139c:	f7 81       	ldd	r31, Z+7	; 0x07
    139e:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    13a0:	30 97       	sbiw	r30, 0x00	; 0
    13a2:	89 f7       	brne	.-30     	; 0x1386 <chMtxUnlockS+0x30>
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    13a4:	fa 01       	movw	r30, r20
    13a6:	24 83       	std	Z+4, r18	; 0x04
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    13a8:	e8 81       	ld	r30, Y
    13aa:	f9 81       	ldd	r31, Y+1	; 0x01

  qp->next       = p->next;
    13ac:	a0 81       	ld	r26, Z
    13ae:	b1 81       	ldd	r27, Z+1	; 0x01
    13b0:	b9 83       	std	Y+1, r27	; 0x01
    13b2:	a8 83       	st	Y, r26
  qp->next->prev = qp;
    13b4:	13 96       	adiw	r26, 0x03	; 3
    13b6:	dc 93       	st	X, r29
    13b8:	ce 93       	st	-X, r28
    13ba:	12 97       	sbiw	r26, 0x02	; 2
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    13bc:	fd 83       	std	Y+5, r31	; 0x05
    13be:	ec 83       	std	Y+4, r30	; 0x04
      mp->next = tp->mtxlist;
    13c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    13c2:	94 8d       	ldd	r25, Z+28	; 0x1c
    13c4:	9f 83       	std	Y+7, r25	; 0x07
    13c6:	8e 83       	std	Y+6, r24	; 0x06
      tp->mtxlist = mp;
    13c8:	d4 8f       	std	Z+28, r29	; 0x1c
    13ca:	c3 8f       	std	Z+27, r28	; 0x1b
      (void) chSchReadyI(tp);
    13cc:	cf 01       	movw	r24, r30
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    13d2:	b0 cb       	rjmp	.-2208   	; 0xb34 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
    13d4:	15 96       	adiw	r26, 0x05	; 5
    13d6:	1c 92       	st	X, r1
    13d8:	1e 92       	st	-X, r1
    13da:	14 97       	sbiw	r26, 0x04	; 4
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	08 95       	ret

000013e2 <chCondObjectInit>:
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
  }
}
    13e2:	fc 01       	movw	r30, r24
    13e4:	91 83       	std	Z+1, r25	; 0x01
    13e6:	80 83       	st	Z, r24
    13e8:	93 83       	std	Z+3, r25	; 0x03
    13ea:	82 83       	std	Z+2, r24	; 0x02
    13ec:	08 95       	ret

000013ee <chCondSignal>:
    13ee:	cf 93       	push	r28
    13f0:	df 93       	push	r29
    13f2:	fc 01       	movw	r30, r24
    13f4:	f8 94       	cli
    13f6:	80 81       	ld	r24, Z
    13f8:	91 81       	ldd	r25, Z+1	; 0x01
    13fa:	e8 17       	cp	r30, r24
    13fc:	f9 07       	cpc	r31, r25
    13fe:	61 f0       	breq	.+24     	; 0x1418 <chCondSignal+0x2a>
    1400:	ec 01       	movw	r28, r24
    1402:	a8 81       	ld	r26, Y
    1404:	b9 81       	ldd	r27, Y+1	; 0x01
    1406:	b1 83       	std	Z+1, r27	; 0x01
    1408:	a0 83       	st	Z, r26
    140a:	13 96       	adiw	r26, 0x03	; 3
    140c:	fc 93       	st	X, r31
    140e:	ee 93       	st	-X, r30
    1410:	12 97       	sbiw	r26, 0x02	; 2
    1412:	60 e0       	ldi	r22, 0x00	; 0
    1414:	70 e0       	ldi	r23, 0x00	; 0
    1416:	05 dc       	rcall	.-2038   	; 0xc22 <chSchWakeupS>
    1418:	78 94       	sei
    141a:	df 91       	pop	r29
    141c:	cf 91       	pop	r28
    141e:	08 95       	ret

00001420 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
    1420:	ef 92       	push	r14
    1422:	ff 92       	push	r15
    1424:	0f 93       	push	r16
    1426:	1f 93       	push	r17
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	8c 01       	movw	r16, r24
    142e:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
    1432:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
    1436:	eb 8c       	ldd	r14, Y+27	; 0x1b
    1438:	fc 8c       	ldd	r15, Y+28	; 0x1c
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
    143a:	c7 01       	movw	r24, r14
    143c:	8c df       	rcall	.-232    	; 0x1356 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
    143e:	1b 8b       	std	Y+19, r17	; 0x13
    1440:	0a 8b       	std	Y+18, r16	; 0x12
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
    1442:	d8 01       	movw	r26, r16
    1444:	f8 01       	movw	r30, r16
    1446:	04 c0       	rjmp	.+8      	; 0x1450 <chCondWaitS+0x30>
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
    1448:	94 81       	ldd	r25, Z+4	; 0x04
    144a:	8c 81       	ldd	r24, Y+4	; 0x04
    144c:	98 17       	cp	r25, r24
    144e:	18 f1       	brcs	.+70     	; 0x1496 <chCondWaitS+0x76>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    1450:	01 90       	ld	r0, Z+
    1452:	f0 81       	ld	r31, Z
    1454:	e0 2d       	mov	r30, r0
  } while ((cp != qp) &&
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
    1456:	e0 17       	cp	r30, r16
    1458:	f1 07       	cpc	r31, r17
    145a:	b1 f7       	brne	.-20     	; 0x1448 <chCondWaitS+0x28>
  tp->next       = cp;
    145c:	b9 83       	std	Y+1, r27	; 0x01
    145e:	a8 83       	st	Y, r26
  tp->prev       = cp->prev;
    1460:	12 96       	adiw	r26, 0x02	; 2
    1462:	ed 91       	ld	r30, X+
    1464:	fc 91       	ld	r31, X
    1466:	13 97       	sbiw	r26, 0x03	; 3
    1468:	fb 83       	std	Y+3, r31	; 0x03
    146a:	ea 83       	std	Y+2, r30	; 0x02
  tp->prev->next = tp;
    146c:	d1 83       	std	Z+1, r29	; 0x01
    146e:	c0 83       	st	Z, r28
  cp->prev       = tp;
    1470:	13 96       	adiw	r26, 0x03	; 3
    1472:	dc 93       	st	X, r29
    1474:	ce 93       	st	-X, r28
    1476:	12 97       	sbiw	r26, 0x02	; 2
  chSchGoSleepS(CH_STATE_WTCOND);
    1478:	87 e0       	ldi	r24, 0x07	; 7
    147a:	80 db       	rcall	.-2304   	; 0xb7c <chSchGoSleepS>
  msg = currtp->u.rdymsg;
    147c:	0a 88       	ldd	r0, Y+18	; 0x12
    147e:	db 89       	ldd	r29, Y+19	; 0x13
  chMtxLockS(mp);
    1480:	c0 2d       	mov	r28, r0
    1482:	c7 01       	movw	r24, r14
    1484:	4e de       	rcall	.-868    	; 0x1122 <chMtxLockS>

  return msg;
}
    1486:	ce 01       	movw	r24, r28
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	1f 91       	pop	r17
    148e:	0f 91       	pop	r16
    1490:	ff 90       	pop	r15
    1492:	ef 90       	pop	r14
    1494:	08 95       	ret
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
    1496:	df 01       	movw	r26, r30
    1498:	e1 cf       	rjmp	.-62     	; 0x145c <chCondWaitS+0x3c>

0000149a <chCondWait>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    149a:	f8 94       	cli
 */
msg_t chCondWait(condition_variable_t *cp) {
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
    149c:	c1 df       	rcall	.-126    	; 0x1420 <chCondWaitS>
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    149e:	78 94       	sei
  chSysUnlock();
  return msg;
}
    14a0:	08 95       	ret

000014a2 <chEvtObjectInit>:
    14a2:	fc 01       	movw	r30, r24
    14a4:	91 83       	std	Z+1, r25	; 0x01
    14a6:	80 83       	st	Z, r24
    14a8:	08 95       	ret

000014aa <chEvtSignalI>:
    14aa:	fc 01       	movw	r30, r24
    14ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    14ae:	69 2b       	or	r22, r25
    14b0:	62 8f       	std	Z+26, r22	; 0x1a
    14b2:	87 85       	ldd	r24, Z+15	; 0x0f
    14b4:	8a 30       	cpi	r24, 0x0A	; 10
    14b6:	59 f0       	breq	.+22     	; 0x14ce <chEvtSignalI+0x24>
    14b8:	8b 30       	cpi	r24, 0x0B	; 11
    14ba:	09 f0       	breq	.+2      	; 0x14be <chEvtSignalI+0x14>
    14bc:	08 95       	ret
    14be:	82 89       	ldd	r24, Z+18	; 0x12
    14c0:	68 23       	and	r22, r24
    14c2:	86 13       	cpse	r24, r22
    14c4:	fb cf       	rjmp	.-10     	; 0x14bc <chEvtSignalI+0x12>
    14c6:	13 8a       	std	Z+19, r1	; 0x13
    14c8:	12 8a       	std	Z+18, r1	; 0x12
    14ca:	cf 01       	movw	r24, r30
    14cc:	33 cb       	rjmp	.-2458   	; 0xb34 <chSchReadyI>
    14ce:	82 89       	ldd	r24, Z+18	; 0x12
    14d0:	68 23       	and	r22, r24
    14d2:	c9 f7       	brne	.-14     	; 0x14c6 <chEvtSignalI+0x1c>
    14d4:	08 95       	ret

000014d6 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    14d6:	ef 92       	push	r14
    14d8:	ff 92       	push	r15
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	7c 01       	movw	r14, r24
    14e2:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    14e4:	fc 01       	movw	r30, r24
    14e6:	c0 81       	ld	r28, Z
    14e8:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    14ea:	8c 17       	cp	r24, r28
    14ec:	9d 07       	cpc	r25, r29
    14ee:	91 f0       	breq	.+36     	; 0x1514 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    14f0:	8d 81       	ldd	r24, Y+5	; 0x05
    14f2:	81 2b       	or	r24, r17
    14f4:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    14f6:	11 23       	and	r17, r17
    14f8:	19 f0       	breq	.+6      	; 0x1500 <chEvtBroadcastFlagsI+0x2a>
    14fa:	8e 81       	ldd	r24, Y+6	; 0x06
    14fc:	81 23       	and	r24, r17
    14fe:	21 f0       	breq	.+8      	; 0x1508 <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    1500:	6c 81       	ldd	r22, Y+4	; 0x04
    1502:	8a 81       	ldd	r24, Y+2	; 0x02
    1504:	9b 81       	ldd	r25, Y+3	; 0x03
    1506:	d1 df       	rcall	.-94     	; 0x14aa <chEvtSignalI>
    }
    elp = elp->next;
    1508:	09 90       	ld	r0, Y+
    150a:	d8 81       	ld	r29, Y
    150c:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    150e:	ec 16       	cp	r14, r28
    1510:	fd 06       	cpc	r15, r29
    1512:	71 f7       	brne	.-36     	; 0x14f0 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    1514:	df 91       	pop	r29
    1516:	cf 91       	pop	r28
    1518:	1f 91       	pop	r17
    151a:	ff 90       	pop	r15
    151c:	ef 90       	pop	r14
    151e:	08 95       	ret

00001520 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1520:	e6 ec       	ldi	r30, 0xC6	; 198
    1522:	f4 e0       	ldi	r31, 0x04	; 4
    1524:	89 ec       	ldi	r24, 0xC9	; 201
    1526:	91 e0       	ldi	r25, 0x01	; 1
    1528:	91 83       	std	Z+1, r25	; 0x01
    152a:	80 83       	st	Z, r24
    152c:	89 e4       	ldi	r24, 0x49	; 73
    152e:	92 e0       	ldi	r25, 0x02	; 2
    1530:	93 83       	std	Z+3, r25	; 0x03
    1532:	82 83       	std	Z+2, r24	; 0x02
    1534:	08 95       	ret

00001536 <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    1536:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    1538:	20 91 c8 04 	lds	r18, 0x04C8	; 0x8004c8 <ch_memcore+0x2>
    153c:	30 91 c9 04 	lds	r19, 0x04C9	; 0x8004c9 <ch_memcore+0x3>
    1540:	f9 01       	movw	r30, r18
    1542:	e8 1b       	sub	r30, r24
    1544:	f9 0b       	sbc	r31, r25
    1546:	71 95       	neg	r23
    1548:	61 95       	neg	r22
    154a:	71 09       	sbc	r23, r1
    154c:	6e 23       	and	r22, r30
    154e:	7f 23       	and	r23, r31
  prev = p - offset;
    1550:	cb 01       	movw	r24, r22
    1552:	84 1b       	sub	r24, r20
    1554:	95 0b       	sbc	r25, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    1556:	40 91 c6 04 	lds	r20, 0x04C6	; 0x8004c6 <ch_memcore>
    155a:	50 91 c7 04 	lds	r21, 0x04C7	; 0x8004c7 <ch_memcore+0x1>
    155e:	84 17       	cp	r24, r20
    1560:	95 07       	cpc	r25, r21
    1562:	50 f0       	brcs	.+20     	; 0x1578 <chCoreAllocFromTop+0x42>
    1564:	28 17       	cp	r18, r24
    1566:	39 07       	cpc	r19, r25
    1568:	38 f0       	brcs	.+14     	; 0x1578 <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    156a:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <ch_memcore+0x3>
    156e:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <ch_memcore+0x2>

  return p;
    1572:	cb 01       	movw	r24, r22
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1574:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    1576:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    157e:	08 95       	ret

00001580 <chCoreGetStatusX>:
 *
 * @xclass
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
    1580:	e6 ec       	ldi	r30, 0xC6	; 198
    1582:	f4 e0       	ldi	r31, 0x04	; 4
    1584:	40 81       	ld	r20, Z
    1586:	51 81       	ldd	r21, Z+1	; 0x01
    1588:	dc 01       	movw	r26, r24
    158a:	11 96       	adiw	r26, 0x01	; 1
    158c:	5c 93       	st	X, r21
    158e:	4e 93       	st	-X, r20
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
    1590:	22 81       	ldd	r18, Z+2	; 0x02
    1592:	33 81       	ldd	r19, Z+3	; 0x03
    1594:	24 1b       	sub	r18, r20
    1596:	35 0b       	sbc	r19, r21
    1598:	13 96       	adiw	r26, 0x03	; 3
    159a:	3c 93       	st	X, r19
    159c:	2e 93       	st	-X, r18
    159e:	12 97       	sbiw	r26, 0x02	; 2
    15a0:	08 95       	ret

000015a2 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
    15a2:	cf 93       	push	r28
    15a4:	df 93       	push	r29

  default_heap.provider = chCoreAllocAlignedWithOffset;
    15a6:	c9 e4       	ldi	r28, 0x49	; 73
    15a8:	d2 e0       	ldi	r29, 0x02	; 2
    15aa:	8b e9       	ldi	r24, 0x9B	; 155
    15ac:	9a e0       	ldi	r25, 0x0A	; 10
    15ae:	99 83       	std	Y+1, r25	; 0x01
    15b0:	88 83       	st	Y, r24
  chCoreGetStatusX(&default_heap.area);
    15b2:	8b e4       	ldi	r24, 0x4B	; 75
    15b4:	92 e0       	ldi	r25, 0x02	; 2
    15b6:	e4 df       	rcall	.-56     	; 0x1580 <chCoreGetStatusX>
  H_FREE_NEXT(&default_heap.header) = NULL;
    15b8:	1f 82       	std	Y+7, r1	; 0x07
    15ba:	1e 82       	std	Y+6, r1	; 0x06
  H_FREE_PAGES(&default_heap.header) = 0;
    15bc:	19 86       	std	Y+9, r1	; 0x09
    15be:	18 86       	std	Y+8, r1	; 0x08
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15c0:	83 e5       	ldi	r24, 0x53	; 83
    15c2:	92 e0       	ldi	r25, 0x02	; 2
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
    15c4:	df 91       	pop	r29
  default_heap.provider = chCoreAllocAlignedWithOffset;
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15c6:	cf 91       	pop	r28
    15c8:	a4 cd       	rjmp	.-1208   	; 0x1112 <chMtxObjectInit>

000015ca <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    15ca:	2f 92       	push	r2
  asm volatile ("push    r3");
    15cc:	3f 92       	push	r3
  asm volatile ("push    r4");
    15ce:	4f 92       	push	r4
  asm volatile ("push    r5");
    15d0:	5f 92       	push	r5
  asm volatile ("push    r6");
    15d2:	6f 92       	push	r6
  asm volatile ("push    r7");
    15d4:	7f 92       	push	r7
  asm volatile ("push    r8");
    15d6:	8f 92       	push	r8
  asm volatile ("push    r9");
    15d8:	9f 92       	push	r9
  asm volatile ("push    r10");
    15da:	af 92       	push	r10
  asm volatile ("push    r11");
    15dc:	bf 92       	push	r11
  asm volatile ("push    r12");
    15de:	cf 92       	push	r12
  asm volatile ("push    r13");
    15e0:	df 92       	push	r13
  asm volatile ("push    r14");
    15e2:	ef 92       	push	r14
  asm volatile ("push    r15");
    15e4:	ff 92       	push	r15
  asm volatile ("push    r16");
    15e6:	0f 93       	push	r16
  asm volatile ("push    r17");
    15e8:	1f 93       	push	r17
  asm volatile ("push    r28");
    15ea:	cf 93       	push	r28
  asm volatile ("push    r29");
    15ec:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    15ee:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    15f0:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    15f2:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    15f4:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    15f6:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    15f8:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    15fa:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    15fc:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    15fe:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    1600:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    1602:	df 91       	pop	r29
  asm volatile ("pop     r28");
    1604:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    1606:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    1608:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    160a:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    160c:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    160e:	df 90       	pop	r13
  asm volatile ("pop     r12");
    1610:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    1612:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    1614:	af 90       	pop	r10
  asm volatile ("pop     r9");
    1616:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    1618:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    161a:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    161c:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    161e:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1620:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1622:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1624:	2f 90       	pop	r2
  asm volatile ("ret");
    1626:	08 95       	ret

00001628 <_port_thread_start>:
    1628:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    162a:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    162c:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    162e:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1630:	2c cd       	rjmp	.-1448   	; 0x108a <chThdExit>

00001632 <Consumer>:
    }
}

// Funo da thread Consumidora
static THD_WORKING_AREA(waConsumer, 128);
static THD_FUNCTION(Consumer, arg) {
    1632:	c2 e3       	ldi	r28, 0x32	; 50
    1634:	d4 e0       	ldi	r29, 0x04	; 4
        chCondSignal(&buffer_not_full);

        chMtxUnlock(&buffer_mutex);  // Libera o mutex

        // Simula o processamento do dado recebido
        palTogglePad(IOPORT2, 5);  // Alterna o LED (PB5)
    1636:	10 e2       	ldi	r17, 0x20	; 32
    (void)arg;
    uint8_t received_data;
    msg_t result;  // Varivel para armazenar o retorno de chCondWait

    while (true) {
        chMtxLock(&buffer_mutex);  // Trava o mutex
    1638:	89 e2       	ldi	r24, 0x29	; 41
    163a:	94 e0       	ldi	r25, 0x04	; 4
    163c:	38 de       	rcall	.-912    	; 0x12ae <chMtxLock>

        // Espera enquanto o buffer est vazio
        while (buffer_count == 0) {
    163e:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <buffer_count>
    1642:	81 11       	cpse	r24, r1
    1644:	0c c0       	rjmp	.+24     	; 0x165e <Consumer+0x2c>
            result = chCondWait(&buffer_not_empty);  // Aguarda at haver dados
    1646:	85 e2       	ldi	r24, 0x25	; 37
    1648:	94 e0       	ldi	r25, 0x04	; 4
    164a:	27 df       	rcall	.-434    	; 0x149a <chCondWait>
            if (result != MSG_OK) {
    164c:	89 2b       	or	r24, r25
    164e:	b9 f3       	breq	.-18     	; 0x163e <Consumer+0xc>
                // Tratar erros se necessrio (por exemplo, interrupo)
                chMtxUnlock(&buffer_mutex);  // Libera o mutex em caso de erro
    1650:	89 e2       	ldi	r24, 0x29	; 41
    1652:	94 e0       	ldi	r25, 0x04	; 4
    1654:	30 de       	rcall	.-928    	; 0x12b6 <chMtxUnlock>

    while (true) {
        chMtxLock(&buffer_mutex);  // Trava o mutex

        // Espera enquanto o buffer est vazio
        while (buffer_count == 0) {
    1656:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <buffer_count>
    165a:	88 23       	and	r24, r24
    165c:	a1 f3       	breq	.-24     	; 0x1646 <Consumer+0x14>
            }
        }

        // L o dado do buffer
        received_data = *read_ptr;
        if (++read_ptr >= buffer + BUFFER_SIZE) {
    165e:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    1662:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    1666:	2f 5f       	subi	r18, 0xFF	; 255
    1668:	3f 4f       	sbci	r19, 0xFF	; 255
    166a:	94 e0       	ldi	r25, 0x04	; 4
    166c:	27 33       	cpi	r18, 0x37	; 55
    166e:	39 07       	cpc	r19, r25
    1670:	a0 f4       	brcc	.+40     	; 0x169a <Consumer+0x68>
    1672:	30 93 01 01 	sts	0x0101, r19	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    1676:	20 93 00 01 	sts	0x0100, r18	; 0x800100 <__DATA_REGION_ORIGIN__>
            read_ptr = buffer;  // Volta para o incio do buffer
        }
        buffer_count--;
    167a:	81 50       	subi	r24, 0x01	; 1
    167c:	80 93 31 04 	sts	0x0431, r24	; 0x800431 <buffer_count>

        // Sinaliza que o buffer no est mais cheio
        chCondSignal(&buffer_not_full);
    1680:	81 e2       	ldi	r24, 0x21	; 33
    1682:	94 e0       	ldi	r25, 0x04	; 4

        chMtxUnlock(&buffer_mutex);  // Libera o mutex
    1684:	b4 de       	rcall	.-664    	; 0x13ee <chCondSignal>
    1686:	89 e2       	ldi	r24, 0x29	; 41
    1688:	94 e0       	ldi	r25, 0x04	; 4
    168a:	15 de       	rcall	.-982    	; 0x12b6 <chMtxUnlock>

        // Simula o processamento do dado recebido
        palTogglePad(IOPORT2, 5);  // Alterna o LED (PB5)
    168c:	85 b1       	in	r24, 0x05	; 5
    168e:	81 27       	eor	r24, r17
        chThdSleepMilliseconds(300);
    1690:	85 b9       	out	0x05, r24	; 5
    1692:	80 e5       	ldi	r24, 0x50	; 80
    1694:	92 e1       	ldi	r25, 0x12	; 18
    1696:	fb dc       	rcall	.-1546   	; 0x108e <chThdSleep>
    }
    1698:	cf cf       	rjmp	.-98     	; 0x1638 <Consumer+0x6>
        }

        // L o dado do buffer
        received_data = *read_ptr;
        if (++read_ptr >= buffer + BUFFER_SIZE) {
            read_ptr = buffer;  // Volta para o incio do buffer
    169a:	d0 93 01 01 	sts	0x0101, r29	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    169e:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__DATA_REGION_ORIGIN__>
    16a2:	eb cf       	rjmp	.-42     	; 0x167a <Consumer+0x48>

000016a4 <Producer>:

// Funo da thread Produtora
static THD_WORKING_AREA(waProducer, 128);
static THD_FUNCTION(Producer, arg) {
    (void)arg;
    uint8_t data = 0;  // Dados a serem produzidos
    16a4:	c0 e0       	ldi	r28, 0x00	; 0
    16a6:	02 e3       	ldi	r16, 0x32	; 50
    16a8:	14 e0       	ldi	r17, 0x04	; 4
    msg_t result;      // Varivel para armazenar o retorno de chCondWait

    while (true) {
        chMtxLock(&buffer_mutex);  // Trava o mutex
    16aa:	89 e2       	ldi	r24, 0x29	; 41
    16ac:	94 e0       	ldi	r25, 0x04	; 4
    16ae:	ff dd       	rcall	.-1026   	; 0x12ae <chMtxLock>

        // Espera enquanto o buffer est cheio
        while (buffer_count == BUFFER_SIZE) {
    16b0:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <buffer_count>
    16b4:	85 30       	cpi	r24, 0x05	; 5
    16b6:	61 f4       	brne	.+24     	; 0x16d0 <Producer+0x2c>
            result = chCondWait(&buffer_not_full);  // Aguarda espao disponvel
    16b8:	81 e2       	ldi	r24, 0x21	; 33
    16ba:	94 e0       	ldi	r25, 0x04	; 4
    16bc:	ee de       	rcall	.-548    	; 0x149a <chCondWait>
            if (result != MSG_OK) {
    16be:	89 2b       	or	r24, r25
    16c0:	b9 f3       	breq	.-18     	; 0x16b0 <Producer+0xc>
                // Tratar erros se necessrio (por exemplo, interrupo)
                chMtxUnlock(&buffer_mutex);  // Libera o mutex em caso de erro
    16c2:	89 e2       	ldi	r24, 0x29	; 41
    16c4:	94 e0       	ldi	r25, 0x04	; 4
    16c6:	f7 dd       	rcall	.-1042   	; 0x12b6 <chMtxUnlock>

    while (true) {
        chMtxLock(&buffer_mutex);  // Trava o mutex

        // Espera enquanto o buffer est cheio
        while (buffer_count == BUFFER_SIZE) {
    16c8:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <buffer_count>
    16cc:	85 30       	cpi	r24, 0x05	; 5
    16ce:	a1 f3       	breq	.-24     	; 0x16b8 <Producer+0x14>
                continue;
            }
        }

        // Adiciona o dado ao buffer
        *write_ptr = data++;
    16d0:	d1 e0       	ldi	r29, 0x01	; 1
    16d2:	dc 0f       	add	r29, r28
    16d4:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <write_ptr>
    16d8:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <write_ptr+0x1>
    16dc:	c1 93       	st	Z+, r28
        if (++write_ptr >= buffer + BUFFER_SIZE) {
    16de:	94 e0       	ldi	r25, 0x04	; 4
    16e0:	e7 33       	cpi	r30, 0x37	; 55
    16e2:	f9 07       	cpc	r31, r25
    16e4:	90 f4       	brcc	.+36     	; 0x170a <Producer+0x66>
    16e6:	f0 93 03 01 	sts	0x0103, r31	; 0x800103 <write_ptr+0x1>
    16ea:	e0 93 02 01 	sts	0x0102, r30	; 0x800102 <write_ptr>
            write_ptr = buffer;  // Volta para o incio do buffer
        }
        buffer_count++;
    16ee:	8f 5f       	subi	r24, 0xFF	; 255
    16f0:	80 93 31 04 	sts	0x0431, r24	; 0x800431 <buffer_count>

        // Sinaliza que o buffer no est mais vazio
        chCondSignal(&buffer_not_empty);
    16f4:	85 e2       	ldi	r24, 0x25	; 37
    16f6:	94 e0       	ldi	r25, 0x04	; 4

        chMtxUnlock(&buffer_mutex);  // Libera o mutex
    16f8:	7a de       	rcall	.-780    	; 0x13ee <chCondSignal>
    16fa:	89 e2       	ldi	r24, 0x29	; 41
    16fc:	94 e0       	ldi	r25, 0x04	; 4

        // Simula algum tempo de produo
        chThdSleepMilliseconds(500);
    16fe:	db dd       	rcall	.-1098   	; 0x12b6 <chMtxUnlock>
    1700:	84 e8       	ldi	r24, 0x84	; 132
    1702:	9e e1       	ldi	r25, 0x1E	; 30
    1704:	c4 dc       	rcall	.-1656   	; 0x108e <chThdSleep>
                continue;
            }
        }

        // Adiciona o dado ao buffer
        *write_ptr = data++;
    1706:	cd 2f       	mov	r28, r29

        chMtxUnlock(&buffer_mutex);  // Libera o mutex

        // Simula algum tempo de produo
        chThdSleepMilliseconds(500);
    }
    1708:	d0 cf       	rjmp	.-96     	; 0x16aa <Producer+0x6>
        }

        // Adiciona o dado ao buffer
        *write_ptr = data++;
        if (++write_ptr >= buffer + BUFFER_SIZE) {
            write_ptr = buffer;  // Volta para o incio do buffer
    170a:	10 93 03 01 	sts	0x0103, r17	; 0x800103 <write_ptr+0x1>
    170e:	00 93 02 01 	sts	0x0102, r16	; 0x800102 <write_ptr>
    1712:	ed cf       	rjmp	.-38     	; 0x16ee <Producer+0x4a>

00001714 <main>:
    }
}

// Funo principal (main)
int main(void) {
    halInit();    // Inicializa o HAL (Hardware Abstraction Layer)
    1714:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
    chSysInit();  // Inicializa o sistema ChibiOS
    1718:	cd d8       	rcall	.-3686   	; 0x8b4 <chSysInit>

    // Configurao dos pinos
    palSetPadMode(IOPORT2, 5, PAL_MODE_OUTPUT_PUSHPULL);
    171a:	46 e0       	ldi	r20, 0x06	; 6
    171c:	60 e2       	ldi	r22, 0x20	; 32
    171e:	83 e2       	ldi	r24, 0x23	; 35
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	0e 94 7f 03 	call	0x6fe	; 0x6fe <_pal_lld_setgroupmode>
    palClearPad(IOPORT2, 5);
    1726:	2d 98       	cbi	0x05, 5	; 5

    // Inicializa o mutex e as variveis de condio
    chMtxObjectInit(&buffer_mutex);
    1728:	89 e2       	ldi	r24, 0x29	; 41
    172a:	94 e0       	ldi	r25, 0x04	; 4
    172c:	f2 dc       	rcall	.-1564   	; 0x1112 <chMtxObjectInit>
    chCondObjectInit(&buffer_not_empty);
    172e:	85 e2       	ldi	r24, 0x25	; 37
    1730:	94 e0       	ldi	r25, 0x04	; 4
    1732:	57 de       	rcall	.-850    	; 0x13e2 <chCondObjectInit>
    chCondObjectInit(&buffer_not_full);
    1734:	81 e2       	ldi	r24, 0x21	; 33
    1736:	94 e0       	ldi	r25, 0x04	; 4
    1738:	54 de       	rcall	.-856    	; 0x13e2 <chCondObjectInit>
    173a:	00 e0       	ldi	r16, 0x00	; 0

    // Cria as threads produtora e consumidora
    chThdCreateStatic(waProducer, sizeof(waProducer), NORMALPRIO, Producer, NULL);
    173c:	10 e0       	ldi	r17, 0x00	; 0
    173e:	22 e5       	ldi	r18, 0x52	; 82
    1740:	3b e0       	ldi	r19, 0x0B	; 11
    1742:	40 e8       	ldi	r20, 0x80	; 128
    1744:	63 ee       	ldi	r22, 0xE3	; 227
    1746:	70 e0       	ldi	r23, 0x00	; 0
    1748:	8e e3       	ldi	r24, 0x3E	; 62
    174a:	93 e0       	ldi	r25, 0x03	; 3
    174c:	23 dc       	rcall	.-1978   	; 0xf94 <chThdCreateStatic>
    174e:	29 e1       	ldi	r18, 0x19	; 25
    chThdCreateStatic(waConsumer, sizeof(waConsumer), NORMALPRIO, Consumer, NULL);
    1750:	3b e0       	ldi	r19, 0x0B	; 11
    1752:	40 e8       	ldi	r20, 0x80	; 128
    1754:	63 ee       	ldi	r22, 0xE3	; 227
    1756:	70 e0       	ldi	r23, 0x00	; 0
    1758:	8b e5       	ldi	r24, 0x5B	; 91
    175a:	92 e0       	ldi	r25, 0x02	; 2
    175c:	1b dc       	rcall	.-1994   	; 0xf94 <chThdCreateStatic>

    // Loop infinito para manter o sistema rodando
    while (true) {
        chThdSleepMilliseconds(1000);
    175e:	88 e0       	ldi	r24, 0x08	; 8
    1760:	9d e3       	ldi	r25, 0x3D	; 61
    1762:	95 dc       	rcall	.-1750   	; 0x108e <chThdSleep>
    1764:	fc cf       	rjmp	.-8      	; 0x175e <main+0x4a>

00001766 <vfprintf>:
    1766:	ab e0       	ldi	r26, 0x0B	; 11
    1768:	b0 e0       	ldi	r27, 0x00	; 0
    176a:	e8 eb       	ldi	r30, 0xB8	; 184
    176c:	fb e0       	ldi	r31, 0x0B	; 11
    176e:	d3 c2       	rjmp	.+1446   	; 0x1d16 <__prologue_saves__+0x8>
    1770:	6c 01       	movw	r12, r24
    1772:	7b 01       	movw	r14, r22
    1774:	3a 01       	movw	r6, r20
    1776:	fc 01       	movw	r30, r24
    1778:	17 82       	std	Z+7, r1	; 0x07
    177a:	16 82       	std	Z+6, r1	; 0x06
    177c:	83 81       	ldd	r24, Z+3	; 0x03
    177e:	81 ff       	sbrs	r24, 1
    1780:	f9 c0       	rjmp	.+498    	; 0x1974 <vfprintf+0x20e>
    1782:	ce 01       	movw	r24, r28
    1784:	01 96       	adiw	r24, 0x01	; 1
    1786:	4c 01       	movw	r8, r24
    1788:	f6 01       	movw	r30, r12
    178a:	b3 80       	ldd	r11, Z+3	; 0x03
    178c:	f7 01       	movw	r30, r14
    178e:	b3 fc       	sbrc	r11, 3
    1790:	05 91       	lpm	r16, Z+
    1792:	b3 fe       	sbrs	r11, 3
    1794:	01 91       	ld	r16, Z+
    1796:	7f 01       	movw	r14, r30
    1798:	00 23       	and	r16, r16
    179a:	09 f4       	brne	.+2      	; 0x179e <vfprintf+0x38>
    179c:	e7 c0       	rjmp	.+462    	; 0x196c <vfprintf+0x206>
    179e:	05 32       	cpi	r16, 0x25	; 37
    17a0:	49 f4       	brne	.+18     	; 0x17b4 <vfprintf+0x4e>
    17a2:	b3 fc       	sbrc	r11, 3
    17a4:	05 91       	lpm	r16, Z+
    17a6:	b3 fe       	sbrs	r11, 3
    17a8:	01 91       	ld	r16, Z+
    17aa:	7f 01       	movw	r14, r30
    17ac:	05 32       	cpi	r16, 0x25	; 37
    17ae:	11 f0       	breq	.+4      	; 0x17b4 <vfprintf+0x4e>
    17b0:	10 e0       	ldi	r17, 0x00	; 0
    17b2:	17 c0       	rjmp	.+46     	; 0x17e2 <vfprintf+0x7c>
    17b4:	b6 01       	movw	r22, r12
    17b6:	80 2f       	mov	r24, r16
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	3a d3       	rcall	.+1652   	; 0x1e30 <fputc>
    17bc:	53 01       	movw	r10, r6
    17be:	35 01       	movw	r6, r10
    17c0:	e3 cf       	rjmp	.-58     	; 0x1788 <vfprintf+0x22>
    17c2:	00 23       	and	r16, r16
    17c4:	09 f4       	brne	.+2      	; 0x17c8 <vfprintf+0x62>
    17c6:	d2 c0       	rjmp	.+420    	; 0x196c <vfprintf+0x206>
    17c8:	60 2f       	mov	r22, r16
    17ca:	70 e0       	ldi	r23, 0x00	; 0
    17cc:	8f e6       	ldi	r24, 0x6F	; 111
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	dd d2       	rcall	.+1466   	; 0x1d8c <strchr_P>
    17d2:	89 2b       	or	r24, r25
    17d4:	49 f0       	breq	.+18     	; 0x17e8 <vfprintf+0x82>
    17d6:	f7 01       	movw	r30, r14
    17d8:	b3 fc       	sbrc	r11, 3
    17da:	05 91       	lpm	r16, Z+
    17dc:	b3 fe       	sbrs	r11, 3
    17de:	01 91       	ld	r16, Z+
    17e0:	7f 01       	movw	r14, r30
    17e2:	17 ff       	sbrs	r17, 7
    17e4:	ee cf       	rjmp	.-36     	; 0x17c2 <vfprintf+0x5c>
    17e6:	04 c0       	rjmp	.+8      	; 0x17f0 <vfprintf+0x8a>
    17e8:	03 32       	cpi	r16, 0x23	; 35
    17ea:	39 f0       	breq	.+14     	; 0x17fa <vfprintf+0x94>
    17ec:	0c 36       	cpi	r16, 0x6C	; 108
    17ee:	19 f0       	breq	.+6      	; 0x17f6 <vfprintf+0x90>
    17f0:	01 11       	cpse	r16, r1
    17f2:	05 c0       	rjmp	.+10     	; 0x17fe <vfprintf+0x98>
    17f4:	bb c0       	rjmp	.+374    	; 0x196c <vfprintf+0x206>
    17f6:	10 68       	ori	r17, 0x80	; 128
    17f8:	ee cf       	rjmp	.-36     	; 0x17d6 <vfprintf+0x70>
    17fa:	10 e1       	ldi	r17, 0x10	; 16
    17fc:	ec cf       	rjmp	.-40     	; 0x17d6 <vfprintf+0x70>
    17fe:	60 2f       	mov	r22, r16
    1800:	70 e0       	ldi	r23, 0x00	; 0
    1802:	88 e6       	ldi	r24, 0x68	; 104
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	c2 d2       	rcall	.+1412   	; 0x1d8c <strchr_P>
    1808:	89 2b       	or	r24, r25
    180a:	41 f0       	breq	.+16     	; 0x181c <vfprintf+0xb6>
    180c:	53 01       	movw	r10, r6
    180e:	f4 e0       	ldi	r31, 0x04	; 4
    1810:	af 0e       	add	r10, r31
    1812:	b1 1c       	adc	r11, r1
    1814:	b6 01       	movw	r22, r12
    1816:	8f e3       	ldi	r24, 0x3F	; 63
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	10 c0       	rjmp	.+32     	; 0x183c <vfprintf+0xd6>
    181c:	03 36       	cpi	r16, 0x63	; 99
    181e:	31 f0       	breq	.+12     	; 0x182c <vfprintf+0xc6>
    1820:	03 37       	cpi	r16, 0x73	; 115
    1822:	71 f0       	breq	.+28     	; 0x1840 <vfprintf+0xda>
    1824:	03 35       	cpi	r16, 0x53	; 83
    1826:	01 f5       	brne	.+64     	; 0x1868 <vfprintf+0x102>
    1828:	11 60       	ori	r17, 0x01	; 1
    182a:	0a c0       	rjmp	.+20     	; 0x1840 <vfprintf+0xda>
    182c:	53 01       	movw	r10, r6
    182e:	82 e0       	ldi	r24, 0x02	; 2
    1830:	a8 0e       	add	r10, r24
    1832:	b1 1c       	adc	r11, r1
    1834:	b6 01       	movw	r22, r12
    1836:	f3 01       	movw	r30, r6
    1838:	80 81       	ld	r24, Z
    183a:	91 81       	ldd	r25, Z+1	; 0x01
    183c:	f9 d2       	rcall	.+1522   	; 0x1e30 <fputc>
    183e:	bf cf       	rjmp	.-130    	; 0x17be <vfprintf+0x58>
    1840:	53 01       	movw	r10, r6
    1842:	f2 e0       	ldi	r31, 0x02	; 2
    1844:	af 0e       	add	r10, r31
    1846:	b1 1c       	adc	r11, r1
    1848:	f3 01       	movw	r30, r6
    184a:	60 80       	ld	r6, Z
    184c:	71 80       	ldd	r7, Z+1	; 0x01
    184e:	f3 01       	movw	r30, r6
    1850:	10 fd       	sbrc	r17, 0
    1852:	85 91       	lpm	r24, Z+
    1854:	10 ff       	sbrs	r17, 0
    1856:	81 91       	ld	r24, Z+
    1858:	3f 01       	movw	r6, r30
    185a:	88 23       	and	r24, r24
    185c:	09 f4       	brne	.+2      	; 0x1860 <vfprintf+0xfa>
    185e:	af cf       	rjmp	.-162    	; 0x17be <vfprintf+0x58>
    1860:	b6 01       	movw	r22, r12
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	e5 d2       	rcall	.+1482   	; 0x1e30 <fputc>
    1866:	f3 cf       	rjmp	.-26     	; 0x184e <vfprintf+0xe8>
    1868:	04 36       	cpi	r16, 0x64	; 100
    186a:	11 f0       	breq	.+4      	; 0x1870 <vfprintf+0x10a>
    186c:	09 36       	cpi	r16, 0x69	; 105
    186e:	21 f5       	brne	.+72     	; 0x18b8 <vfprintf+0x152>
    1870:	53 01       	movw	r10, r6
    1872:	17 ff       	sbrs	r17, 7
    1874:	09 c0       	rjmp	.+18     	; 0x1888 <vfprintf+0x122>
    1876:	f4 e0       	ldi	r31, 0x04	; 4
    1878:	af 0e       	add	r10, r31
    187a:	b1 1c       	adc	r11, r1
    187c:	f3 01       	movw	r30, r6
    187e:	60 81       	ld	r22, Z
    1880:	71 81       	ldd	r23, Z+1	; 0x01
    1882:	82 81       	ldd	r24, Z+2	; 0x02
    1884:	93 81       	ldd	r25, Z+3	; 0x03
    1886:	0a c0       	rjmp	.+20     	; 0x189c <vfprintf+0x136>
    1888:	f2 e0       	ldi	r31, 0x02	; 2
    188a:	af 0e       	add	r10, r31
    188c:	b1 1c       	adc	r11, r1
    188e:	f3 01       	movw	r30, r6
    1890:	60 81       	ld	r22, Z
    1892:	71 81       	ldd	r23, Z+1	; 0x01
    1894:	07 2e       	mov	r0, r23
    1896:	00 0c       	add	r0, r0
    1898:	88 0b       	sbc	r24, r24
    189a:	99 0b       	sbc	r25, r25
    189c:	1f 7e       	andi	r17, 0xEF	; 239
    189e:	97 ff       	sbrs	r25, 7
    18a0:	08 c0       	rjmp	.+16     	; 0x18b2 <vfprintf+0x14c>
    18a2:	90 95       	com	r25
    18a4:	80 95       	com	r24
    18a6:	70 95       	com	r23
    18a8:	61 95       	neg	r22
    18aa:	7f 4f       	sbci	r23, 0xFF	; 255
    18ac:	8f 4f       	sbci	r24, 0xFF	; 255
    18ae:	9f 4f       	sbci	r25, 0xFF	; 255
    18b0:	10 64       	ori	r17, 0x40	; 64
    18b2:	2a e0       	ldi	r18, 0x0A	; 10
    18b4:	30 e0       	ldi	r19, 0x00	; 0
    18b6:	30 c0       	rjmp	.+96     	; 0x1918 <vfprintf+0x1b2>
    18b8:	00 37       	cpi	r16, 0x70	; 112
    18ba:	91 f0       	breq	.+36     	; 0x18e0 <vfprintf+0x17a>
    18bc:	40 f4       	brcc	.+16     	; 0x18ce <vfprintf+0x168>
    18be:	08 35       	cpi	r16, 0x58	; 88
    18c0:	a1 f0       	breq	.+40     	; 0x18ea <vfprintf+0x184>
    18c2:	0f 36       	cpi	r16, 0x6F	; 111
    18c4:	09 f0       	breq	.+2      	; 0x18c8 <vfprintf+0x162>
    18c6:	52 c0       	rjmp	.+164    	; 0x196c <vfprintf+0x206>
    18c8:	28 e0       	ldi	r18, 0x08	; 8
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	11 c0       	rjmp	.+34     	; 0x18f0 <vfprintf+0x18a>
    18ce:	05 37       	cpi	r16, 0x75	; 117
    18d0:	19 f0       	breq	.+6      	; 0x18d8 <vfprintf+0x172>
    18d2:	08 37       	cpi	r16, 0x78	; 120
    18d4:	31 f0       	breq	.+12     	; 0x18e2 <vfprintf+0x17c>
    18d6:	4a c0       	rjmp	.+148    	; 0x196c <vfprintf+0x206>
    18d8:	1f 7e       	andi	r17, 0xEF	; 239
    18da:	2a e0       	ldi	r18, 0x0A	; 10
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	08 c0       	rjmp	.+16     	; 0x18f0 <vfprintf+0x18a>
    18e0:	10 61       	ori	r17, 0x10	; 16
    18e2:	14 62       	ori	r17, 0x24	; 36
    18e4:	20 e1       	ldi	r18, 0x10	; 16
    18e6:	30 e0       	ldi	r19, 0x00	; 0
    18e8:	03 c0       	rjmp	.+6      	; 0x18f0 <vfprintf+0x18a>
    18ea:	14 60       	ori	r17, 0x04	; 4
    18ec:	20 e1       	ldi	r18, 0x10	; 16
    18ee:	32 e0       	ldi	r19, 0x02	; 2
    18f0:	53 01       	movw	r10, r6
    18f2:	17 ff       	sbrs	r17, 7
    18f4:	09 c0       	rjmp	.+18     	; 0x1908 <vfprintf+0x1a2>
    18f6:	f4 e0       	ldi	r31, 0x04	; 4
    18f8:	af 0e       	add	r10, r31
    18fa:	b1 1c       	adc	r11, r1
    18fc:	f3 01       	movw	r30, r6
    18fe:	60 81       	ld	r22, Z
    1900:	71 81       	ldd	r23, Z+1	; 0x01
    1902:	82 81       	ldd	r24, Z+2	; 0x02
    1904:	93 81       	ldd	r25, Z+3	; 0x03
    1906:	08 c0       	rjmp	.+16     	; 0x1918 <vfprintf+0x1b2>
    1908:	f2 e0       	ldi	r31, 0x02	; 2
    190a:	af 0e       	add	r10, r31
    190c:	b1 1c       	adc	r11, r1
    190e:	f3 01       	movw	r30, r6
    1910:	60 81       	ld	r22, Z
    1912:	71 81       	ldd	r23, Z+1	; 0x01
    1914:	80 e0       	ldi	r24, 0x00	; 0
    1916:	90 e0       	ldi	r25, 0x00	; 0
    1918:	a4 01       	movw	r20, r8
    191a:	df d2       	rcall	.+1470   	; 0x1eda <__ultoa_invert>
    191c:	08 2f       	mov	r16, r24
    191e:	08 19       	sub	r16, r8
    1920:	16 ff       	sbrs	r17, 6
    1922:	04 c0       	rjmp	.+8      	; 0x192c <vfprintf+0x1c6>
    1924:	b6 01       	movw	r22, r12
    1926:	8d e2       	ldi	r24, 0x2D	; 45
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	82 d2       	rcall	.+1284   	; 0x1e30 <fputc>
    192c:	14 ff       	sbrs	r17, 4
    192e:	13 c0       	rjmp	.+38     	; 0x1956 <vfprintf+0x1f0>
    1930:	fe 01       	movw	r30, r28
    1932:	e0 0f       	add	r30, r16
    1934:	f1 1d       	adc	r31, r1
    1936:	80 81       	ld	r24, Z
    1938:	80 33       	cpi	r24, 0x30	; 48
    193a:	69 f0       	breq	.+26     	; 0x1956 <vfprintf+0x1f0>
    193c:	b6 01       	movw	r22, r12
    193e:	80 e3       	ldi	r24, 0x30	; 48
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	76 d2       	rcall	.+1260   	; 0x1e30 <fputc>
    1944:	12 ff       	sbrs	r17, 2
    1946:	07 c0       	rjmp	.+14     	; 0x1956 <vfprintf+0x1f0>
    1948:	10 72       	andi	r17, 0x20	; 32
    194a:	81 2f       	mov	r24, r17
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	b6 01       	movw	r22, r12
    1950:	88 5a       	subi	r24, 0xA8	; 168
    1952:	9f 4f       	sbci	r25, 0xFF	; 255
    1954:	6d d2       	rcall	.+1242   	; 0x1e30 <fputc>
    1956:	01 50       	subi	r16, 0x01	; 1
    1958:	f4 01       	movw	r30, r8
    195a:	e0 0f       	add	r30, r16
    195c:	f1 1d       	adc	r31, r1
    195e:	80 81       	ld	r24, Z
    1960:	b6 01       	movw	r22, r12
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	65 d2       	rcall	.+1226   	; 0x1e30 <fputc>
    1966:	01 11       	cpse	r16, r1
    1968:	f6 cf       	rjmp	.-20     	; 0x1956 <vfprintf+0x1f0>
    196a:	29 cf       	rjmp	.-430    	; 0x17be <vfprintf+0x58>
    196c:	f6 01       	movw	r30, r12
    196e:	86 81       	ldd	r24, Z+6	; 0x06
    1970:	97 81       	ldd	r25, Z+7	; 0x07
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <vfprintf+0x212>
    1974:	8f ef       	ldi	r24, 0xFF	; 255
    1976:	9f ef       	ldi	r25, 0xFF	; 255
    1978:	2b 96       	adiw	r28, 0x0b	; 11
    197a:	ee e0       	ldi	r30, 0x0E	; 14
    197c:	e8 c1       	rjmp	.+976    	; 0x1d4e <__epilogue_restores__+0x8>

0000197e <putval>:
    197e:	20 fd       	sbrc	r18, 0
    1980:	09 c0       	rjmp	.+18     	; 0x1994 <putval+0x16>
    1982:	fc 01       	movw	r30, r24
    1984:	23 fd       	sbrc	r18, 3
    1986:	05 c0       	rjmp	.+10     	; 0x1992 <putval+0x14>
    1988:	22 ff       	sbrs	r18, 2
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <putval+0x12>
    198c:	73 83       	std	Z+3, r23	; 0x03
    198e:	62 83       	std	Z+2, r22	; 0x02
    1990:	51 83       	std	Z+1, r21	; 0x01
    1992:	40 83       	st	Z, r20
    1994:	08 95       	ret

00001996 <mulacc>:
    1996:	44 fd       	sbrc	r20, 4
    1998:	17 c0       	rjmp	.+46     	; 0x19c8 <mulacc+0x32>
    199a:	46 fd       	sbrc	r20, 6
    199c:	17 c0       	rjmp	.+46     	; 0x19cc <mulacc+0x36>
    199e:	ab 01       	movw	r20, r22
    19a0:	bc 01       	movw	r22, r24
    19a2:	da 01       	movw	r26, r20
    19a4:	fb 01       	movw	r30, r22
    19a6:	aa 0f       	add	r26, r26
    19a8:	bb 1f       	adc	r27, r27
    19aa:	ee 1f       	adc	r30, r30
    19ac:	ff 1f       	adc	r31, r31
    19ae:	10 94       	com	r1
    19b0:	d1 f7       	brne	.-12     	; 0x19a6 <mulacc+0x10>
    19b2:	4a 0f       	add	r20, r26
    19b4:	5b 1f       	adc	r21, r27
    19b6:	6e 1f       	adc	r22, r30
    19b8:	7f 1f       	adc	r23, r31
    19ba:	cb 01       	movw	r24, r22
    19bc:	ba 01       	movw	r22, r20
    19be:	66 0f       	add	r22, r22
    19c0:	77 1f       	adc	r23, r23
    19c2:	88 1f       	adc	r24, r24
    19c4:	99 1f       	adc	r25, r25
    19c6:	09 c0       	rjmp	.+18     	; 0x19da <mulacc+0x44>
    19c8:	33 e0       	ldi	r19, 0x03	; 3
    19ca:	01 c0       	rjmp	.+2      	; 0x19ce <mulacc+0x38>
    19cc:	34 e0       	ldi	r19, 0x04	; 4
    19ce:	66 0f       	add	r22, r22
    19d0:	77 1f       	adc	r23, r23
    19d2:	88 1f       	adc	r24, r24
    19d4:	99 1f       	adc	r25, r25
    19d6:	31 50       	subi	r19, 0x01	; 1
    19d8:	d1 f7       	brne	.-12     	; 0x19ce <mulacc+0x38>
    19da:	62 0f       	add	r22, r18
    19dc:	71 1d       	adc	r23, r1
    19de:	81 1d       	adc	r24, r1
    19e0:	91 1d       	adc	r25, r1
    19e2:	08 95       	ret

000019e4 <skip_spaces>:
    19e4:	0f 93       	push	r16
    19e6:	1f 93       	push	r17
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	8c 01       	movw	r16, r24
    19ee:	c8 01       	movw	r24, r16
    19f0:	e1 d1       	rcall	.+962    	; 0x1db4 <fgetc>
    19f2:	ec 01       	movw	r28, r24
    19f4:	97 fd       	sbrc	r25, 7
    19f6:	06 c0       	rjmp	.+12     	; 0x1a04 <skip_spaces+0x20>
    19f8:	c1 d1       	rcall	.+898    	; 0x1d7c <isspace>
    19fa:	89 2b       	or	r24, r25
    19fc:	c1 f7       	brne	.-16     	; 0x19ee <skip_spaces+0xa>
    19fe:	b8 01       	movw	r22, r16
    1a00:	ce 01       	movw	r24, r28
    1a02:	52 d2       	rcall	.+1188   	; 0x1ea8 <ungetc>
    1a04:	ce 01       	movw	r24, r28
    1a06:	df 91       	pop	r29
    1a08:	cf 91       	pop	r28
    1a0a:	1f 91       	pop	r17
    1a0c:	0f 91       	pop	r16
    1a0e:	08 95       	ret

00001a10 <conv_int>:
    1a10:	8f 92       	push	r8
    1a12:	9f 92       	push	r9
    1a14:	af 92       	push	r10
    1a16:	bf 92       	push	r11
    1a18:	ef 92       	push	r14
    1a1a:	ff 92       	push	r15
    1a1c:	0f 93       	push	r16
    1a1e:	1f 93       	push	r17
    1a20:	cf 93       	push	r28
    1a22:	df 93       	push	r29
    1a24:	8c 01       	movw	r16, r24
    1a26:	d6 2f       	mov	r29, r22
    1a28:	7a 01       	movw	r14, r20
    1a2a:	b2 2e       	mov	r11, r18
    1a2c:	c3 d1       	rcall	.+902    	; 0x1db4 <fgetc>
    1a2e:	9c 01       	movw	r18, r24
    1a30:	33 27       	eor	r19, r19
    1a32:	2b 32       	cpi	r18, 0x2B	; 43
    1a34:	31 05       	cpc	r19, r1
    1a36:	31 f0       	breq	.+12     	; 0x1a44 <conv_int+0x34>
    1a38:	2d 32       	cpi	r18, 0x2D	; 45
    1a3a:	31 05       	cpc	r19, r1
    1a3c:	59 f4       	brne	.+22     	; 0x1a54 <conv_int+0x44>
    1a3e:	8b 2d       	mov	r24, r11
    1a40:	80 68       	ori	r24, 0x80	; 128
    1a42:	b8 2e       	mov	r11, r24
    1a44:	d1 50       	subi	r29, 0x01	; 1
    1a46:	11 f4       	brne	.+4      	; 0x1a4c <conv_int+0x3c>
    1a48:	80 e0       	ldi	r24, 0x00	; 0
    1a4a:	61 c0       	rjmp	.+194    	; 0x1b0e <conv_int+0xfe>
    1a4c:	c8 01       	movw	r24, r16
    1a4e:	b2 d1       	rcall	.+868    	; 0x1db4 <fgetc>
    1a50:	97 fd       	sbrc	r25, 7
    1a52:	fa cf       	rjmp	.-12     	; 0x1a48 <conv_int+0x38>
    1a54:	cb 2d       	mov	r28, r11
    1a56:	cd 7f       	andi	r28, 0xFD	; 253
    1a58:	2b 2d       	mov	r18, r11
    1a5a:	20 73       	andi	r18, 0x30	; 48
    1a5c:	f9 f4       	brne	.+62     	; 0x1a9c <conv_int+0x8c>
    1a5e:	80 33       	cpi	r24, 0x30	; 48
    1a60:	e9 f4       	brne	.+58     	; 0x1a9c <conv_int+0x8c>
    1a62:	aa 24       	eor	r10, r10
    1a64:	aa 94       	dec	r10
    1a66:	ad 0e       	add	r10, r29
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <conv_int+0x5c>
    1a6a:	3e c0       	rjmp	.+124    	; 0x1ae8 <conv_int+0xd8>
    1a6c:	c8 01       	movw	r24, r16
    1a6e:	a2 d1       	rcall	.+836    	; 0x1db4 <fgetc>
    1a70:	97 fd       	sbrc	r25, 7
    1a72:	3a c0       	rjmp	.+116    	; 0x1ae8 <conv_int+0xd8>
    1a74:	9c 01       	movw	r18, r24
    1a76:	2f 7d       	andi	r18, 0xDF	; 223
    1a78:	33 27       	eor	r19, r19
    1a7a:	28 35       	cpi	r18, 0x58	; 88
    1a7c:	31 05       	cpc	r19, r1
    1a7e:	41 f4       	brne	.+16     	; 0x1a90 <conv_int+0x80>
    1a80:	c2 64       	ori	r28, 0x42	; 66
    1a82:	d2 50       	subi	r29, 0x02	; 2
    1a84:	89 f1       	breq	.+98     	; 0x1ae8 <conv_int+0xd8>
    1a86:	c8 01       	movw	r24, r16
    1a88:	95 d1       	rcall	.+810    	; 0x1db4 <fgetc>
    1a8a:	97 ff       	sbrs	r25, 7
    1a8c:	07 c0       	rjmp	.+14     	; 0x1a9c <conv_int+0x8c>
    1a8e:	2c c0       	rjmp	.+88     	; 0x1ae8 <conv_int+0xd8>
    1a90:	b6 fe       	sbrs	r11, 6
    1a92:	02 c0       	rjmp	.+4      	; 0x1a98 <conv_int+0x88>
    1a94:	c2 60       	ori	r28, 0x02	; 2
    1a96:	01 c0       	rjmp	.+2      	; 0x1a9a <conv_int+0x8a>
    1a98:	c2 61       	ori	r28, 0x12	; 18
    1a9a:	da 2d       	mov	r29, r10
    1a9c:	81 2c       	mov	r8, r1
    1a9e:	91 2c       	mov	r9, r1
    1aa0:	54 01       	movw	r10, r8
    1aa2:	20 ed       	ldi	r18, 0xD0	; 208
    1aa4:	28 0f       	add	r18, r24
    1aa6:	28 30       	cpi	r18, 0x08	; 8
    1aa8:	78 f0       	brcs	.+30     	; 0x1ac8 <conv_int+0xb8>
    1aaa:	c4 ff       	sbrs	r28, 4
    1aac:	03 c0       	rjmp	.+6      	; 0x1ab4 <conv_int+0xa4>
    1aae:	b8 01       	movw	r22, r16
    1ab0:	fb d1       	rcall	.+1014   	; 0x1ea8 <ungetc>
    1ab2:	17 c0       	rjmp	.+46     	; 0x1ae2 <conv_int+0xd2>
    1ab4:	2a 30       	cpi	r18, 0x0A	; 10
    1ab6:	40 f0       	brcs	.+16     	; 0x1ac8 <conv_int+0xb8>
    1ab8:	c6 ff       	sbrs	r28, 6
    1aba:	f9 cf       	rjmp	.-14     	; 0x1aae <conv_int+0x9e>
    1abc:	2f 7d       	andi	r18, 0xDF	; 223
    1abe:	3f ee       	ldi	r19, 0xEF	; 239
    1ac0:	32 0f       	add	r19, r18
    1ac2:	36 30       	cpi	r19, 0x06	; 6
    1ac4:	a0 f7       	brcc	.-24     	; 0x1aae <conv_int+0x9e>
    1ac6:	27 50       	subi	r18, 0x07	; 7
    1ac8:	4c 2f       	mov	r20, r28
    1aca:	c5 01       	movw	r24, r10
    1acc:	b4 01       	movw	r22, r8
    1ace:	63 df       	rcall	.-314    	; 0x1996 <mulacc>
    1ad0:	4b 01       	movw	r8, r22
    1ad2:	5c 01       	movw	r10, r24
    1ad4:	c2 60       	ori	r28, 0x02	; 2
    1ad6:	d1 50       	subi	r29, 0x01	; 1
    1ad8:	51 f0       	breq	.+20     	; 0x1aee <conv_int+0xde>
    1ada:	c8 01       	movw	r24, r16
    1adc:	6b d1       	rcall	.+726    	; 0x1db4 <fgetc>
    1ade:	97 ff       	sbrs	r25, 7
    1ae0:	e0 cf       	rjmp	.-64     	; 0x1aa2 <conv_int+0x92>
    1ae2:	c1 fd       	sbrc	r28, 1
    1ae4:	04 c0       	rjmp	.+8      	; 0x1aee <conv_int+0xde>
    1ae6:	b0 cf       	rjmp	.-160    	; 0x1a48 <conv_int+0x38>
    1ae8:	81 2c       	mov	r8, r1
    1aea:	91 2c       	mov	r9, r1
    1aec:	54 01       	movw	r10, r8
    1aee:	c7 ff       	sbrs	r28, 7
    1af0:	08 c0       	rjmp	.+16     	; 0x1b02 <conv_int+0xf2>
    1af2:	b0 94       	com	r11
    1af4:	a0 94       	com	r10
    1af6:	90 94       	com	r9
    1af8:	80 94       	com	r8
    1afa:	81 1c       	adc	r8, r1
    1afc:	91 1c       	adc	r9, r1
    1afe:	a1 1c       	adc	r10, r1
    1b00:	b1 1c       	adc	r11, r1
    1b02:	2c 2f       	mov	r18, r28
    1b04:	b5 01       	movw	r22, r10
    1b06:	a4 01       	movw	r20, r8
    1b08:	c7 01       	movw	r24, r14
    1b0a:	39 df       	rcall	.-398    	; 0x197e <putval>
    1b0c:	81 e0       	ldi	r24, 0x01	; 1
    1b0e:	df 91       	pop	r29
    1b10:	cf 91       	pop	r28
    1b12:	1f 91       	pop	r17
    1b14:	0f 91       	pop	r16
    1b16:	ff 90       	pop	r15
    1b18:	ef 90       	pop	r14
    1b1a:	bf 90       	pop	r11
    1b1c:	af 90       	pop	r10
    1b1e:	9f 90       	pop	r9
    1b20:	8f 90       	pop	r8
    1b22:	08 95       	ret

00001b24 <vfscanf>:
    1b24:	a0 e0       	ldi	r26, 0x00	; 0
    1b26:	b0 e0       	ldi	r27, 0x00	; 0
    1b28:	e7 e9       	ldi	r30, 0x97	; 151
    1b2a:	fd e0       	ldi	r31, 0x0D	; 13
    1b2c:	f3 c0       	rjmp	.+486    	; 0x1d14 <__prologue_saves__+0x6>
    1b2e:	6c 01       	movw	r12, r24
    1b30:	eb 01       	movw	r28, r22
    1b32:	5a 01       	movw	r10, r20
    1b34:	fc 01       	movw	r30, r24
    1b36:	17 82       	std	Z+7, r1	; 0x07
    1b38:	16 82       	std	Z+6, r1	; 0x06
    1b3a:	51 2c       	mov	r5, r1
    1b3c:	f6 01       	movw	r30, r12
    1b3e:	f3 80       	ldd	r15, Z+3	; 0x03
    1b40:	fe 01       	movw	r30, r28
    1b42:	f3 fc       	sbrc	r15, 3
    1b44:	85 91       	lpm	r24, Z+
    1b46:	f3 fe       	sbrs	r15, 3
    1b48:	81 91       	ld	r24, Z+
    1b4a:	18 2f       	mov	r17, r24
    1b4c:	ef 01       	movw	r28, r30
    1b4e:	88 23       	and	r24, r24
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <vfscanf+0x30>
    1b52:	d4 c0       	rjmp	.+424    	; 0x1cfc <vfscanf+0x1d8>
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	12 d1       	rcall	.+548    	; 0x1d7c <isspace>
    1b58:	89 2b       	or	r24, r25
    1b5a:	19 f0       	breq	.+6      	; 0x1b62 <vfscanf+0x3e>
    1b5c:	c6 01       	movw	r24, r12
    1b5e:	42 df       	rcall	.-380    	; 0x19e4 <skip_spaces>
    1b60:	ed cf       	rjmp	.-38     	; 0x1b3c <vfscanf+0x18>
    1b62:	15 32       	cpi	r17, 0x25	; 37
    1b64:	41 f4       	brne	.+16     	; 0x1b76 <vfscanf+0x52>
    1b66:	fe 01       	movw	r30, r28
    1b68:	f3 fc       	sbrc	r15, 3
    1b6a:	15 91       	lpm	r17, Z+
    1b6c:	f3 fe       	sbrs	r15, 3
    1b6e:	11 91       	ld	r17, Z+
    1b70:	ef 01       	movw	r28, r30
    1b72:	15 32       	cpi	r17, 0x25	; 37
    1b74:	71 f4       	brne	.+28     	; 0x1b92 <vfscanf+0x6e>
    1b76:	c6 01       	movw	r24, r12
    1b78:	1d d1       	rcall	.+570    	; 0x1db4 <fgetc>
    1b7a:	97 fd       	sbrc	r25, 7
    1b7c:	bd c0       	rjmp	.+378    	; 0x1cf8 <vfscanf+0x1d4>
    1b7e:	41 2f       	mov	r20, r17
    1b80:	50 e0       	ldi	r21, 0x00	; 0
    1b82:	9c 01       	movw	r18, r24
    1b84:	33 27       	eor	r19, r19
    1b86:	24 17       	cp	r18, r20
    1b88:	35 07       	cpc	r19, r21
    1b8a:	c1 f2       	breq	.-80     	; 0x1b3c <vfscanf+0x18>
    1b8c:	b6 01       	movw	r22, r12
    1b8e:	8c d1       	rcall	.+792    	; 0x1ea8 <ungetc>
    1b90:	b5 c0       	rjmp	.+362    	; 0x1cfc <vfscanf+0x1d8>
    1b92:	1a 32       	cpi	r17, 0x2A	; 42
    1b94:	39 f4       	brne	.+14     	; 0x1ba4 <vfscanf+0x80>
    1b96:	f3 fc       	sbrc	r15, 3
    1b98:	15 91       	lpm	r17, Z+
    1b9a:	f3 fe       	sbrs	r15, 3
    1b9c:	11 91       	ld	r17, Z+
    1b9e:	ef 01       	movw	r28, r30
    1ba0:	01 e0       	ldi	r16, 0x01	; 1
    1ba2:	01 c0       	rjmp	.+2      	; 0x1ba6 <vfscanf+0x82>
    1ba4:	00 e0       	ldi	r16, 0x00	; 0
    1ba6:	e1 2c       	mov	r14, r1
    1ba8:	20 ed       	ldi	r18, 0xD0	; 208
    1baa:	21 0f       	add	r18, r17
    1bac:	2a 30       	cpi	r18, 0x0A	; 10
    1bae:	78 f4       	brcc	.+30     	; 0x1bce <vfscanf+0xaa>
    1bb0:	02 60       	ori	r16, 0x02	; 2
    1bb2:	6e 2d       	mov	r22, r14
    1bb4:	70 e0       	ldi	r23, 0x00	; 0
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	40 e2       	ldi	r20, 0x20	; 32
    1bbc:	ec de       	rcall	.-552    	; 0x1996 <mulacc>
    1bbe:	e6 2e       	mov	r14, r22
    1bc0:	fe 01       	movw	r30, r28
    1bc2:	f3 fc       	sbrc	r15, 3
    1bc4:	15 91       	lpm	r17, Z+
    1bc6:	f3 fe       	sbrs	r15, 3
    1bc8:	11 91       	ld	r17, Z+
    1bca:	ef 01       	movw	r28, r30
    1bcc:	ed cf       	rjmp	.-38     	; 0x1ba8 <vfscanf+0x84>
    1bce:	01 ff       	sbrs	r16, 1
    1bd0:	03 c0       	rjmp	.+6      	; 0x1bd8 <vfscanf+0xb4>
    1bd2:	e1 10       	cpse	r14, r1
    1bd4:	03 c0       	rjmp	.+6      	; 0x1bdc <vfscanf+0xb8>
    1bd6:	92 c0       	rjmp	.+292    	; 0x1cfc <vfscanf+0x1d8>
    1bd8:	ee 24       	eor	r14, r14
    1bda:	ea 94       	dec	r14
    1bdc:	18 36       	cpi	r17, 0x68	; 104
    1bde:	19 f0       	breq	.+6      	; 0x1be6 <vfscanf+0xc2>
    1be0:	1c 36       	cpi	r17, 0x6C	; 108
    1be2:	51 f0       	breq	.+20     	; 0x1bf8 <vfscanf+0xd4>
    1be4:	10 c0       	rjmp	.+32     	; 0x1c06 <vfscanf+0xe2>
    1be6:	fe 01       	movw	r30, r28
    1be8:	f3 fc       	sbrc	r15, 3
    1bea:	15 91       	lpm	r17, Z+
    1bec:	f3 fe       	sbrs	r15, 3
    1bee:	11 91       	ld	r17, Z+
    1bf0:	ef 01       	movw	r28, r30
    1bf2:	18 36       	cpi	r17, 0x68	; 104
    1bf4:	41 f4       	brne	.+16     	; 0x1c06 <vfscanf+0xe2>
    1bf6:	08 60       	ori	r16, 0x08	; 8
    1bf8:	04 60       	ori	r16, 0x04	; 4
    1bfa:	fe 01       	movw	r30, r28
    1bfc:	f3 fc       	sbrc	r15, 3
    1bfe:	15 91       	lpm	r17, Z+
    1c00:	f3 fe       	sbrs	r15, 3
    1c02:	11 91       	ld	r17, Z+
    1c04:	ef 01       	movw	r28, r30
    1c06:	11 23       	and	r17, r17
    1c08:	09 f4       	brne	.+2      	; 0x1c0c <vfscanf+0xe8>
    1c0a:	78 c0       	rjmp	.+240    	; 0x1cfc <vfscanf+0x1d8>
    1c0c:	61 2f       	mov	r22, r17
    1c0e:	70 e0       	ldi	r23, 0x00	; 0
    1c10:	8f e7       	ldi	r24, 0x7F	; 127
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	bb d0       	rcall	.+374    	; 0x1d8c <strchr_P>
    1c16:	89 2b       	or	r24, r25
    1c18:	09 f4       	brne	.+2      	; 0x1c1c <vfscanf+0xf8>
    1c1a:	70 c0       	rjmp	.+224    	; 0x1cfc <vfscanf+0x1d8>
    1c1c:	00 fd       	sbrc	r16, 0
    1c1e:	07 c0       	rjmp	.+14     	; 0x1c2e <vfscanf+0x10a>
    1c20:	f5 01       	movw	r30, r10
    1c22:	80 80       	ld	r8, Z
    1c24:	91 80       	ldd	r9, Z+1	; 0x01
    1c26:	c5 01       	movw	r24, r10
    1c28:	02 96       	adiw	r24, 0x02	; 2
    1c2a:	5c 01       	movw	r10, r24
    1c2c:	02 c0       	rjmp	.+4      	; 0x1c32 <vfscanf+0x10e>
    1c2e:	81 2c       	mov	r8, r1
    1c30:	91 2c       	mov	r9, r1
    1c32:	1e 36       	cpi	r17, 0x6E	; 110
    1c34:	49 f4       	brne	.+18     	; 0x1c48 <vfscanf+0x124>
    1c36:	f6 01       	movw	r30, r12
    1c38:	46 81       	ldd	r20, Z+6	; 0x06
    1c3a:	57 81       	ldd	r21, Z+7	; 0x07
    1c3c:	60 e0       	ldi	r22, 0x00	; 0
    1c3e:	70 e0       	ldi	r23, 0x00	; 0
    1c40:	20 2f       	mov	r18, r16
    1c42:	c4 01       	movw	r24, r8
    1c44:	9c de       	rcall	.-712    	; 0x197e <putval>
    1c46:	7a cf       	rjmp	.-268    	; 0x1b3c <vfscanf+0x18>
    1c48:	13 36       	cpi	r17, 0x63	; 99
    1c4a:	a1 f4       	brne	.+40     	; 0x1c74 <vfscanf+0x150>
    1c4c:	01 fd       	sbrc	r16, 1
    1c4e:	02 c0       	rjmp	.+4      	; 0x1c54 <vfscanf+0x130>
    1c50:	ee 24       	eor	r14, r14
    1c52:	e3 94       	inc	r14
    1c54:	c6 01       	movw	r24, r12
    1c56:	ae d0       	rcall	.+348    	; 0x1db4 <fgetc>
    1c58:	97 fd       	sbrc	r25, 7
    1c5a:	4e c0       	rjmp	.+156    	; 0x1cf8 <vfscanf+0x1d4>
    1c5c:	81 14       	cp	r8, r1
    1c5e:	91 04       	cpc	r9, r1
    1c60:	29 f0       	breq	.+10     	; 0x1c6c <vfscanf+0x148>
    1c62:	f4 01       	movw	r30, r8
    1c64:	80 83       	st	Z, r24
    1c66:	c4 01       	movw	r24, r8
    1c68:	01 96       	adiw	r24, 0x01	; 1
    1c6a:	4c 01       	movw	r8, r24
    1c6c:	ea 94       	dec	r14
    1c6e:	e1 10       	cpse	r14, r1
    1c70:	f1 cf       	rjmp	.-30     	; 0x1c54 <vfscanf+0x130>
    1c72:	3e c0       	rjmp	.+124    	; 0x1cf0 <vfscanf+0x1cc>
    1c74:	c6 01       	movw	r24, r12
    1c76:	b6 de       	rcall	.-660    	; 0x19e4 <skip_spaces>
    1c78:	97 fd       	sbrc	r25, 7
    1c7a:	3e c0       	rjmp	.+124    	; 0x1cf8 <vfscanf+0x1d4>
    1c7c:	1f 36       	cpi	r17, 0x6F	; 111
    1c7e:	49 f1       	breq	.+82     	; 0x1cd2 <vfscanf+0x1ae>
    1c80:	28 f4       	brcc	.+10     	; 0x1c8c <vfscanf+0x168>
    1c82:	14 36       	cpi	r17, 0x64	; 100
    1c84:	21 f1       	breq	.+72     	; 0x1cce <vfscanf+0x1aa>
    1c86:	19 36       	cpi	r17, 0x69	; 105
    1c88:	39 f1       	breq	.+78     	; 0x1cd8 <vfscanf+0x1b4>
    1c8a:	25 c0       	rjmp	.+74     	; 0x1cd6 <vfscanf+0x1b2>
    1c8c:	13 37       	cpi	r17, 0x73	; 115
    1c8e:	71 f0       	breq	.+28     	; 0x1cac <vfscanf+0x188>
    1c90:	15 37       	cpi	r17, 0x75	; 117
    1c92:	e9 f0       	breq	.+58     	; 0x1cce <vfscanf+0x1aa>
    1c94:	20 c0       	rjmp	.+64     	; 0x1cd6 <vfscanf+0x1b2>
    1c96:	81 14       	cp	r8, r1
    1c98:	91 04       	cpc	r9, r1
    1c9a:	29 f0       	breq	.+10     	; 0x1ca6 <vfscanf+0x182>
    1c9c:	f4 01       	movw	r30, r8
    1c9e:	60 82       	st	Z, r6
    1ca0:	c4 01       	movw	r24, r8
    1ca2:	01 96       	adiw	r24, 0x01	; 1
    1ca4:	4c 01       	movw	r8, r24
    1ca6:	ea 94       	dec	r14
    1ca8:	ee 20       	and	r14, r14
    1caa:	59 f0       	breq	.+22     	; 0x1cc2 <vfscanf+0x19e>
    1cac:	c6 01       	movw	r24, r12
    1cae:	82 d0       	rcall	.+260    	; 0x1db4 <fgetc>
    1cb0:	3c 01       	movw	r6, r24
    1cb2:	97 fd       	sbrc	r25, 7
    1cb4:	06 c0       	rjmp	.+12     	; 0x1cc2 <vfscanf+0x19e>
    1cb6:	62 d0       	rcall	.+196    	; 0x1d7c <isspace>
    1cb8:	89 2b       	or	r24, r25
    1cba:	69 f3       	breq	.-38     	; 0x1c96 <vfscanf+0x172>
    1cbc:	b6 01       	movw	r22, r12
    1cbe:	c3 01       	movw	r24, r6
    1cc0:	f3 d0       	rcall	.+486    	; 0x1ea8 <ungetc>
    1cc2:	81 14       	cp	r8, r1
    1cc4:	91 04       	cpc	r9, r1
    1cc6:	a1 f0       	breq	.+40     	; 0x1cf0 <vfscanf+0x1cc>
    1cc8:	f4 01       	movw	r30, r8
    1cca:	10 82       	st	Z, r1
    1ccc:	11 c0       	rjmp	.+34     	; 0x1cf0 <vfscanf+0x1cc>
    1cce:	00 62       	ori	r16, 0x20	; 32
    1cd0:	03 c0       	rjmp	.+6      	; 0x1cd8 <vfscanf+0x1b4>
    1cd2:	00 61       	ori	r16, 0x10	; 16
    1cd4:	01 c0       	rjmp	.+2      	; 0x1cd8 <vfscanf+0x1b4>
    1cd6:	00 64       	ori	r16, 0x40	; 64
    1cd8:	20 2f       	mov	r18, r16
    1cda:	a4 01       	movw	r20, r8
    1cdc:	6e 2d       	mov	r22, r14
    1cde:	c6 01       	movw	r24, r12
    1ce0:	97 de       	rcall	.-722    	; 0x1a10 <conv_int>
    1ce2:	81 11       	cpse	r24, r1
    1ce4:	05 c0       	rjmp	.+10     	; 0x1cf0 <vfscanf+0x1cc>
    1ce6:	f6 01       	movw	r30, r12
    1ce8:	83 81       	ldd	r24, Z+3	; 0x03
    1cea:	80 73       	andi	r24, 0x30	; 48
    1cec:	29 f4       	brne	.+10     	; 0x1cf8 <vfscanf+0x1d4>
    1cee:	06 c0       	rjmp	.+12     	; 0x1cfc <vfscanf+0x1d8>
    1cf0:	00 fd       	sbrc	r16, 0
    1cf2:	24 cf       	rjmp	.-440    	; 0x1b3c <vfscanf+0x18>
    1cf4:	53 94       	inc	r5
    1cf6:	22 cf       	rjmp	.-444    	; 0x1b3c <vfscanf+0x18>
    1cf8:	55 20       	and	r5, r5
    1cfa:	19 f0       	breq	.+6      	; 0x1d02 <vfscanf+0x1de>
    1cfc:	85 2d       	mov	r24, r5
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	02 c0       	rjmp	.+4      	; 0x1d06 <vfscanf+0x1e2>
    1d02:	8f ef       	ldi	r24, 0xFF	; 255
    1d04:	9f ef       	ldi	r25, 0xFF	; 255
    1d06:	cd b7       	in	r28, 0x3d	; 61
    1d08:	de b7       	in	r29, 0x3e	; 62
    1d0a:	ef e0       	ldi	r30, 0x0F	; 15
    1d0c:	1f c0       	rjmp	.+62     	; 0x1d4c <__epilogue_restores__+0x6>

00001d0e <__prologue_saves__>:
    1d0e:	2f 92       	push	r2
    1d10:	3f 92       	push	r3
    1d12:	4f 92       	push	r4
    1d14:	5f 92       	push	r5
    1d16:	6f 92       	push	r6
    1d18:	7f 92       	push	r7
    1d1a:	8f 92       	push	r8
    1d1c:	9f 92       	push	r9
    1d1e:	af 92       	push	r10
    1d20:	bf 92       	push	r11
    1d22:	cf 92       	push	r12
    1d24:	df 92       	push	r13
    1d26:	ef 92       	push	r14
    1d28:	ff 92       	push	r15
    1d2a:	0f 93       	push	r16
    1d2c:	1f 93       	push	r17
    1d2e:	cf 93       	push	r28
    1d30:	df 93       	push	r29
    1d32:	cd b7       	in	r28, 0x3d	; 61
    1d34:	de b7       	in	r29, 0x3e	; 62
    1d36:	ca 1b       	sub	r28, r26
    1d38:	db 0b       	sbc	r29, r27
    1d3a:	0f b6       	in	r0, 0x3f	; 63
    1d3c:	f8 94       	cli
    1d3e:	de bf       	out	0x3e, r29	; 62
    1d40:	0f be       	out	0x3f, r0	; 63
    1d42:	cd bf       	out	0x3d, r28	; 61
    1d44:	09 94       	ijmp

00001d46 <__epilogue_restores__>:
    1d46:	2a 88       	ldd	r2, Y+18	; 0x12
    1d48:	39 88       	ldd	r3, Y+17	; 0x11
    1d4a:	48 88       	ldd	r4, Y+16	; 0x10
    1d4c:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d4e:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d50:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d52:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d54:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d56:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d58:	b9 84       	ldd	r11, Y+9	; 0x09
    1d5a:	c8 84       	ldd	r12, Y+8	; 0x08
    1d5c:	df 80       	ldd	r13, Y+7	; 0x07
    1d5e:	ee 80       	ldd	r14, Y+6	; 0x06
    1d60:	fd 80       	ldd	r15, Y+5	; 0x05
    1d62:	0c 81       	ldd	r16, Y+4	; 0x04
    1d64:	1b 81       	ldd	r17, Y+3	; 0x03
    1d66:	aa 81       	ldd	r26, Y+2	; 0x02
    1d68:	b9 81       	ldd	r27, Y+1	; 0x01
    1d6a:	ce 0f       	add	r28, r30
    1d6c:	d1 1d       	adc	r29, r1
    1d6e:	0f b6       	in	r0, 0x3f	; 63
    1d70:	f8 94       	cli
    1d72:	de bf       	out	0x3e, r29	; 62
    1d74:	0f be       	out	0x3f, r0	; 63
    1d76:	cd bf       	out	0x3d, r28	; 61
    1d78:	ed 01       	movw	r28, r26
    1d7a:	08 95       	ret

00001d7c <isspace>:
    1d7c:	91 11       	cpse	r25, r1
    1d7e:	0b c1       	rjmp	.+534    	; 0x1f96 <__ctype_isfalse>
    1d80:	80 32       	cpi	r24, 0x20	; 32
    1d82:	19 f0       	breq	.+6      	; 0x1d8a <isspace+0xe>
    1d84:	89 50       	subi	r24, 0x09	; 9
    1d86:	85 50       	subi	r24, 0x05	; 5
    1d88:	d0 f7       	brcc	.-12     	; 0x1d7e <isspace+0x2>
    1d8a:	08 95       	ret

00001d8c <strchr_P>:
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	05 90       	lpm	r0, Z+
    1d90:	06 16       	cp	r0, r22
    1d92:	21 f0       	breq	.+8      	; 0x1d9c <strchr_P+0x10>
    1d94:	00 20       	and	r0, r0
    1d96:	d9 f7       	brne	.-10     	; 0x1d8e <strchr_P+0x2>
    1d98:	c0 01       	movw	r24, r0
    1d9a:	08 95       	ret
    1d9c:	31 97       	sbiw	r30, 0x01	; 1
    1d9e:	cf 01       	movw	r24, r30
    1da0:	08 95       	ret

00001da2 <memcpy>:
    1da2:	fb 01       	movw	r30, r22
    1da4:	dc 01       	movw	r26, r24
    1da6:	02 c0       	rjmp	.+4      	; 0x1dac <memcpy+0xa>
    1da8:	01 90       	ld	r0, Z+
    1daa:	0d 92       	st	X+, r0
    1dac:	41 50       	subi	r20, 0x01	; 1
    1dae:	50 40       	sbci	r21, 0x00	; 0
    1db0:	d8 f7       	brcc	.-10     	; 0x1da8 <memcpy+0x6>
    1db2:	08 95       	ret

00001db4 <fgetc>:
    1db4:	cf 93       	push	r28
    1db6:	df 93       	push	r29
    1db8:	ec 01       	movw	r28, r24
    1dba:	2b 81       	ldd	r18, Y+3	; 0x03
    1dbc:	20 ff       	sbrs	r18, 0
    1dbe:	33 c0       	rjmp	.+102    	; 0x1e26 <fgetc+0x72>
    1dc0:	26 ff       	sbrs	r18, 6
    1dc2:	0a c0       	rjmp	.+20     	; 0x1dd8 <fgetc+0x24>
    1dc4:	2f 7b       	andi	r18, 0xBF	; 191
    1dc6:	2b 83       	std	Y+3, r18	; 0x03
    1dc8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dca:	9f 81       	ldd	r25, Y+7	; 0x07
    1dcc:	01 96       	adiw	r24, 0x01	; 1
    1dce:	9f 83       	std	Y+7, r25	; 0x07
    1dd0:	8e 83       	std	Y+6, r24	; 0x06
    1dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd4:	90 e0       	ldi	r25, 0x00	; 0
    1dd6:	29 c0       	rjmp	.+82     	; 0x1e2a <fgetc+0x76>
    1dd8:	22 ff       	sbrs	r18, 2
    1dda:	0f c0       	rjmp	.+30     	; 0x1dfa <fgetc+0x46>
    1ddc:	e8 81       	ld	r30, Y
    1dde:	f9 81       	ldd	r31, Y+1	; 0x01
    1de0:	80 81       	ld	r24, Z
    1de2:	08 2e       	mov	r0, r24
    1de4:	00 0c       	add	r0, r0
    1de6:	99 0b       	sbc	r25, r25
    1de8:	00 97       	sbiw	r24, 0x00	; 0
    1dea:	19 f4       	brne	.+6      	; 0x1df2 <fgetc+0x3e>
    1dec:	20 62       	ori	r18, 0x20	; 32
    1dee:	2b 83       	std	Y+3, r18	; 0x03
    1df0:	1a c0       	rjmp	.+52     	; 0x1e26 <fgetc+0x72>
    1df2:	31 96       	adiw	r30, 0x01	; 1
    1df4:	f9 83       	std	Y+1, r31	; 0x01
    1df6:	e8 83       	st	Y, r30
    1df8:	0e c0       	rjmp	.+28     	; 0x1e16 <fgetc+0x62>
    1dfa:	ea 85       	ldd	r30, Y+10	; 0x0a
    1dfc:	fb 85       	ldd	r31, Y+11	; 0x0b
    1dfe:	09 95       	icall
    1e00:	97 ff       	sbrs	r25, 7
    1e02:	09 c0       	rjmp	.+18     	; 0x1e16 <fgetc+0x62>
    1e04:	2b 81       	ldd	r18, Y+3	; 0x03
    1e06:	01 96       	adiw	r24, 0x01	; 1
    1e08:	11 f0       	breq	.+4      	; 0x1e0e <fgetc+0x5a>
    1e0a:	80 e2       	ldi	r24, 0x20	; 32
    1e0c:	01 c0       	rjmp	.+2      	; 0x1e10 <fgetc+0x5c>
    1e0e:	80 e1       	ldi	r24, 0x10	; 16
    1e10:	82 2b       	or	r24, r18
    1e12:	8b 83       	std	Y+3, r24	; 0x03
    1e14:	08 c0       	rjmp	.+16     	; 0x1e26 <fgetc+0x72>
    1e16:	2e 81       	ldd	r18, Y+6	; 0x06
    1e18:	3f 81       	ldd	r19, Y+7	; 0x07
    1e1a:	2f 5f       	subi	r18, 0xFF	; 255
    1e1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e1e:	3f 83       	std	Y+7, r19	; 0x07
    1e20:	2e 83       	std	Y+6, r18	; 0x06
    1e22:	99 27       	eor	r25, r25
    1e24:	02 c0       	rjmp	.+4      	; 0x1e2a <fgetc+0x76>
    1e26:	8f ef       	ldi	r24, 0xFF	; 255
    1e28:	9f ef       	ldi	r25, 0xFF	; 255
    1e2a:	df 91       	pop	r29
    1e2c:	cf 91       	pop	r28
    1e2e:	08 95       	ret

00001e30 <fputc>:
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	df 93       	push	r29
    1e38:	fb 01       	movw	r30, r22
    1e3a:	23 81       	ldd	r18, Z+3	; 0x03
    1e3c:	21 fd       	sbrc	r18, 1
    1e3e:	03 c0       	rjmp	.+6      	; 0x1e46 <fputc+0x16>
    1e40:	8f ef       	ldi	r24, 0xFF	; 255
    1e42:	9f ef       	ldi	r25, 0xFF	; 255
    1e44:	2c c0       	rjmp	.+88     	; 0x1e9e <fputc+0x6e>
    1e46:	22 ff       	sbrs	r18, 2
    1e48:	16 c0       	rjmp	.+44     	; 0x1e76 <fputc+0x46>
    1e4a:	46 81       	ldd	r20, Z+6	; 0x06
    1e4c:	57 81       	ldd	r21, Z+7	; 0x07
    1e4e:	24 81       	ldd	r18, Z+4	; 0x04
    1e50:	35 81       	ldd	r19, Z+5	; 0x05
    1e52:	42 17       	cp	r20, r18
    1e54:	53 07       	cpc	r21, r19
    1e56:	44 f4       	brge	.+16     	; 0x1e68 <fputc+0x38>
    1e58:	a0 81       	ld	r26, Z
    1e5a:	b1 81       	ldd	r27, Z+1	; 0x01
    1e5c:	9d 01       	movw	r18, r26
    1e5e:	2f 5f       	subi	r18, 0xFF	; 255
    1e60:	3f 4f       	sbci	r19, 0xFF	; 255
    1e62:	31 83       	std	Z+1, r19	; 0x01
    1e64:	20 83       	st	Z, r18
    1e66:	8c 93       	st	X, r24
    1e68:	26 81       	ldd	r18, Z+6	; 0x06
    1e6a:	37 81       	ldd	r19, Z+7	; 0x07
    1e6c:	2f 5f       	subi	r18, 0xFF	; 255
    1e6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e70:	37 83       	std	Z+7, r19	; 0x07
    1e72:	26 83       	std	Z+6, r18	; 0x06
    1e74:	14 c0       	rjmp	.+40     	; 0x1e9e <fputc+0x6e>
    1e76:	8b 01       	movw	r16, r22
    1e78:	ec 01       	movw	r28, r24
    1e7a:	fb 01       	movw	r30, r22
    1e7c:	00 84       	ldd	r0, Z+8	; 0x08
    1e7e:	f1 85       	ldd	r31, Z+9	; 0x09
    1e80:	e0 2d       	mov	r30, r0
    1e82:	09 95       	icall
    1e84:	89 2b       	or	r24, r25
    1e86:	e1 f6       	brne	.-72     	; 0x1e40 <fputc+0x10>
    1e88:	d8 01       	movw	r26, r16
    1e8a:	16 96       	adiw	r26, 0x06	; 6
    1e8c:	8d 91       	ld	r24, X+
    1e8e:	9c 91       	ld	r25, X
    1e90:	17 97       	sbiw	r26, 0x07	; 7
    1e92:	01 96       	adiw	r24, 0x01	; 1
    1e94:	17 96       	adiw	r26, 0x07	; 7
    1e96:	9c 93       	st	X, r25
    1e98:	8e 93       	st	-X, r24
    1e9a:	16 97       	sbiw	r26, 0x06	; 6
    1e9c:	ce 01       	movw	r24, r28
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	1f 91       	pop	r17
    1ea4:	0f 91       	pop	r16
    1ea6:	08 95       	ret

00001ea8 <ungetc>:
    1ea8:	fb 01       	movw	r30, r22
    1eaa:	23 81       	ldd	r18, Z+3	; 0x03
    1eac:	20 ff       	sbrs	r18, 0
    1eae:	12 c0       	rjmp	.+36     	; 0x1ed4 <ungetc+0x2c>
    1eb0:	26 fd       	sbrc	r18, 6
    1eb2:	10 c0       	rjmp	.+32     	; 0x1ed4 <ungetc+0x2c>
    1eb4:	8f 3f       	cpi	r24, 0xFF	; 255
    1eb6:	3f ef       	ldi	r19, 0xFF	; 255
    1eb8:	93 07       	cpc	r25, r19
    1eba:	61 f0       	breq	.+24     	; 0x1ed4 <ungetc+0x2c>
    1ebc:	82 83       	std	Z+2, r24	; 0x02
    1ebe:	2f 7d       	andi	r18, 0xDF	; 223
    1ec0:	20 64       	ori	r18, 0x40	; 64
    1ec2:	23 83       	std	Z+3, r18	; 0x03
    1ec4:	26 81       	ldd	r18, Z+6	; 0x06
    1ec6:	37 81       	ldd	r19, Z+7	; 0x07
    1ec8:	21 50       	subi	r18, 0x01	; 1
    1eca:	31 09       	sbc	r19, r1
    1ecc:	37 83       	std	Z+7, r19	; 0x07
    1ece:	26 83       	std	Z+6, r18	; 0x06
    1ed0:	99 27       	eor	r25, r25
    1ed2:	08 95       	ret
    1ed4:	8f ef       	ldi	r24, 0xFF	; 255
    1ed6:	9f ef       	ldi	r25, 0xFF	; 255
    1ed8:	08 95       	ret

00001eda <__ultoa_invert>:
    1eda:	fa 01       	movw	r30, r20
    1edc:	aa 27       	eor	r26, r26
    1ede:	28 30       	cpi	r18, 0x08	; 8
    1ee0:	51 f1       	breq	.+84     	; 0x1f36 <__ultoa_invert+0x5c>
    1ee2:	20 31       	cpi	r18, 0x10	; 16
    1ee4:	81 f1       	breq	.+96     	; 0x1f46 <__ultoa_invert+0x6c>
    1ee6:	e8 94       	clt
    1ee8:	6f 93       	push	r22
    1eea:	6e 7f       	andi	r22, 0xFE	; 254
    1eec:	6e 5f       	subi	r22, 0xFE	; 254
    1eee:	7f 4f       	sbci	r23, 0xFF	; 255
    1ef0:	8f 4f       	sbci	r24, 0xFF	; 255
    1ef2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ef4:	af 4f       	sbci	r26, 0xFF	; 255
    1ef6:	b1 e0       	ldi	r27, 0x01	; 1
    1ef8:	3e d0       	rcall	.+124    	; 0x1f76 <__ultoa_invert+0x9c>
    1efa:	b4 e0       	ldi	r27, 0x04	; 4
    1efc:	3c d0       	rcall	.+120    	; 0x1f76 <__ultoa_invert+0x9c>
    1efe:	67 0f       	add	r22, r23
    1f00:	78 1f       	adc	r23, r24
    1f02:	89 1f       	adc	r24, r25
    1f04:	9a 1f       	adc	r25, r26
    1f06:	a1 1d       	adc	r26, r1
    1f08:	68 0f       	add	r22, r24
    1f0a:	79 1f       	adc	r23, r25
    1f0c:	8a 1f       	adc	r24, r26
    1f0e:	91 1d       	adc	r25, r1
    1f10:	a1 1d       	adc	r26, r1
    1f12:	6a 0f       	add	r22, r26
    1f14:	71 1d       	adc	r23, r1
    1f16:	81 1d       	adc	r24, r1
    1f18:	91 1d       	adc	r25, r1
    1f1a:	a1 1d       	adc	r26, r1
    1f1c:	20 d0       	rcall	.+64     	; 0x1f5e <__ultoa_invert+0x84>
    1f1e:	09 f4       	brne	.+2      	; 0x1f22 <__ultoa_invert+0x48>
    1f20:	68 94       	set
    1f22:	3f 91       	pop	r19
    1f24:	2a e0       	ldi	r18, 0x0A	; 10
    1f26:	26 9f       	mul	r18, r22
    1f28:	11 24       	eor	r1, r1
    1f2a:	30 19       	sub	r19, r0
    1f2c:	30 5d       	subi	r19, 0xD0	; 208
    1f2e:	31 93       	st	Z+, r19
    1f30:	de f6       	brtc	.-74     	; 0x1ee8 <__ultoa_invert+0xe>
    1f32:	cf 01       	movw	r24, r30
    1f34:	08 95       	ret
    1f36:	46 2f       	mov	r20, r22
    1f38:	47 70       	andi	r20, 0x07	; 7
    1f3a:	40 5d       	subi	r20, 0xD0	; 208
    1f3c:	41 93       	st	Z+, r20
    1f3e:	b3 e0       	ldi	r27, 0x03	; 3
    1f40:	0f d0       	rcall	.+30     	; 0x1f60 <__ultoa_invert+0x86>
    1f42:	c9 f7       	brne	.-14     	; 0x1f36 <__ultoa_invert+0x5c>
    1f44:	f6 cf       	rjmp	.-20     	; 0x1f32 <__ultoa_invert+0x58>
    1f46:	46 2f       	mov	r20, r22
    1f48:	4f 70       	andi	r20, 0x0F	; 15
    1f4a:	40 5d       	subi	r20, 0xD0	; 208
    1f4c:	4a 33       	cpi	r20, 0x3A	; 58
    1f4e:	18 f0       	brcs	.+6      	; 0x1f56 <__ultoa_invert+0x7c>
    1f50:	49 5d       	subi	r20, 0xD9	; 217
    1f52:	31 fd       	sbrc	r19, 1
    1f54:	40 52       	subi	r20, 0x20	; 32
    1f56:	41 93       	st	Z+, r20
    1f58:	02 d0       	rcall	.+4      	; 0x1f5e <__ultoa_invert+0x84>
    1f5a:	a9 f7       	brne	.-22     	; 0x1f46 <__ultoa_invert+0x6c>
    1f5c:	ea cf       	rjmp	.-44     	; 0x1f32 <__ultoa_invert+0x58>
    1f5e:	b4 e0       	ldi	r27, 0x04	; 4
    1f60:	a6 95       	lsr	r26
    1f62:	97 95       	ror	r25
    1f64:	87 95       	ror	r24
    1f66:	77 95       	ror	r23
    1f68:	67 95       	ror	r22
    1f6a:	ba 95       	dec	r27
    1f6c:	c9 f7       	brne	.-14     	; 0x1f60 <__ultoa_invert+0x86>
    1f6e:	00 97       	sbiw	r24, 0x00	; 0
    1f70:	61 05       	cpc	r22, r1
    1f72:	71 05       	cpc	r23, r1
    1f74:	08 95       	ret
    1f76:	9b 01       	movw	r18, r22
    1f78:	ac 01       	movw	r20, r24
    1f7a:	0a 2e       	mov	r0, r26
    1f7c:	06 94       	lsr	r0
    1f7e:	57 95       	ror	r21
    1f80:	47 95       	ror	r20
    1f82:	37 95       	ror	r19
    1f84:	27 95       	ror	r18
    1f86:	ba 95       	dec	r27
    1f88:	c9 f7       	brne	.-14     	; 0x1f7c <__ultoa_invert+0xa2>
    1f8a:	62 0f       	add	r22, r18
    1f8c:	73 1f       	adc	r23, r19
    1f8e:	84 1f       	adc	r24, r20
    1f90:	95 1f       	adc	r25, r21
    1f92:	a0 1d       	adc	r26, r0
    1f94:	08 95       	ret

00001f96 <__ctype_isfalse>:
    1f96:	99 27       	eor	r25, r25
    1f98:	88 27       	eor	r24, r24

00001f9a <__ctype_istrue>:
    1f9a:	08 95       	ret

00001f9c <_exit>:
    1f9c:	f8 94       	cli

00001f9e <__stop_program>:
    1f9e:	ff cf       	rjmp	.-2      	; 0x1f9e <__stop_program>
