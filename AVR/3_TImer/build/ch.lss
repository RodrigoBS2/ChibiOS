
build/ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800100  00001eb8  00001f4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001eb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000216  00800174  00800174  00001fc0  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00001fc0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001fd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000768  00000000  00000000  00002014  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014f3d  00000000  00000000  0000277c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000434c  00000000  00000000  000176b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000579e  00000000  00000000  0001ba05  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001530  00000000  00000000  000211a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002037  00000000  00000000  000226d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006e27  00000000  00000000  0002470b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009c0  00000000  00000000  0002b532  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8e c3       	rjmp	.+1820   	; 0x74a <__vector_11>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	45 c0       	rjmp	.+138    	; 0xc4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	c8 c3       	rjmp	.+1936   	; 0x7da <__vector_18>
      4a:	00 00       	nop
      4c:	04 c4       	rjmp	.+2056   	; 0x856 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2314>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2449>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e8 eb       	ldi	r30, 0xB8	; 184
      9e:	fe e1       	ldi	r31, 0x1E	; 30
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	a4 37       	cpi	r26, 0x74	; 116
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	23 e0       	ldi	r18, 0x03	; 3
      ae:	a4 e7       	ldi	r26, 0x74	; 116
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	aa 38       	cpi	r26, 0x8A	; 138
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <main>
      c0:	0c 94 5a 0f 	jmp	0x1eb4	; 0x1eb4 <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	32 d3       	rcall	.+1636   	; 0x72c <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	84 e1       	ldi	r24, 0x14	; 20
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	30 d3       	rcall	.+1632   	; 0x72e <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	ae d2       	rcall	.+1372   	; 0x62c <sdInit>
      d0:	29 d3       	rcall	.+1618   	; 0x724 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	65 c3       	rjmp	.+1738   	; 0x7a0 <st_lld_init>

000000d6 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t) TCNT1;
      d6:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
      da:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
      de:	08 95       	ret

000000e0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      e0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      e4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

  /* Reset pending. */
  TIFR_REG = _BV(OCF1A);
      e8:	82 e0       	ldi	r24, 0x02	; 2
      ea:	86 bb       	out	0x16, r24	; 22

  /* Enable interrupt. */
  TIMSK_REG = _BV(OCIE1A);
      ec:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
      f0:	08 95       	ret

000000f2 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  TIMSK_REG = 0;
      f2:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
      f6:	08 95       	ret

000000f8 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
      f8:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
      fc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     100:	08 95       	ret

00000102 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
     102:	af 92       	push	r10
     104:	bf 92       	push	r11
     106:	cf 92       	push	r12
     108:	df 92       	push	r13
     10a:	ef 92       	push	r14
     10c:	ff 92       	push	r15
     10e:	0f 93       	push	r16
     110:	1f 93       	push	r17
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	ec 01       	movw	r28, r24
     118:	6b 01       	movw	r12, r22
     11a:	8a 01       	movw	r16, r20
     11c:	8c 81       	ldd	r24, Y+4	; 0x04
     11e:	9d 81       	ldd	r25, Y+5	; 0x05
     120:	84 17       	cp	r24, r20
     122:	95 07       	cpc	r25, r21
     124:	10 f4       	brcc	.+4      	; 0x12a <iq_read+0x28>
     126:	0c 81       	ldd	r16, Y+4	; 0x04
     128:	1d 81       	ldd	r17, Y+5	; 0x05
     12a:	6c 85       	ldd	r22, Y+12	; 0x0c
     12c:	7d 85       	ldd	r23, Y+13	; 0x0d
     12e:	e8 84       	ldd	r14, Y+8	; 0x08
     130:	f9 84       	ldd	r15, Y+9	; 0x09
     132:	e6 1a       	sub	r14, r22
     134:	f7 0a       	sbc	r15, r23
     136:	0e 15       	cp	r16, r14
     138:	1f 05       	cpc	r17, r15
     13a:	98 f1       	brcs	.+102    	; 0x1a2 <iq_read+0xa0>
     13c:	e0 16       	cp	r14, r16
     13e:	f1 06       	cpc	r15, r17
     140:	d0 f0       	brcs	.+52     	; 0x176 <iq_read+0x74>
     142:	a8 01       	movw	r20, r16
     144:	c6 01       	movw	r24, r12
     146:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     14a:	8e 81       	ldd	r24, Y+6	; 0x06
     14c:	9f 81       	ldd	r25, Y+7	; 0x07
     14e:	9d 87       	std	Y+13, r25	; 0x0d
     150:	8c 87       	std	Y+12, r24	; 0x0c
     152:	8c 81       	ldd	r24, Y+4	; 0x04
     154:	9d 81       	ldd	r25, Y+5	; 0x05
     156:	80 1b       	sub	r24, r16
     158:	91 0b       	sbc	r25, r17
     15a:	9d 83       	std	Y+5, r25	; 0x05
     15c:	8c 83       	std	Y+4, r24	; 0x04
     15e:	c8 01       	movw	r24, r16
     160:	df 91       	pop	r29
     162:	cf 91       	pop	r28
     164:	1f 91       	pop	r17
     166:	0f 91       	pop	r16
     168:	ff 90       	pop	r15
     16a:	ef 90       	pop	r14
     16c:	df 90       	pop	r13
     16e:	cf 90       	pop	r12
     170:	bf 90       	pop	r11
     172:	af 90       	pop	r10
     174:	08 95       	ret
     176:	a7 01       	movw	r20, r14
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     17e:	58 01       	movw	r10, r16
     180:	ae 18       	sub	r10, r14
     182:	bf 08       	sbc	r11, r15
     184:	6e 81       	ldd	r22, Y+6	; 0x06
     186:	7f 81       	ldd	r23, Y+7	; 0x07
     188:	a5 01       	movw	r20, r10
     18a:	c6 01       	movw	r24, r12
     18c:	8e 0d       	add	r24, r14
     18e:	9f 1d       	adc	r25, r15
     190:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     194:	8e 81       	ldd	r24, Y+6	; 0x06
     196:	9f 81       	ldd	r25, Y+7	; 0x07
     198:	a8 0e       	add	r10, r24
     19a:	b9 1e       	adc	r11, r25
     19c:	bd 86       	std	Y+13, r11	; 0x0d
     19e:	ac 86       	std	Y+12, r10	; 0x0c
     1a0:	d8 cf       	rjmp	.-80     	; 0x152 <iq_read+0x50>
     1a2:	a8 01       	movw	r20, r16
     1a4:	c6 01       	movw	r24, r12
     1a6:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     1aa:	8c 85       	ldd	r24, Y+12	; 0x0c
     1ac:	9d 85       	ldd	r25, Y+13	; 0x0d
     1ae:	80 0f       	add	r24, r16
     1b0:	91 1f       	adc	r25, r17
     1b2:	9d 87       	std	Y+13, r25	; 0x0d
     1b4:	8c 87       	std	Y+12, r24	; 0x0c
     1b6:	cd cf       	rjmp	.-102    	; 0x152 <iq_read+0x50>

000001b8 <oq_write>:
     1b8:	af 92       	push	r10
     1ba:	bf 92       	push	r11
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
     1ce:	6b 01       	movw	r12, r22
     1d0:	8a 01       	movw	r16, r20
     1d2:	8c 81       	ldd	r24, Y+4	; 0x04
     1d4:	9d 81       	ldd	r25, Y+5	; 0x05
     1d6:	84 17       	cp	r24, r20
     1d8:	95 07       	cpc	r25, r21
     1da:	10 f4       	brcc	.+4      	; 0x1e0 <oq_write+0x28>
     1dc:	0c 81       	ldd	r16, Y+4	; 0x04
     1de:	1d 81       	ldd	r17, Y+5	; 0x05
     1e0:	8a 85       	ldd	r24, Y+10	; 0x0a
     1e2:	9b 85       	ldd	r25, Y+11	; 0x0b
     1e4:	e8 84       	ldd	r14, Y+8	; 0x08
     1e6:	f9 84       	ldd	r15, Y+9	; 0x09
     1e8:	e8 1a       	sub	r14, r24
     1ea:	f9 0a       	sbc	r15, r25
     1ec:	0e 15       	cp	r16, r14
     1ee:	1f 05       	cpc	r17, r15
     1f0:	98 f1       	brcs	.+102    	; 0x258 <oq_write+0xa0>
     1f2:	e0 16       	cp	r14, r16
     1f4:	f1 06       	cpc	r15, r17
     1f6:	d0 f0       	brcs	.+52     	; 0x22c <oq_write+0x74>
     1f8:	a8 01       	movw	r20, r16
     1fa:	b6 01       	movw	r22, r12
     1fc:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     200:	8e 81       	ldd	r24, Y+6	; 0x06
     202:	9f 81       	ldd	r25, Y+7	; 0x07
     204:	9b 87       	std	Y+11, r25	; 0x0b
     206:	8a 87       	std	Y+10, r24	; 0x0a
     208:	8c 81       	ldd	r24, Y+4	; 0x04
     20a:	9d 81       	ldd	r25, Y+5	; 0x05
     20c:	80 1b       	sub	r24, r16
     20e:	91 0b       	sbc	r25, r17
     210:	9d 83       	std	Y+5, r25	; 0x05
     212:	8c 83       	std	Y+4, r24	; 0x04
     214:	c8 01       	movw	r24, r16
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	1f 91       	pop	r17
     21c:	0f 91       	pop	r16
     21e:	ff 90       	pop	r15
     220:	ef 90       	pop	r14
     222:	df 90       	pop	r13
     224:	cf 90       	pop	r12
     226:	bf 90       	pop	r11
     228:	af 90       	pop	r10
     22a:	08 95       	ret
     22c:	a7 01       	movw	r20, r14
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     234:	58 01       	movw	r10, r16
     236:	ae 18       	sub	r10, r14
     238:	bf 08       	sbc	r11, r15
     23a:	b6 01       	movw	r22, r12
     23c:	6e 0d       	add	r22, r14
     23e:	7f 1d       	adc	r23, r15
     240:	a5 01       	movw	r20, r10
     242:	8e 81       	ldd	r24, Y+6	; 0x06
     244:	9f 81       	ldd	r25, Y+7	; 0x07
     246:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f 81       	ldd	r25, Y+7	; 0x07
     24e:	a8 0e       	add	r10, r24
     250:	b9 1e       	adc	r11, r25
     252:	bb 86       	std	Y+11, r11	; 0x0b
     254:	aa 86       	std	Y+10, r10	; 0x0a
     256:	d8 cf       	rjmp	.-80     	; 0x208 <oq_write+0x50>
     258:	a8 01       	movw	r20, r16
     25a:	b6 01       	movw	r22, r12
     25c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <memcpy>
     260:	8a 85       	ldd	r24, Y+10	; 0x0a
     262:	9b 85       	ldd	r25, Y+11	; 0x0b
     264:	80 0f       	add	r24, r16
     266:	91 1f       	adc	r25, r17
     268:	9b 87       	std	Y+11, r25	; 0x0b
     26a:	8a 87       	std	Y+10, r24	; 0x0a
     26c:	cd cf       	rjmp	.-102    	; 0x208 <oq_write+0x50>

0000026e <iqObjectInit>:
     26e:	af 92       	push	r10
     270:	bf 92       	push	r11
     272:	cf 92       	push	r12
     274:	df 92       	push	r13
     276:	ef 92       	push	r14
     278:	ff 92       	push	r15
     27a:	0f 93       	push	r16
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	ec 01       	movw	r28, r24
     284:	7b 01       	movw	r14, r22
     286:	6a 01       	movw	r12, r20
     288:	59 01       	movw	r10, r18
     28a:	0e 94 ff 09 	call	0x13fe	; 0x13fe <chThdQueueObjectInit>
     28e:	1d 82       	std	Y+5, r1	; 0x05
     290:	1c 82       	std	Y+4, r1	; 0x04
     292:	ff 82       	std	Y+7, r15	; 0x07
     294:	ee 82       	std	Y+6, r14	; 0x06
     296:	fd 86       	std	Y+13, r15	; 0x0d
     298:	ec 86       	std	Y+12, r14	; 0x0c
     29a:	fb 86       	std	Y+11, r15	; 0x0b
     29c:	ea 86       	std	Y+10, r14	; 0x0a
     29e:	ec 0c       	add	r14, r12
     2a0:	fd 1c       	adc	r15, r13
     2a2:	f9 86       	std	Y+9, r15	; 0x09
     2a4:	e8 86       	std	Y+8, r14	; 0x08
     2a6:	bf 86       	std	Y+15, r11	; 0x0f
     2a8:	ae 86       	std	Y+14, r10	; 0x0e
     2aa:	19 8b       	std	Y+17, r17	; 0x11
     2ac:	08 8b       	std	Y+16, r16	; 0x10
     2ae:	df 91       	pop	r29
     2b0:	cf 91       	pop	r28
     2b2:	1f 91       	pop	r17
     2b4:	0f 91       	pop	r16
     2b6:	ff 90       	pop	r15
     2b8:	ef 90       	pop	r14
     2ba:	df 90       	pop	r13
     2bc:	cf 90       	pop	r12
     2be:	bf 90       	pop	r11
     2c0:	af 90       	pop	r10
     2c2:	08 95       	ret

000002c4 <iqPutI>:
     2c4:	fc 01       	movw	r30, r24
     2c6:	a2 85       	ldd	r26, Z+10	; 0x0a
     2c8:	b3 85       	ldd	r27, Z+11	; 0x0b
     2ca:	84 85       	ldd	r24, Z+12	; 0x0c
     2cc:	95 85       	ldd	r25, Z+13	; 0x0d
     2ce:	a8 17       	cp	r26, r24
     2d0:	b9 07       	cpc	r27, r25
     2d2:	e9 f0       	breq	.+58     	; 0x30e <iqPutI+0x4a>
     2d4:	84 81       	ldd	r24, Z+4	; 0x04
     2d6:	95 81       	ldd	r25, Z+5	; 0x05
     2d8:	01 96       	adiw	r24, 0x01	; 1
     2da:	95 83       	std	Z+5, r25	; 0x05
     2dc:	84 83       	std	Z+4, r24	; 0x04
     2de:	cd 01       	movw	r24, r26
     2e0:	01 96       	adiw	r24, 0x01	; 1
     2e2:	93 87       	std	Z+11, r25	; 0x0b
     2e4:	82 87       	std	Z+10, r24	; 0x0a
     2e6:	6c 93       	st	X, r22
     2e8:	22 85       	ldd	r18, Z+10	; 0x0a
     2ea:	33 85       	ldd	r19, Z+11	; 0x0b
     2ec:	80 85       	ldd	r24, Z+8	; 0x08
     2ee:	91 85       	ldd	r25, Z+9	; 0x09
     2f0:	28 17       	cp	r18, r24
     2f2:	39 07       	cpc	r19, r25
     2f4:	20 f0       	brcs	.+8      	; 0x2fe <iqPutI+0x3a>
     2f6:	86 81       	ldd	r24, Z+6	; 0x06
     2f8:	97 81       	ldd	r25, Z+7	; 0x07
     2fa:	93 87       	std	Z+11, r25	; 0x0b
     2fc:	82 87       	std	Z+10, r24	; 0x0a
     2fe:	cf 01       	movw	r24, r30
     300:	60 e0       	ldi	r22, 0x00	; 0
     302:	70 e0       	ldi	r23, 0x00	; 0
     304:	0e 94 22 0a 	call	0x1444	; 0x1444 <chThdDequeueNextI>
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	08 95       	ret
     30e:	84 81       	ldd	r24, Z+4	; 0x04
     310:	95 81       	ldd	r25, Z+5	; 0x05
     312:	89 2b       	or	r24, r25
     314:	f9 f2       	breq	.-66     	; 0x2d4 <iqPutI+0x10>
     316:	8f ef       	ldi	r24, 0xFF	; 255
     318:	9f ef       	ldi	r25, 0xFF	; 255
     31a:	08 95       	ret

0000031c <iqGetTimeout>:
     31c:	0f 93       	push	r16
     31e:	1f 93       	push	r17
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	ec 01       	movw	r28, r24
     326:	8b 01       	movw	r16, r22
     328:	f8 94       	cli
     32a:	06 c0       	rjmp	.+12     	; 0x338 <iqGetTimeout+0x1c>
     32c:	b8 01       	movw	r22, r16
     32e:	ce 01       	movw	r24, r28
     330:	0e 94 05 0a 	call	0x140a	; 0x140a <chThdEnqueueTimeoutS>
     334:	97 fd       	sbrc	r25, 7
     336:	27 c0       	rjmp	.+78     	; 0x386 <iqGetTimeout+0x6a>
     338:	8c 81       	ldd	r24, Y+4	; 0x04
     33a:	9d 81       	ldd	r25, Y+5	; 0x05
     33c:	89 2b       	or	r24, r25
     33e:	b1 f3       	breq	.-20     	; 0x32c <iqGetTimeout+0x10>
     340:	8c 81       	ldd	r24, Y+4	; 0x04
     342:	9d 81       	ldd	r25, Y+5	; 0x05
     344:	01 97       	sbiw	r24, 0x01	; 1
     346:	9d 83       	std	Y+5, r25	; 0x05
     348:	8c 83       	std	Y+4, r24	; 0x04
     34a:	ec 85       	ldd	r30, Y+12	; 0x0c
     34c:	fd 85       	ldd	r31, Y+13	; 0x0d
     34e:	cf 01       	movw	r24, r30
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	9d 87       	std	Y+13, r25	; 0x0d
     354:	8c 87       	std	Y+12, r24	; 0x0c
     356:	10 81       	ld	r17, Z
     358:	28 85       	ldd	r18, Y+8	; 0x08
     35a:	39 85       	ldd	r19, Y+9	; 0x09
     35c:	82 17       	cp	r24, r18
     35e:	93 07       	cpc	r25, r19
     360:	20 f0       	brcs	.+8      	; 0x36a <iqGetTimeout+0x4e>
     362:	8e 81       	ldd	r24, Y+6	; 0x06
     364:	9f 81       	ldd	r25, Y+7	; 0x07
     366:	9d 87       	std	Y+13, r25	; 0x0d
     368:	8c 87       	std	Y+12, r24	; 0x0c
     36a:	ee 85       	ldd	r30, Y+14	; 0x0e
     36c:	ff 85       	ldd	r31, Y+15	; 0x0f
     36e:	30 97       	sbiw	r30, 0x00	; 0
     370:	11 f0       	breq	.+4      	; 0x376 <iqGetTimeout+0x5a>
     372:	ce 01       	movw	r24, r28
     374:	09 95       	icall
     376:	78 94       	sei
     378:	81 2f       	mov	r24, r17
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	1f 91       	pop	r17
     382:	0f 91       	pop	r16
     384:	08 95       	ret
     386:	78 94       	sei
     388:	df 91       	pop	r29
     38a:	cf 91       	pop	r28
     38c:	1f 91       	pop	r17
     38e:	0f 91       	pop	r16
     390:	08 95       	ret

00000392 <iqReadTimeout>:
     392:	6f 92       	push	r6
     394:	7f 92       	push	r7
     396:	8f 92       	push	r8
     398:	9f 92       	push	r9
     39a:	af 92       	push	r10
     39c:	bf 92       	push	r11
     39e:	cf 92       	push	r12
     3a0:	df 92       	push	r13
     3a2:	ef 92       	push	r14
     3a4:	ff 92       	push	r15
     3a6:	0f 93       	push	r16
     3a8:	1f 93       	push	r17
     3aa:	cf 93       	push	r28
     3ac:	df 93       	push	r29
     3ae:	6c 01       	movw	r12, r24
     3b0:	7b 01       	movw	r14, r22
     3b2:	3a 01       	movw	r6, r20
     3b4:	49 01       	movw	r8, r18
     3b6:	fc 01       	movw	r30, r24
     3b8:	a6 84       	ldd	r10, Z+14	; 0x0e
     3ba:	b7 84       	ldd	r11, Z+15	; 0x0f
     3bc:	f8 94       	cli
     3be:	41 15       	cp	r20, r1
     3c0:	51 05       	cpc	r21, r1
     3c2:	b9 f0       	breq	.+46     	; 0x3f2 <iqReadTimeout+0x60>
     3c4:	8a 01       	movw	r16, r20
     3c6:	a8 01       	movw	r20, r16
     3c8:	b7 01       	movw	r22, r14
     3ca:	c6 01       	movw	r24, r12
     3cc:	9a de       	rcall	.-716    	; 0x102 <iq_read>
     3ce:	ec 01       	movw	r28, r24
     3d0:	89 2b       	or	r24, r25
     3d2:	21 f1       	breq	.+72     	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
     3d4:	a1 14       	cp	r10, r1
     3d6:	b1 04       	cpc	r11, r1
     3d8:	19 f0       	breq	.+6      	; 0x3e0 <iqReadTimeout+0x4e>
     3da:	c6 01       	movw	r24, r12
     3dc:	f5 01       	movw	r30, r10
     3de:	09 95       	icall
     3e0:	78 94       	sei
     3e2:	0c 1b       	sub	r16, r28
     3e4:	1d 0b       	sbc	r17, r29
     3e6:	ec 0e       	add	r14, r28
     3e8:	fd 1e       	adc	r15, r29
     3ea:	f8 94       	cli
     3ec:	01 15       	cp	r16, r1
     3ee:	11 05       	cpc	r17, r1
     3f0:	51 f7       	brne	.-44     	; 0x3c6 <iqReadTimeout+0x34>
     3f2:	00 e0       	ldi	r16, 0x00	; 0
     3f4:	10 e0       	ldi	r17, 0x00	; 0
     3f6:	78 94       	sei
     3f8:	c3 01       	movw	r24, r6
     3fa:	80 1b       	sub	r24, r16
     3fc:	91 0b       	sbc	r25, r17
     3fe:	df 91       	pop	r29
     400:	cf 91       	pop	r28
     402:	1f 91       	pop	r17
     404:	0f 91       	pop	r16
     406:	ff 90       	pop	r15
     408:	ef 90       	pop	r14
     40a:	df 90       	pop	r13
     40c:	cf 90       	pop	r12
     40e:	bf 90       	pop	r11
     410:	af 90       	pop	r10
     412:	9f 90       	pop	r9
     414:	8f 90       	pop	r8
     416:	7f 90       	pop	r7
     418:	6f 90       	pop	r6
     41a:	08 95       	ret
     41c:	b4 01       	movw	r22, r8
     41e:	c6 01       	movw	r24, r12
     420:	f4 d7       	rcall	.+4072   	; 0x140a <chThdEnqueueTimeoutS>
     422:	89 2b       	or	r24, r25
     424:	81 f2       	breq	.-96     	; 0x3c6 <iqReadTimeout+0x34>
     426:	e7 cf       	rjmp	.-50     	; 0x3f6 <iqReadTimeout+0x64>

00000428 <oqObjectInit>:
     428:	af 92       	push	r10
     42a:	bf 92       	push	r11
     42c:	cf 92       	push	r12
     42e:	df 92       	push	r13
     430:	ef 92       	push	r14
     432:	ff 92       	push	r15
     434:	0f 93       	push	r16
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
     43c:	ec 01       	movw	r28, r24
     43e:	5b 01       	movw	r10, r22
     440:	7a 01       	movw	r14, r20
     442:	69 01       	movw	r12, r18
     444:	dc d7       	rcall	.+4024   	; 0x13fe <chThdQueueObjectInit>
     446:	fd 82       	std	Y+5, r15	; 0x05
     448:	ec 82       	std	Y+4, r14	; 0x04
     44a:	bf 82       	std	Y+7, r11	; 0x07
     44c:	ae 82       	std	Y+6, r10	; 0x06
     44e:	bd 86       	std	Y+13, r11	; 0x0d
     450:	ac 86       	std	Y+12, r10	; 0x0c
     452:	bb 86       	std	Y+11, r11	; 0x0b
     454:	aa 86       	std	Y+10, r10	; 0x0a
     456:	ea 0c       	add	r14, r10
     458:	fb 1c       	adc	r15, r11
     45a:	f9 86       	std	Y+9, r15	; 0x09
     45c:	e8 86       	std	Y+8, r14	; 0x08
     45e:	df 86       	std	Y+15, r13	; 0x0f
     460:	ce 86       	std	Y+14, r12	; 0x0e
     462:	19 8b       	std	Y+17, r17	; 0x11
     464:	08 8b       	std	Y+16, r16	; 0x10
     466:	df 91       	pop	r29
     468:	cf 91       	pop	r28
     46a:	1f 91       	pop	r17
     46c:	0f 91       	pop	r16
     46e:	ff 90       	pop	r15
     470:	ef 90       	pop	r14
     472:	df 90       	pop	r13
     474:	cf 90       	pop	r12
     476:	bf 90       	pop	r11
     478:	af 90       	pop	r10
     47a:	08 95       	ret

0000047c <oqPutTimeout>:
     47c:	ff 92       	push	r15
     47e:	0f 93       	push	r16
     480:	1f 93       	push	r17
     482:	cf 93       	push	r28
     484:	df 93       	push	r29
     486:	ec 01       	movw	r28, r24
     488:	f6 2e       	mov	r15, r22
     48a:	8a 01       	movw	r16, r20
     48c:	f8 94       	cli
     48e:	05 c0       	rjmp	.+10     	; 0x49a <oqPutTimeout+0x1e>
     490:	b8 01       	movw	r22, r16
     492:	ce 01       	movw	r24, r28
     494:	ba d7       	rcall	.+3956   	; 0x140a <chThdEnqueueTimeoutS>
     496:	97 fd       	sbrc	r25, 7
     498:	2a c0       	rjmp	.+84     	; 0x4ee <oqPutTimeout+0x72>
     49a:	8c 81       	ldd	r24, Y+4	; 0x04
     49c:	9d 81       	ldd	r25, Y+5	; 0x05
     49e:	89 2b       	or	r24, r25
     4a0:	b9 f3       	breq	.-18     	; 0x490 <oqPutTimeout+0x14>
     4a2:	8c 81       	ldd	r24, Y+4	; 0x04
     4a4:	9d 81       	ldd	r25, Y+5	; 0x05
     4a6:	01 97       	sbiw	r24, 0x01	; 1
     4a8:	9d 83       	std	Y+5, r25	; 0x05
     4aa:	8c 83       	std	Y+4, r24	; 0x04
     4ac:	ea 85       	ldd	r30, Y+10	; 0x0a
     4ae:	fb 85       	ldd	r31, Y+11	; 0x0b
     4b0:	cf 01       	movw	r24, r30
     4b2:	01 96       	adiw	r24, 0x01	; 1
     4b4:	9b 87       	std	Y+11, r25	; 0x0b
     4b6:	8a 87       	std	Y+10, r24	; 0x0a
     4b8:	f0 82       	st	Z, r15
     4ba:	2a 85       	ldd	r18, Y+10	; 0x0a
     4bc:	3b 85       	ldd	r19, Y+11	; 0x0b
     4be:	88 85       	ldd	r24, Y+8	; 0x08
     4c0:	99 85       	ldd	r25, Y+9	; 0x09
     4c2:	28 17       	cp	r18, r24
     4c4:	39 07       	cpc	r19, r25
     4c6:	20 f0       	brcs	.+8      	; 0x4d0 <oqPutTimeout+0x54>
     4c8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ca:	9f 81       	ldd	r25, Y+7	; 0x07
     4cc:	9b 87       	std	Y+11, r25	; 0x0b
     4ce:	8a 87       	std	Y+10, r24	; 0x0a
     4d0:	ee 85       	ldd	r30, Y+14	; 0x0e
     4d2:	ff 85       	ldd	r31, Y+15	; 0x0f
     4d4:	30 97       	sbiw	r30, 0x00	; 0
     4d6:	11 f0       	breq	.+4      	; 0x4dc <oqPutTimeout+0x60>
     4d8:	ce 01       	movw	r24, r28
     4da:	09 95       	icall
     4dc:	78 94       	sei
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	df 91       	pop	r29
     4e4:	cf 91       	pop	r28
     4e6:	1f 91       	pop	r17
     4e8:	0f 91       	pop	r16
     4ea:	ff 90       	pop	r15
     4ec:	08 95       	ret
     4ee:	78 94       	sei
     4f0:	df 91       	pop	r29
     4f2:	cf 91       	pop	r28
     4f4:	1f 91       	pop	r17
     4f6:	0f 91       	pop	r16
     4f8:	ff 90       	pop	r15
     4fa:	08 95       	ret

000004fc <oqGetI>:
     4fc:	cf 93       	push	r28
     4fe:	fc 01       	movw	r30, r24
     500:	a4 85       	ldd	r26, Z+12	; 0x0c
     502:	b5 85       	ldd	r27, Z+13	; 0x0d
     504:	82 85       	ldd	r24, Z+10	; 0x0a
     506:	93 85       	ldd	r25, Z+11	; 0x0b
     508:	8a 17       	cp	r24, r26
     50a:	9b 07       	cpc	r25, r27
     50c:	e1 f0       	breq	.+56     	; 0x546 <oqGetI+0x4a>
     50e:	84 81       	ldd	r24, Z+4	; 0x04
     510:	95 81       	ldd	r25, Z+5	; 0x05
     512:	01 96       	adiw	r24, 0x01	; 1
     514:	95 83       	std	Z+5, r25	; 0x05
     516:	84 83       	std	Z+4, r24	; 0x04
     518:	cd 01       	movw	r24, r26
     51a:	01 96       	adiw	r24, 0x01	; 1
     51c:	95 87       	std	Z+13, r25	; 0x0d
     51e:	84 87       	std	Z+12, r24	; 0x0c
     520:	cc 91       	ld	r28, X
     522:	20 85       	ldd	r18, Z+8	; 0x08
     524:	31 85       	ldd	r19, Z+9	; 0x09
     526:	82 17       	cp	r24, r18
     528:	93 07       	cpc	r25, r19
     52a:	40 f4       	brcc	.+16     	; 0x53c <oqGetI+0x40>
     52c:	cf 01       	movw	r24, r30
     52e:	60 e0       	ldi	r22, 0x00	; 0
     530:	70 e0       	ldi	r23, 0x00	; 0
     532:	88 d7       	rcall	.+3856   	; 0x1444 <chThdDequeueNextI>
     534:	8c 2f       	mov	r24, r28
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	cf 91       	pop	r28
     53a:	08 95       	ret
     53c:	86 81       	ldd	r24, Z+6	; 0x06
     53e:	97 81       	ldd	r25, Z+7	; 0x07
     540:	95 87       	std	Z+13, r25	; 0x0d
     542:	84 87       	std	Z+12, r24	; 0x0c
     544:	f3 cf       	rjmp	.-26     	; 0x52c <oqGetI+0x30>
     546:	84 81       	ldd	r24, Z+4	; 0x04
     548:	95 81       	ldd	r25, Z+5	; 0x05
     54a:	89 2b       	or	r24, r25
     54c:	01 f3       	breq	.-64     	; 0x50e <oqGetI+0x12>
     54e:	8f ef       	ldi	r24, 0xFF	; 255
     550:	9f ef       	ldi	r25, 0xFF	; 255
     552:	f2 cf       	rjmp	.-28     	; 0x538 <oqGetI+0x3c>

00000554 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     554:	6f 92       	push	r6
     556:	7f 92       	push	r7
     558:	8f 92       	push	r8
     55a:	9f 92       	push	r9
     55c:	af 92       	push	r10
     55e:	bf 92       	push	r11
     560:	cf 92       	push	r12
     562:	df 92       	push	r13
     564:	ef 92       	push	r14
     566:	ff 92       	push	r15
     568:	0f 93       	push	r16
     56a:	1f 93       	push	r17
     56c:	cf 93       	push	r28
     56e:	df 93       	push	r29
     570:	6c 01       	movw	r12, r24
     572:	7b 01       	movw	r14, r22
     574:	3a 01       	movw	r6, r20
     576:	49 01       	movw	r8, r18
  qnotify_t nfy = oqp->q_notify;
     578:	fc 01       	movw	r30, r24
     57a:	a6 84       	ldd	r10, Z+14	; 0x0e
     57c:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     57e:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     580:	41 15       	cp	r20, r1
     582:	51 05       	cpc	r21, r1
     584:	b9 f0       	breq	.+46     	; 0x5b4 <oqWriteTimeout+0x60>
     586:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     588:	a8 01       	movw	r20, r16
     58a:	b7 01       	movw	r22, r14
     58c:	c6 01       	movw	r24, r12
     58e:	14 de       	rcall	.-984    	; 0x1b8 <oq_write>
     590:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     592:	89 2b       	or	r24, r25
     594:	21 f1       	breq	.+72     	; 0x5de <oqWriteTimeout+0x8a>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     596:	a1 14       	cp	r10, r1
     598:	b1 04       	cpc	r11, r1
     59a:	19 f0       	breq	.+6      	; 0x5a2 <oqWriteTimeout+0x4e>
        nfy(oqp);
     59c:	c6 01       	movw	r24, r12
     59e:	f5 01       	movw	r30, r10
     5a0:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     5a2:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     5a4:	0c 1b       	sub	r16, r28
     5a6:	1d 0b       	sbc	r17, r29
      bp += done;
     5a8:	ec 0e       	add	r14, r28
     5aa:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     5ac:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     5ae:	01 15       	cp	r16, r1
     5b0:	11 05       	cpc	r17, r1
     5b2:	51 f7       	brne	.-44     	; 0x588 <oqWriteTimeout+0x34>
     5b4:	00 e0       	ldi	r16, 0x00	; 0
     5b6:	10 e0       	ldi	r17, 0x00	; 0
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     5b8:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     5ba:	c3 01       	movw	r24, r6
     5bc:	80 1b       	sub	r24, r16
     5be:	91 0b       	sbc	r25, r17
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	1f 91       	pop	r17
     5c6:	0f 91       	pop	r16
     5c8:	ff 90       	pop	r15
     5ca:	ef 90       	pop	r14
     5cc:	df 90       	pop	r13
     5ce:	cf 90       	pop	r12
     5d0:	bf 90       	pop	r11
     5d2:	af 90       	pop	r10
     5d4:	9f 90       	pop	r9
     5d6:	8f 90       	pop	r8
     5d8:	7f 90       	pop	r7
     5da:	6f 90       	pop	r6
     5dc:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     5de:	b4 01       	movw	r22, r8
     5e0:	c6 01       	movw	r24, r12
     5e2:	13 d7       	rcall	.+3622   	; 0x140a <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     5e4:	89 2b       	or	r24, r25
     5e6:	81 f2       	breq	.-96     	; 0x588 <oqWriteTimeout+0x34>
     5e8:	e7 cf       	rjmp	.-50     	; 0x5b8 <oqWriteTimeout+0x64>

000005ea <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     5ea:	05 96       	adiw	r24, 0x05	; 5
     5ec:	d2 ce       	rjmp	.-604    	; 0x392 <iqReadTimeout>

000005ee <_read>:
     5ee:	2f ef       	ldi	r18, 0xFF	; 255
     5f0:	3f ef       	ldi	r19, 0xFF	; 255
     5f2:	05 96       	adiw	r24, 0x05	; 5
     5f4:	ce ce       	rjmp	.-612    	; 0x392 <iqReadTimeout>

000005f6 <_writet>:
     5f6:	47 96       	adiw	r24, 0x17	; 23
     5f8:	ad cf       	rjmp	.-166    	; 0x554 <oqWriteTimeout>

000005fa <_write>:
     5fa:	2f ef       	ldi	r18, 0xFF	; 255
     5fc:	3f ef       	ldi	r19, 0xFF	; 255
     5fe:	47 96       	adiw	r24, 0x17	; 23
     600:	a9 cf       	rjmp	.-174    	; 0x554 <oqWriteTimeout>

00000602 <_gett>:
     602:	05 96       	adiw	r24, 0x05	; 5
     604:	8b ce       	rjmp	.-746    	; 0x31c <iqGetTimeout>

00000606 <_get>:
     606:	6f ef       	ldi	r22, 0xFF	; 255
     608:	7f ef       	ldi	r23, 0xFF	; 255
     60a:	05 96       	adiw	r24, 0x05	; 5
     60c:	87 ce       	rjmp	.-754    	; 0x31c <iqGetTimeout>

0000060e <_putt>:
     60e:	47 96       	adiw	r24, 0x17	; 23
     610:	35 cf       	rjmp	.-406    	; 0x47c <oqPutTimeout>

00000612 <_put>:
     612:	4f ef       	ldi	r20, 0xFF	; 255
     614:	5f ef       	ldi	r21, 0xFF	; 255
     616:	47 96       	adiw	r24, 0x17	; 23
     618:	31 cf       	rjmp	.-414    	; 0x47c <oqPutTimeout>

0000061a <_ctl>:
     61a:	61 30       	cpi	r22, 0x01	; 1
     61c:	71 05       	cpc	r23, r1
     61e:	19 f0       	breq	.+6      	; 0x626 <_ctl+0xc>
     620:	8c ee       	ldi	r24, 0xEC	; 236
     622:	9f ef       	ldi	r25, 0xFF	; 255
     624:	08 95       	ret
     626:	80 e0       	ldi	r24, 0x00	; 0
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	08 95       	ret

0000062c <sdInit>:
     62c:	4b c1       	rjmp	.+662    	; 0x8c4 <sd_lld_init>

0000062e <sdObjectInit>:
     62e:	cf 92       	push	r12
     630:	df 92       	push	r13
     632:	ef 92       	push	r14
     634:	ff 92       	push	r15
     636:	0f 93       	push	r16
     638:	1f 93       	push	r17
     63a:	cf 93       	push	r28
     63c:	df 93       	push	r29
     63e:	ec 01       	movw	r28, r24
     640:	6b 01       	movw	r12, r22
     642:	7a 01       	movw	r14, r20
     644:	20 e0       	ldi	r18, 0x00	; 0
     646:	31 e0       	ldi	r19, 0x01	; 1
     648:	fc 01       	movw	r30, r24
     64a:	21 93       	st	Z+, r18
     64c:	31 93       	st	Z+, r19
     64e:	cf 01       	movw	r24, r30
     650:	1a d7       	rcall	.+3636   	; 0x1486 <chEvtObjectInit>
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	8c 83       	std	Y+4, r24	; 0x04
     656:	be 01       	movw	r22, r28
     658:	67 5d       	subi	r22, 0xD7	; 215
     65a:	7f 4f       	sbci	r23, 0xFF	; 255
     65c:	8e 01       	movw	r16, r28
     65e:	96 01       	movw	r18, r12
     660:	40 e1       	ldi	r20, 0x10	; 16
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	ce 01       	movw	r24, r28
     666:	05 96       	adiw	r24, 0x05	; 5
     668:	02 de       	rcall	.-1020   	; 0x26e <iqObjectInit>
     66a:	be 01       	movw	r22, r28
     66c:	67 5c       	subi	r22, 0xC7	; 199
     66e:	7f 4f       	sbci	r23, 0xFF	; 255
     670:	97 01       	movw	r18, r14
     672:	40 e1       	ldi	r20, 0x10	; 16
     674:	50 e0       	ldi	r21, 0x00	; 0
     676:	ce 01       	movw	r24, r28
     678:	47 96       	adiw	r24, 0x17	; 23
     67a:	d6 de       	rcall	.-596    	; 0x428 <oqObjectInit>
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
     680:	1f 91       	pop	r17
     682:	0f 91       	pop	r16
     684:	ff 90       	pop	r15
     686:	ef 90       	pop	r14
     688:	df 90       	pop	r13
     68a:	cf 90       	pop	r12
     68c:	08 95       	ret

0000068e <sdStart>:
     68e:	cf 93       	push	r28
     690:	df 93       	push	r29
     692:	ec 01       	movw	r28, r24
     694:	f8 94       	cli
     696:	1d d1       	rcall	.+570    	; 0x8d2 <sd_lld_start>
     698:	82 e0       	ldi	r24, 0x02	; 2
     69a:	8c 83       	std	Y+4, r24	; 0x04
     69c:	78 94       	sei
     69e:	80 e0       	ldi	r24, 0x00	; 0
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	df 91       	pop	r29
     6a4:	cf 91       	pop	r28
     6a6:	08 95       	ret

000006a8 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     6a8:	1f 93       	push	r17
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	ec 01       	movw	r28, r24
     6b0:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     6b2:	89 85       	ldd	r24, Y+9	; 0x09
     6b4:	9a 85       	ldd	r25, Y+10	; 0x0a
     6b6:	89 2b       	or	r24, r25
     6b8:	51 f0       	breq	.+20     	; 0x6ce <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     6ba:	61 2f       	mov	r22, r17
     6bc:	ce 01       	movw	r24, r28
     6be:	05 96       	adiw	r24, 0x05	; 5
     6c0:	01 de       	rcall	.-1022   	; 0x2c4 <iqPutI>
     6c2:	97 fd       	sbrc	r25, 7
     6c4:	0e c0       	rjmp	.+28     	; 0x6e2 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     6c6:	df 91       	pop	r29
     6c8:	cf 91       	pop	r28
     6ca:	1f 91       	pop	r17
     6cc:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     6ce:	64 e0       	ldi	r22, 0x04	; 4
     6d0:	ce 01       	movw	r24, r28
     6d2:	02 96       	adiw	r24, 0x02	; 2
     6d4:	f2 d6       	rcall	.+3556   	; 0x14ba <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     6d6:	61 2f       	mov	r22, r17
     6d8:	ce 01       	movw	r24, r28
     6da:	05 96       	adiw	r24, 0x05	; 5
     6dc:	f3 dd       	rcall	.-1050   	; 0x2c4 <iqPutI>
     6de:	97 ff       	sbrs	r25, 7
     6e0:	f2 cf       	rjmp	.-28     	; 0x6c6 <sdIncomingDataI+0x1e>
     6e2:	60 e0       	ldi	r22, 0x00	; 0
     6e4:	ce 01       	movw	r24, r28
     6e6:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     6e8:	df 91       	pop	r29
     6ea:	cf 91       	pop	r28
     6ec:	1f 91       	pop	r17
     6ee:	e5 c6       	rjmp	.+3530   	; 0x14ba <chEvtBroadcastFlagsI>

000006f0 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     6f0:	0f 93       	push	r16
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     6fa:	47 96       	adiw	r24, 0x17	; 23
     6fc:	ff de       	rcall	.-514    	; 0x4fc <oqGetI>
     6fe:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     700:	97 fd       	sbrc	r25, 7
     702:	06 c0       	rjmp	.+12     	; 0x710 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     704:	ce 01       	movw	r24, r28
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	08 95       	ret
     710:	68 e0       	ldi	r22, 0x08	; 8
     712:	c8 01       	movw	r24, r16
     714:	02 96       	adiw	r24, 0x02	; 2
     716:	d1 d6       	rcall	.+3490   	; 0x14ba <chEvtBroadcastFlagsI>
     718:	ce 01       	movw	r24, r28
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	08 95       	ret

00000724 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     724:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     728:	1d ba       	out	0x1d, r1	; 29
     72a:	08 95       	ret

0000072c <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
     72c:	08 95       	ret

0000072e <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     72e:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     730:	80 81       	ld	r24, Z
     732:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     734:	81 81       	ldd	r24, Z+1	; 0x01
     736:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     738:	82 81       	ldd	r24, Z+2	; 0x02
     73a:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     73c:	83 81       	ldd	r24, Z+3	; 0x03
     73e:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     740:	84 81       	ldd	r24, Z+4	; 0x04
     742:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     744:	85 81       	ldd	r24, Z+5	; 0x05
     746:	8a b9       	out	0x0a, r24	; 10
     748:	08 95       	ret

0000074a <__vector_11>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for free running mode.
 */
OSAL_IRQ_HANDLER(TIMER1_COMPA_vect) {
     74a:	1f 92       	push	r1
     74c:	0f 92       	push	r0
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	0f 92       	push	r0
     752:	11 24       	eor	r1, r1
     754:	2f 93       	push	r18
     756:	3f 93       	push	r19
     758:	4f 93       	push	r20
     75a:	5f 93       	push	r21
     75c:	6f 93       	push	r22
     75e:	7f 93       	push	r23
     760:	8f 93       	push	r24
     762:	9f 93       	push	r25
     764:	af 93       	push	r26
     766:	bf 93       	push	r27
     768:	ef 93       	push	r30
     76a:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     772:	f5 d0       	rcall	.+490    	; 0x95e <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     774:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <__avr_in_isr>
     778:	60 d4       	rcall	.+2240   	; 0x103a <chSchIsPreemptionRequired>
     77a:	81 11       	cpse	r24, r1
     77c:	6e d4       	rcall	.+2268   	; 0x105a <chSchDoPreemption>
}
     77e:	ff 91       	pop	r31
     780:	ef 91       	pop	r30
     782:	bf 91       	pop	r27
     784:	af 91       	pop	r26
     786:	9f 91       	pop	r25
     788:	8f 91       	pop	r24
     78a:	7f 91       	pop	r23
     78c:	6f 91       	pop	r22
     78e:	5f 91       	pop	r21
     790:	4f 91       	pop	r20
     792:	3f 91       	pop	r19
     794:	2f 91       	pop	r18
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63
     79a:	0f 90       	pop	r0
     79c:	1f 90       	pop	r1
     79e:	18 95       	reti

000007a0 <st_lld_init>:
  /*
   * Periodic mode uses Timer 1 (16 bit).
   */

  /* CTC mode, no clock source. */
  TCCR1A     = 0;
     7a0:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
  TCCR1B     = _BV(WGM12);
     7a4:	e1 e8       	ldi	r30, 0x81	; 129
     7a6:	f0 e0       	ldi	r31, 0x00	; 0
     7a8:	88 e0       	ldi	r24, 0x08	; 8
     7aa:	80 83       	st	Z, r24

  /* Start disabled. */
  TCCR1C     = 0;
     7ac:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x7f8082>
  OCR1A      = 0;
     7b0:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     7b4:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
  TCNT1      = 0;
     7b8:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7f8085>
     7bc:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7f8084>
  TIFR_REG   = _BV(OCF1A);                              /* Reset pending.   */
     7c0:	82 e0       	ldi	r24, 0x02	; 2
     7c2:	86 bb       	out	0x16, r24	; 22
  TIMSK_REG  = 0;
     7c4:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
  TCCR1B     = PRESCALER;
     7c8:	85 e0       	ldi	r24, 0x05	; 5
     7ca:	80 83       	st	Z, r24
     7cc:	08 95       	ret

000007ce <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     7ce:	e1 ec       	ldi	r30, 0xC1	; 193
     7d0:	f0 e0       	ldi	r31, 0x00	; 0
     7d2:	80 81       	ld	r24, Z
     7d4:	80 62       	ori	r24, 0x20	; 32
     7d6:	80 83       	st	Z, r24
     7d8:	08 95       	ret

000007da <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     7da:	1f 92       	push	r1
     7dc:	0f 92       	push	r0
     7de:	0f b6       	in	r0, 0x3f	; 63
     7e0:	0f 92       	push	r0
     7e2:	11 24       	eor	r1, r1
     7e4:	2f 93       	push	r18
     7e6:	3f 93       	push	r19
     7e8:	4f 93       	push	r20
     7ea:	5f 93       	push	r21
     7ec:	6f 93       	push	r22
     7ee:	7f 93       	push	r23
     7f0:	8f 93       	push	r24
     7f2:	9f 93       	push	r25
     7f4:	af 93       	push	r26
     7f6:	bf 93       	push	r27
     7f8:	ef 93       	push	r30
     7fa:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7fc:	81 e0       	ldi	r24, 0x01	; 1
     7fe:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <__avr_in_isr>

  sra = UCSR0A;
     802:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     806:	98 2f       	mov	r25, r24
     808:	9c 71       	andi	r25, 0x1C	; 28
     80a:	41 f0       	breq	.+16     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     80c:	82 fd       	sbrc	r24, 2
     80e:	21 c0       	rjmp	.+66     	; 0x852 <__DATA_REGION_LENGTH__+0x52>
     810:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     812:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
     814:	60 64       	ori	r22, 0x40	; 64
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     816:	86 ef       	ldi	r24, 0xF6	; 246
     818:	92 e0       	ldi	r25, 0x02	; 2
     81a:	4f d6       	rcall	.+3230   	; 0x14ba <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     81c:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     820:	84 ef       	ldi	r24, 0xF4	; 244
     822:	92 e0       	ldi	r25, 0x02	; 2
     824:	41 df       	rcall	.-382    	; 0x6a8 <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     826:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <__avr_in_isr>
     82a:	07 d4       	rcall	.+2062   	; 0x103a <chSchIsPreemptionRequired>
     82c:	81 11       	cpse	r24, r1
     82e:	15 d4       	rcall	.+2090   	; 0x105a <chSchDoPreemption>
}
     830:	ff 91       	pop	r31
     832:	ef 91       	pop	r30
     834:	bf 91       	pop	r27
     836:	af 91       	pop	r26
     838:	9f 91       	pop	r25
     83a:	8f 91       	pop	r24
     83c:	7f 91       	pop	r23
     83e:	6f 91       	pop	r22
     840:	5f 91       	pop	r21
     842:	4f 91       	pop	r20
     844:	3f 91       	pop	r19
     846:	2f 91       	pop	r18
     848:	0f 90       	pop	r0
     84a:	0f be       	out	0x3f, r0	; 63
     84c:	0f 90       	pop	r0
     84e:	1f 90       	pop	r1
     850:	18 95       	reti
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     852:	60 e2       	ldi	r22, 0x20	; 32
     854:	de cf       	rjmp	.-68     	; 0x812 <__DATA_REGION_LENGTH__+0x12>

00000856 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     856:	1f 92       	push	r1
     858:	0f 92       	push	r0
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	0f 92       	push	r0
     85e:	11 24       	eor	r1, r1
     860:	2f 93       	push	r18
     862:	3f 93       	push	r19
     864:	4f 93       	push	r20
     866:	5f 93       	push	r21
     868:	6f 93       	push	r22
     86a:	7f 93       	push	r23
     86c:	8f 93       	push	r24
     86e:	9f 93       	push	r25
     870:	af 93       	push	r26
     872:	bf 93       	push	r27
     874:	ef 93       	push	r30
     876:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     87e:	84 ef       	ldi	r24, 0xF4	; 244
     880:	92 e0       	ldi	r25, 0x02	; 2
     882:	36 df       	rcall	.-404    	; 0x6f0 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     884:	97 fd       	sbrc	r25, 7
     886:	18 c0       	rjmp	.+48     	; 0x8b8 <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     888:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     88c:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <__avr_in_isr>
     890:	d4 d3       	rcall	.+1960   	; 0x103a <chSchIsPreemptionRequired>
     892:	81 11       	cpse	r24, r1
     894:	e2 d3       	rcall	.+1988   	; 0x105a <chSchDoPreemption>
}
     896:	ff 91       	pop	r31
     898:	ef 91       	pop	r30
     89a:	bf 91       	pop	r27
     89c:	af 91       	pop	r26
     89e:	9f 91       	pop	r25
     8a0:	8f 91       	pop	r24
     8a2:	7f 91       	pop	r23
     8a4:	6f 91       	pop	r22
     8a6:	5f 91       	pop	r21
     8a8:	4f 91       	pop	r20
     8aa:	3f 91       	pop	r19
     8ac:	2f 91       	pop	r18
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	0f 90       	pop	r0
     8b4:	1f 90       	pop	r1
     8b6:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     8b8:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8bc:	8f 7d       	andi	r24, 0xDF	; 223
     8be:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8c2:	e4 cf       	rjmp	.-56     	; 0x88c <__vector_19+0x36>

000008c4 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     8c4:	47 ee       	ldi	r20, 0xE7	; 231
     8c6:	53 e0       	ldi	r21, 0x03	; 3
     8c8:	60 e0       	ldi	r22, 0x00	; 0
     8ca:	70 e0       	ldi	r23, 0x00	; 0
     8cc:	84 ef       	ldi	r24, 0xF4	; 244
     8ce:	92 e0       	ldi	r25, 0x02	; 2
     8d0:	ae ce       	rjmp	.-676    	; 0x62e <sdObjectInit>

000008d2 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
     8d2:	61 15       	cp	r22, r1
     8d4:	71 05       	cpc	r23, r1
     8d6:	19 f1       	breq	.+70     	; 0x91e <__stack+0x1f>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
     8d8:	84 5f       	subi	r24, 0xF4	; 244
     8da:	92 40       	sbci	r25, 0x02	; 2
     8dc:	09 f0       	breq	.+2      	; 0x8e0 <sd_lld_start+0xe>
     8de:	08 95       	ret
 */
static void usart0_init(const SerialConfig *config) {

  uint8_t ucsr0c;

  UBRR0L = config->sc_brr;
     8e0:	fb 01       	movw	r30, r22
     8e2:	80 81       	ld	r24, Z
     8e4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
     8e8:	81 81       	ldd	r24, Z+1	; 0x01
     8ea:	8f 70       	andi	r24, 0x0F	; 15
     8ec:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UCSR0A = (1 << U2X0);
     8f0:	82 e0       	ldi	r24, 0x02	; 2
     8f2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
     8f6:	88 e9       	ldi	r24, 0x98	; 152
     8f8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  switch (config->sc_bits_per_char) {
     8fc:	82 81       	ldd	r24, Z+2	; 0x02
     8fe:	81 30       	cpi	r24, 0x01	; 1
     900:	b9 f0       	breq	.+46     	; 0x930 <__stack+0x31>
     902:	a0 f0       	brcs	.+40     	; 0x92c <__stack+0x2d>
     904:	82 30       	cpi	r24, 0x02	; 2
     906:	71 f0       	breq	.+28     	; 0x924 <__stack+0x25>
     908:	84 30       	cpi	r24, 0x04	; 4
     90a:	71 f4       	brne	.+28     	; 0x928 <__stack+0x29>
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_9:
    UCSR0B |= (1 << UCSZ02);
     90c:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     910:	84 60       	ori	r24, 0x04	; 4
     912:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     916:	86 e0       	ldi	r24, 0x06	; 6
  }

#if defined(__AVR_ATmega162__)
  UCSR0C = (1 << URSEL0) | ucsr0c;
#else
  UCSR0C = ucsr0c;
     918:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     91c:	08 95       	ret
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
     91e:	6a e1       	ldi	r22, 0x1A	; 26
     920:	71 e0       	ldi	r23, 0x01	; 1
     922:	da cf       	rjmp	.-76     	; 0x8d8 <sd_lld_start+0x6>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
    break;
  case USART_CHAR_SIZE_7:
    ucsr0c = (1 << UCSZ01);
     924:	84 e0       	ldi	r24, 0x04	; 4
     926:	f8 cf       	rjmp	.-16     	; 0x918 <__stack+0x19>
    UCSR0B |= (1 << UCSZ02);
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    break;
  case USART_CHAR_SIZE_8:
  default:
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
     928:	86 e0       	ldi	r24, 0x06	; 6
     92a:	f6 cf       	rjmp	.-20     	; 0x918 <__stack+0x19>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
  UCSR0A = (1 << U2X0);
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
  switch (config->sc_bits_per_char) {
  case USART_CHAR_SIZE_5:
    ucsr0c = 0;
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	f4 cf       	rjmp	.-24     	; 0x918 <__stack+0x19>
    break;
  case USART_CHAR_SIZE_6:
    ucsr0c = (1 << UCSZ00);
     930:	82 e0       	ldi	r24, 0x02	; 2
     932:	f2 cf       	rjmp	.-28     	; 0x918 <__stack+0x19>

00000934 <chSysInit>:
    /* Registry header, access to this list depends on the current
       kernel configuration.*/
    rqp = REG_HEADER(oip);

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
     934:	cf 93       	push	r28
     936:	df 93       	push	r29
     938:	cd e3       	ldi	r28, 0x3D	; 61
     93a:	d3 e0       	ldi	r29, 0x03	; 3
     93c:	81 e0       	ldi	r24, 0x01	; 1
     93e:	88 83       	st	Y, r24
     940:	1a 82       	std	Y+2, r1	; 0x02
     942:	19 82       	std	Y+1, r1	; 0x01
     944:	df d5       	rcall	.+3006   	; 0x1504 <__core_init>
     946:	1f d6       	rcall	.+3134   	; 0x1586 <__heap_init>
     948:	60 e2       	ldi	r22, 0x20	; 32
     94a:	71 e0       	ldi	r23, 0x01	; 1
     94c:	80 e4       	ldi	r24, 0x40	; 64
     94e:	93 e0       	ldi	r25, 0x03	; 3
     950:	c4 d3       	rcall	.+1928   	; 0x10da <chInstanceObjectInit>
     952:	82 e0       	ldi	r24, 0x02	; 2
     954:	88 83       	st	Y, r24
     956:	78 94       	sei
     958:	df 91       	pop	r29
     95a:	cf 91       	pop	r28
     95c:	08 95       	ret

0000095e <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     95e:	91 c1       	rjmp	.+802    	; 0xc82 <chVTDoTickI>

00000960 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
     964:	e0 e4       	ldi	r30, 0x40	; 64
     966:	f3 e0       	ldi	r31, 0x03	; 3
     968:	07 8d       	ldd	r16, Z+31	; 0x1f
     96a:	10 a1       	ldd	r17, Z+32	; 0x20
     96c:	21 a1       	ldd	r18, Z+33	; 0x21
     96e:	32 a1       	ldd	r19, Z+34	; 0x22
     970:	dc 01       	movw	r26, r24
     972:	cb 01       	movw	r24, r22
     974:	80 2b       	or	r24, r16
     976:	91 2b       	or	r25, r17
     978:	a2 2b       	or	r26, r18
     97a:	b3 2b       	or	r27, r19
     97c:	87 8f       	std	Z+31, r24	; 0x1f
     97e:	90 a3       	std	Z+32, r25	; 0x20
     980:	a1 a3       	std	Z+33, r26	; 0x21
     982:	b2 a3       	std	Z+34, r27	; 0x22
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
     984:	1f 91       	pop	r17
     986:	0f 91       	pop	r16
     988:	08 95       	ret

0000098a <vt_insert_first.constprop.3>:
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
}
     98a:	cf 92       	push	r12
     98c:	df 92       	push	r13
     98e:	ef 92       	push	r14
     990:	ff 92       	push	r15
     992:	0f 93       	push	r16
     994:	1f 93       	push	r17
     996:	cf 93       	push	r28
     998:	df 93       	push	r29
     99a:	fc 01       	movw	r30, r24
     99c:	8b 01       	movw	r16, r22
     99e:	70 93 4e 03 	sts	0x034E, r23	; 0x80034e <ch0+0xe>
     9a2:	60 93 4d 03 	sts	0x034D, r22	; 0x80034d <ch0+0xd>
     9a6:	44 83       	std	Z+4, r20	; 0x04
     9a8:	55 83       	std	Z+5, r21	; 0x05
     9aa:	87 e4       	ldi	r24, 0x47	; 71
     9ac:	93 e0       	ldi	r25, 0x03	; 3
     9ae:	93 83       	std	Z+3, r25	; 0x03
     9b0:	82 83       	std	Z+2, r24	; 0x02
     9b2:	a0 91 47 03 	lds	r26, 0x0347	; 0x800347 <ch0+0x7>
     9b6:	b0 91 48 03 	lds	r27, 0x0348	; 0x800348 <ch0+0x8>
     9ba:	b1 83       	std	Z+1, r27	; 0x01
     9bc:	a0 83       	st	Z, r26
     9be:	13 96       	adiw	r26, 0x03	; 3
     9c0:	fc 93       	st	X, r31
     9c2:	ee 93       	st	-X, r30
     9c4:	12 97       	sbiw	r26, 0x02	; 2
     9c6:	f0 93 48 03 	sts	0x0348, r31	; 0x800348 <ch0+0x8>
     9ca:	e0 93 47 03 	sts	0x0347, r30	; 0x800347 <ch0+0x7>
     9ce:	c0 90 4f 03 	lds	r12, 0x034F	; 0x80034f <ch0+0xf>
     9d2:	d0 90 50 03 	lds	r13, 0x0350	; 0x800350 <ch0+0x10>
     9d6:	ea 01       	movw	r28, r20
     9d8:	4c 15       	cp	r20, r12
     9da:	5d 05       	cpc	r21, r13
     9dc:	08 f4       	brcc	.+2      	; 0x9e0 <vt_insert_first.constprop.3+0x56>
     9de:	e6 01       	movw	r28, r12
     9e0:	c8 01       	movw	r24, r16
     9e2:	8c 0f       	add	r24, r28
     9e4:	9d 1f       	adc	r25, r29
     9e6:	7c db       	rcall	.-2312   	; 0xe0 <stStartAlarm>
     9e8:	08 c0       	rjmp	.+16     	; 0x9fa <vt_insert_first.constprop.3+0x70>
     9ea:	e6 01       	movw	r28, r12
     9ec:	21 96       	adiw	r28, 0x01	; 1
     9ee:	c8 01       	movw	r24, r16
     9f0:	8c 0f       	add	r24, r28
     9f2:	9d 1f       	adc	r25, r29
     9f4:	81 db       	rcall	.-2302   	; 0xf8 <stSetAlarm>
     9f6:	6e 01       	movw	r12, r28
     9f8:	87 01       	movw	r16, r14
     9fa:	6d db       	rcall	.-2342   	; 0xd6 <stGetCounter>
     9fc:	7c 01       	movw	r14, r24
     9fe:	80 1b       	sub	r24, r16
     a00:	91 0b       	sbc	r25, r17
     a02:	8c 17       	cp	r24, r28
     a04:	9d 07       	cpc	r25, r29
     a06:	88 f7       	brcc	.-30     	; 0x9ea <vt_insert_first.constprop.3+0x60>
     a08:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <ch0+0xf>
     a0c:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <ch0+0x10>
     a10:	8c 15       	cp	r24, r12
     a12:	9d 05       	cpc	r25, r13
     a14:	48 f0       	brcs	.+18     	; 0xa28 <vt_insert_first.constprop.3+0x9e>
     a16:	df 91       	pop	r29
     a18:	cf 91       	pop	r28
     a1a:	1f 91       	pop	r17
     a1c:	0f 91       	pop	r16
     a1e:	ff 90       	pop	r15
     a20:	ef 90       	pop	r14
     a22:	df 90       	pop	r13
     a24:	cf 90       	pop	r12
     a26:	08 95       	ret
     a28:	d0 92 50 03 	sts	0x0350, r13	; 0x800350 <ch0+0x10>
     a2c:	c0 92 4f 03 	sts	0x034F, r12	; 0x80034f <ch0+0xf>
     a30:	61 e0       	ldi	r22, 0x01	; 1
     a32:	70 e0       	ldi	r23, 0x00	; 0
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	1f 91       	pop	r17
     a3e:	0f 91       	pop	r16
     a40:	ff 90       	pop	r15
     a42:	ef 90       	pop	r14
     a44:	df 90       	pop	r13
     a46:	cf 90       	pop	r12
     a48:	8b cf       	rjmp	.-234    	; 0x960 <chRFCUCollectFaultsI>

00000a4a <vt_set_alarm.constprop.4>:
     a4a:	ef 92       	push	r14
     a4c:	ff 92       	push	r15
     a4e:	0f 93       	push	r16
     a50:	1f 93       	push	r17
     a52:	cf 93       	push	r28
     a54:	df 93       	push	r29
     a56:	8c 01       	movw	r16, r24
     a58:	e0 90 4f 03 	lds	r14, 0x034F	; 0x80034f <ch0+0xf>
     a5c:	f0 90 50 03 	lds	r15, 0x0350	; 0x800350 <ch0+0x10>
     a60:	e7 01       	movw	r28, r14
     a62:	e6 16       	cp	r14, r22
     a64:	f7 06       	cpc	r15, r23
     a66:	30 f4       	brcc	.+12     	; 0xa74 <vt_set_alarm.constprop.4+0x2a>
     a68:	eb 01       	movw	r28, r22
     a6a:	04 c0       	rjmp	.+8      	; 0xa74 <vt_set_alarm.constprop.4+0x2a>
     a6c:	e7 01       	movw	r28, r14
     a6e:	21 96       	adiw	r28, 0x01	; 1
     a70:	8c 01       	movw	r16, r24
     a72:	7e 01       	movw	r14, r28
     a74:	c8 01       	movw	r24, r16
     a76:	8c 0f       	add	r24, r28
     a78:	9d 1f       	adc	r25, r29
     a7a:	3e db       	rcall	.-2436   	; 0xf8 <stSetAlarm>
     a7c:	2c db       	rcall	.-2472   	; 0xd6 <stGetCounter>
     a7e:	9c 01       	movw	r18, r24
     a80:	20 1b       	sub	r18, r16
     a82:	31 0b       	sbc	r19, r17
     a84:	2c 17       	cp	r18, r28
     a86:	3d 07       	cpc	r19, r29
     a88:	88 f7       	brcc	.-30     	; 0xa6c <vt_set_alarm.constprop.4+0x22>
     a8a:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <ch0+0xf>
     a8e:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <ch0+0x10>
     a92:	8e 15       	cp	r24, r14
     a94:	9f 05       	cpc	r25, r15
     a96:	38 f0       	brcs	.+14     	; 0xaa6 <vt_set_alarm.constprop.4+0x5c>
     a98:	df 91       	pop	r29
     a9a:	cf 91       	pop	r28
     a9c:	1f 91       	pop	r17
     a9e:	0f 91       	pop	r16
     aa0:	ff 90       	pop	r15
     aa2:	ef 90       	pop	r14
     aa4:	08 95       	ret
     aa6:	f0 92 50 03 	sts	0x0350, r15	; 0x800350 <ch0+0x10>
     aaa:	e0 92 4f 03 	sts	0x034F, r14	; 0x80034f <ch0+0xf>
     aae:	61 e0       	ldi	r22, 0x01	; 1
     ab0:	70 e0       	ldi	r23, 0x00	; 0
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	df 91       	pop	r29
     ab8:	cf 91       	pop	r28
     aba:	1f 91       	pop	r17
     abc:	0f 91       	pop	r16
     abe:	ff 90       	pop	r15
     ac0:	ef 90       	pop	r14
     ac2:	4e cf       	rjmp	.-356    	; 0x960 <chRFCUCollectFaultsI>

00000ac4 <vt_enqueue.constprop.2>:
     ac4:	ef 92       	push	r14
     ac6:	ff 92       	push	r15
     ac8:	0f 93       	push	r16
     aca:	1f 93       	push	r17
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	8c 01       	movw	r16, r24
     ad2:	7b 01       	movw	r14, r22
     ad4:	00 db       	rcall	.-2560   	; 0xd6 <stGetCounter>
     ad6:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <ch0+0x7>
     ada:	f0 91 48 03 	lds	r31, 0x0348	; 0x800348 <ch0+0x8>
     ade:	23 e0       	ldi	r18, 0x03	; 3
     ae0:	e7 34       	cpi	r30, 0x47	; 71
     ae2:	f2 07       	cpc	r31, r18
     ae4:	09 f4       	brne	.+2      	; 0xae8 <vt_enqueue.constprop.2+0x24>
     ae6:	54 c0       	rjmp	.+168    	; 0xb90 <vt_enqueue.constprop.2+0xcc>
     ae8:	20 91 4d 03 	lds	r18, 0x034D	; 0x80034d <ch0+0xd>
     aec:	30 91 4e 03 	lds	r19, 0x034E	; 0x80034e <ch0+0xe>
     af0:	ac 01       	movw	r20, r24
     af2:	42 1b       	sub	r20, r18
     af4:	53 0b       	sbc	r21, r19
     af6:	e7 01       	movw	r28, r14
     af8:	c4 0f       	add	r28, r20
     afa:	d5 1f       	adc	r29, r21
     afc:	c4 17       	cp	r28, r20
     afe:	d5 07       	cpc	r29, r21
     b00:	c0 f1       	brcs	.+112    	; 0xb72 <vt_enqueue.constprop.2+0xae>
     b02:	24 81       	ldd	r18, Z+4	; 0x04
     b04:	35 81       	ldd	r19, Z+5	; 0x05
     b06:	c2 17       	cp	r28, r18
     b08:	d3 07       	cpc	r29, r19
     b0a:	c8 f1       	brcs	.+114    	; 0xb7e <vt_enqueue.constprop.2+0xba>
     b0c:	2c 17       	cp	r18, r28
     b0e:	3d 07       	cpc	r19, r29
     b10:	50 f4       	brcc	.+20     	; 0xb26 <vt_enqueue.constprop.2+0x62>
     b12:	c2 1b       	sub	r28, r18
     b14:	d3 0b       	sbc	r29, r19
     b16:	01 90       	ld	r0, Z+
     b18:	f0 81       	ld	r31, Z
     b1a:	e0 2d       	mov	r30, r0
     b1c:	24 81       	ldd	r18, Z+4	; 0x04
     b1e:	35 81       	ldd	r19, Z+5	; 0x05
     b20:	2c 17       	cp	r18, r28
     b22:	3d 07       	cpc	r19, r29
     b24:	b0 f3       	brcs	.-20     	; 0xb12 <vt_enqueue.constprop.2+0x4e>
     b26:	d8 01       	movw	r26, r16
     b28:	15 96       	adiw	r26, 0x05	; 5
     b2a:	dc 93       	st	X, r29
     b2c:	ce 93       	st	-X, r28
     b2e:	14 97       	sbiw	r26, 0x04	; 4
     b30:	11 96       	adiw	r26, 0x01	; 1
     b32:	fc 93       	st	X, r31
     b34:	ee 93       	st	-X, r30
     b36:	82 81       	ldd	r24, Z+2	; 0x02
     b38:	93 81       	ldd	r25, Z+3	; 0x03
     b3a:	13 96       	adiw	r26, 0x03	; 3
     b3c:	9c 93       	st	X, r25
     b3e:	8e 93       	st	-X, r24
     b40:	12 97       	sbiw	r26, 0x02	; 2
     b42:	dc 01       	movw	r26, r24
     b44:	0d 93       	st	X+, r16
     b46:	1c 93       	st	X, r17
     b48:	13 83       	std	Z+3, r17	; 0x03
     b4a:	02 83       	std	Z+2, r16	; 0x02
     b4c:	84 81       	ldd	r24, Z+4	; 0x04
     b4e:	95 81       	ldd	r25, Z+5	; 0x05
     b50:	8c 1b       	sub	r24, r28
     b52:	9d 0b       	sbc	r25, r29
     b54:	95 83       	std	Z+5, r25	; 0x05
     b56:	84 83       	std	Z+4, r24	; 0x04
     b58:	8f ef       	ldi	r24, 0xFF	; 255
     b5a:	9f ef       	ldi	r25, 0xFF	; 255
     b5c:	90 93 4c 03 	sts	0x034C, r25	; 0x80034c <ch0+0xc>
     b60:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <ch0+0xb>
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	ff 90       	pop	r15
     b6e:	ef 90       	pop	r14
     b70:	08 95       	ret
     b72:	e7 01       	movw	r28, r14
     b74:	24 81       	ldd	r18, Z+4	; 0x04
     b76:	35 81       	ldd	r19, Z+5	; 0x05
     b78:	c2 17       	cp	r28, r18
     b7a:	d3 07       	cpc	r29, r19
     b7c:	38 f6       	brcc	.-114    	; 0xb0c <vt_enqueue.constprop.2+0x48>
     b7e:	b7 01       	movw	r22, r14
     b80:	64 df       	rcall	.-312    	; 0xa4a <vt_set_alarm.constprop.4>
     b82:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <ch0+0x7>
     b86:	f0 91 48 03 	lds	r31, 0x0348	; 0x800348 <ch0+0x8>
     b8a:	24 81       	ldd	r18, Z+4	; 0x04
     b8c:	35 81       	ldd	r19, Z+5	; 0x05
     b8e:	be cf       	rjmp	.-132    	; 0xb0c <vt_enqueue.constprop.2+0x48>
     b90:	a7 01       	movw	r20, r14
     b92:	bc 01       	movw	r22, r24
     b94:	c8 01       	movw	r24, r16
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	f3 ce       	rjmp	.-538    	; 0x98a <vt_insert_first.constprop.3>

00000ba4 <chVTDoSetI>:
     ba4:	fc 01       	movw	r30, r24
     ba6:	31 87       	std	Z+9, r19	; 0x09
     ba8:	20 87       	std	Z+8, r18	; 0x08
     baa:	57 83       	std	Z+7, r21	; 0x07
     bac:	46 83       	std	Z+6, r20	; 0x06
     bae:	13 86       	std	Z+11, r1	; 0x0b
     bb0:	12 86       	std	Z+10, r1	; 0x0a
     bb2:	88 cf       	rjmp	.-240    	; 0xac4 <vt_enqueue.constprop.2>

00000bb4 <chVTDoResetI>:
     bb4:	cf 93       	push	r28
     bb6:	df 93       	push	r29
     bb8:	fc 01       	movw	r30, r24
     bba:	80 91 47 03 	lds	r24, 0x0347	; 0x800347 <ch0+0x7>
     bbe:	90 91 48 03 	lds	r25, 0x0348	; 0x800348 <ch0+0x8>
     bc2:	e8 17       	cp	r30, r24
     bc4:	f9 07       	cpc	r31, r25
     bc6:	19 f1       	breq	.+70     	; 0xc0e <chVTDoResetI+0x5a>
     bc8:	c2 81       	ldd	r28, Z+2	; 0x02
     bca:	d3 81       	ldd	r29, Z+3	; 0x03
     bcc:	80 81       	ld	r24, Z
     bce:	91 81       	ldd	r25, Z+1	; 0x01
     bd0:	99 83       	std	Y+1, r25	; 0x01
     bd2:	88 83       	st	Y, r24
     bd4:	a0 81       	ld	r26, Z
     bd6:	b1 81       	ldd	r27, Z+1	; 0x01
     bd8:	13 96       	adiw	r26, 0x03	; 3
     bda:	dc 93       	st	X, r29
     bdc:	ce 93       	st	-X, r28
     bde:	12 97       	sbiw	r26, 0x02	; 2
     be0:	14 96       	adiw	r26, 0x04	; 4
     be2:	2d 91       	ld	r18, X+
     be4:	3c 91       	ld	r19, X
     be6:	15 97       	sbiw	r26, 0x05	; 5
     be8:	84 81       	ldd	r24, Z+4	; 0x04
     bea:	95 81       	ldd	r25, Z+5	; 0x05
     bec:	82 0f       	add	r24, r18
     bee:	93 1f       	adc	r25, r19
     bf0:	15 96       	adiw	r26, 0x05	; 5
     bf2:	9c 93       	st	X, r25
     bf4:	8e 93       	st	-X, r24
     bf6:	14 97       	sbiw	r26, 0x04	; 4
     bf8:	11 82       	std	Z+1, r1	; 0x01
     bfa:	10 82       	st	Z, r1
     bfc:	8f ef       	ldi	r24, 0xFF	; 255
     bfe:	9f ef       	ldi	r25, 0xFF	; 255
     c00:	90 93 4c 03 	sts	0x034C, r25	; 0x80034c <ch0+0xc>
     c04:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <ch0+0xb>
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	08 95       	ret
     c0e:	a0 81       	ld	r26, Z
     c10:	b1 81       	ldd	r27, Z+1	; 0x01
     c12:	b0 93 48 03 	sts	0x0348, r27	; 0x800348 <ch0+0x8>
     c16:	a0 93 47 03 	sts	0x0347, r26	; 0x800347 <ch0+0x7>
     c1a:	87 e4       	ldi	r24, 0x47	; 71
     c1c:	93 e0       	ldi	r25, 0x03	; 3
     c1e:	13 96       	adiw	r26, 0x03	; 3
     c20:	9c 93       	st	X, r25
     c22:	8e 93       	st	-X, r24
     c24:	12 97       	sbiw	r26, 0x02	; 2
     c26:	11 82       	std	Z+1, r1	; 0x01
     c28:	10 82       	st	Z, r1
     c2a:	a0 91 47 03 	lds	r26, 0x0347	; 0x800347 <ch0+0x7>
     c2e:	b0 91 48 03 	lds	r27, 0x0348	; 0x800348 <ch0+0x8>
     c32:	a8 17       	cp	r26, r24
     c34:	b9 07       	cpc	r27, r25
     c36:	11 f1       	breq	.+68     	; 0xc7c <chVTDoResetI+0xc8>
     c38:	14 96       	adiw	r26, 0x04	; 4
     c3a:	2d 91       	ld	r18, X+
     c3c:	3c 91       	ld	r19, X
     c3e:	15 97       	sbiw	r26, 0x05	; 5
     c40:	84 81       	ldd	r24, Z+4	; 0x04
     c42:	95 81       	ldd	r25, Z+5	; 0x05
     c44:	82 0f       	add	r24, r18
     c46:	93 1f       	adc	r25, r19
     c48:	15 96       	adiw	r26, 0x05	; 5
     c4a:	9c 93       	st	X, r25
     c4c:	8e 93       	st	-X, r24
     c4e:	14 97       	sbiw	r26, 0x04	; 4
     c50:	42 da       	rcall	.-2940   	; 0xd6 <stGetCounter>
     c52:	20 91 4d 03 	lds	r18, 0x034D	; 0x80034d <ch0+0xd>
     c56:	30 91 4e 03 	lds	r19, 0x034E	; 0x80034e <ch0+0xe>
     c5a:	ac 01       	movw	r20, r24
     c5c:	42 1b       	sub	r20, r18
     c5e:	53 0b       	sbc	r21, r19
     c60:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <ch0+0x7>
     c64:	f0 91 48 03 	lds	r31, 0x0348	; 0x800348 <ch0+0x8>
     c68:	64 81       	ldd	r22, Z+4	; 0x04
     c6a:	75 81       	ldd	r23, Z+5	; 0x05
     c6c:	46 17       	cp	r20, r22
     c6e:	57 07       	cpc	r21, r23
     c70:	58 f6       	brcc	.-106    	; 0xc08 <chVTDoResetI+0x54>
     c72:	64 1b       	sub	r22, r20
     c74:	75 0b       	sbc	r23, r21
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	e7 ce       	rjmp	.-562    	; 0xa4a <vt_set_alarm.constprop.4>
     c7c:	df 91       	pop	r29
     c7e:	cf 91       	pop	r28
     c80:	38 ca       	rjmp	.-2960   	; 0xf2 <stStopAlarm>

00000c82 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     c82:	cf 92       	push	r12
     c84:	df 92       	push	r13
     c86:	ef 92       	push	r14
     c88:	ff 92       	push	r15
     c8a:	0f 93       	push	r16
     c8c:	1f 93       	push	r17
     c8e:	cf 93       	push	r28
     c90:	df 93       	push	r29
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     c92:	ee 24       	eor	r14, r14
     c94:	ea 94       	dec	r14
     c96:	fe 2c       	mov	r15, r14
     c98:	0b c0       	rjmp	.+22     	; 0xcb0 <chVTDoTickI+0x2e>
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
     c9a:	68 85       	ldd	r22, Y+8	; 0x08
     c9c:	79 85       	ldd	r23, Y+9	; 0x09
     c9e:	ee 81       	ldd	r30, Y+6	; 0x06
     ca0:	ff 81       	ldd	r31, Y+7	; 0x07
     ca2:	ce 01       	movw	r24, r28
     ca4:	09 95       	icall

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
     ca6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ca8:	9b 85       	ldd	r25, Y+11	; 0x0b
     caa:	89 2b       	or	r24, r25
     cac:	09 f0       	breq	.+2      	; 0xcb0 <chVTDoTickI+0x2e>
     cae:	48 c0       	rjmp	.+144    	; 0xd40 <chVTDoTickI+0xbe>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
     cb0:	c0 91 47 03 	lds	r28, 0x0347	; 0x800347 <ch0+0x7>
     cb4:	d0 91 48 03 	lds	r29, 0x0348	; 0x800348 <ch0+0x8>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     cb8:	0e da       	rcall	.-3044   	; 0xd6 <stGetCounter>

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
     cba:	00 91 4d 03 	lds	r16, 0x034D	; 0x80034d <ch0+0xd>
     cbe:	10 91 4e 03 	lds	r17, 0x034E	; 0x80034e <ch0+0xe>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     cc2:	ac 01       	movw	r20, r24
     cc4:	40 1b       	sub	r20, r16
     cc6:	51 0b       	sbc	r21, r17

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
     cc8:	2c 81       	ldd	r18, Y+4	; 0x04
     cca:	3d 81       	ldd	r19, Y+5	; 0x05
     ccc:	42 17       	cp	r20, r18
     cce:	53 07       	cpc	r21, r19
     cd0:	e8 f0       	brcs	.+58     	; 0xd0c <chVTDoTickI+0x8a>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
     cd2:	02 0f       	add	r16, r18
     cd4:	13 1f       	adc	r17, r19
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;
     cd6:	10 93 4e 03 	sts	0x034E, r17	; 0x80034e <ch0+0xe>
     cda:	00 93 4d 03 	sts	0x034D, r16	; 0x80034d <ch0+0xd>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     cde:	ea 81       	ldd	r30, Y+2	; 0x02
     ce0:	fb 81       	ldd	r31, Y+3	; 0x03
     ce2:	88 81       	ld	r24, Y
     ce4:	99 81       	ldd	r25, Y+1	; 0x01
     ce6:	91 83       	std	Z+1, r25	; 0x01
     ce8:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     cea:	a8 81       	ld	r26, Y
     cec:	b9 81       	ldd	r27, Y+1	; 0x01
     cee:	13 96       	adiw	r26, 0x03	; 3
     cf0:	fc 93       	st	X, r31
     cf2:	ee 93       	st	-X, r30
     cf4:	12 97       	sbiw	r26, 0x02	; 2

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
     cf6:	19 82       	std	Y+1, r1	; 0x01
     cf8:	18 82       	st	Y, r1

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
     cfa:	80 91 47 03 	lds	r24, 0x0347	; 0x800347 <ch0+0x7>
     cfe:	90 91 48 03 	lds	r25, 0x0348	; 0x800348 <ch0+0x8>
     d02:	87 54       	subi	r24, 0x47	; 71
     d04:	93 40       	sbci	r25, 0x03	; 3
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
     d06:	49 f6       	brne	.-110    	; 0xc9a <chVTDoTickI+0x18>
     d08:	f4 d9       	rcall	.-3096   	; 0xf2 <stStopAlarm>
     d0a:	c7 cf       	rjmp	.-114    	; 0xc9a <chVTDoTickI+0x18>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
     d0c:	60 91 47 03 	lds	r22, 0x0347	; 0x800347 <ch0+0x7>
     d10:	70 91 48 03 	lds	r23, 0x0348	; 0x800348 <ch0+0x8>
     d14:	67 54       	subi	r22, 0x47	; 71
     d16:	73 40       	sbci	r23, 0x03	; 3
     d18:	09 f4       	brne	.+2      	; 0xd1c <chVTDoTickI+0x9a>
     d1a:	5f c0       	rjmp	.+190    	; 0xdda <chVTDoTickI+0x158>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
     d1c:	90 93 4e 03 	sts	0x034E, r25	; 0x80034e <ch0+0xe>
     d20:	80 93 4d 03 	sts	0x034D, r24	; 0x80034d <ch0+0xd>
  vtp->dlist.delta -= nowdelta;
     d24:	b9 01       	movw	r22, r18
     d26:	64 1b       	sub	r22, r20
     d28:	75 0b       	sbc	r23, r21
     d2a:	7d 83       	std	Y+5, r23	; 0x05
     d2c:	6c 83       	std	Y+4, r22	; 0x04

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	df 90       	pop	r13
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
     d3c:	cf 90       	pop	r12
     d3e:	85 ce       	rjmp	.-758    	; 0xa4a <vt_set_alarm.constprop.4>
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
     d40:	ca d9       	rcall	.-3180   	; 0xd6 <stGetCounter>
     d42:	6c 01       	movw	r12, r24
     d44:	ac 01       	movw	r20, r24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     d46:	40 1b       	sub	r20, r16
     d48:	51 0b       	sbc	r21, r17
     d4a:	8a 01       	movw	r16, r20
     d4c:	8a 85       	ldd	r24, Y+10	; 0x0a
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
     d4e:	9b 85       	ldd	r25, Y+11	; 0x0b
     d50:	84 17       	cp	r24, r20
     d52:	95 07       	cpc	r25, r21
     d54:	98 f1       	brcs	.+102    	; 0xdbc <chVTDoTickI+0x13a>
     d56:	ac 01       	movw	r20, r24

        delay = (sysinterval_t)0;
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
     d58:	40 1b       	sub	r20, r16
     d5a:	51 0b       	sbc	r21, r17
     d5c:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     d60:	f0 91 48 03 	lds	r31, 0x0348	; 0x800348 <ch0+0x8>
     d64:	23 e0       	ldi	r18, 0x03	; 3
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     d66:	e7 34       	cpi	r30, 0x47	; 71
     d68:	f2 07       	cpc	r31, r18
     d6a:	09 f4       	brne	.+2      	; 0xd6e <chVTDoTickI+0xec>
     d6c:	41 c0       	rjmp	.+130    	; 0xdf0 <chVTDoTickI+0x16e>
     d6e:	24 81       	ldd	r18, Z+4	; 0x04
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     d70:	35 81       	ldd	r19, Z+5	; 0x05
     d72:	28 17       	cp	r18, r24
     d74:	39 07       	cpc	r19, r25
     d76:	50 f4       	brcc	.+20     	; 0xd8c <chVTDoTickI+0x10a>
     d78:	82 1b       	sub	r24, r18
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     d7a:	93 0b       	sbc	r25, r19
     d7c:	01 90       	ld	r0, Z+
    dlp = dlp->next;
     d7e:	f0 81       	ld	r31, Z
     d80:	e0 2d       	mov	r30, r0
     d82:	24 81       	ldd	r18, Z+4	; 0x04
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     d84:	35 81       	ldd	r19, Z+5	; 0x05
     d86:	28 17       	cp	r18, r24
     d88:	39 07       	cpc	r19, r25
     d8a:	b0 f3       	brcs	.-20     	; 0xd78 <chVTDoTickI+0xf6>
     d8c:	9d 83       	std	Y+5, r25	; 0x05
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     d8e:	8c 83       	std	Y+4, r24	; 0x04
     d90:	f9 83       	std	Y+1, r31	; 0x01
  dlp->next       = dlhp;
     d92:	e8 83       	st	Y, r30
     d94:	a2 81       	ldd	r26, Z+2	; 0x02
  dlp->prev       = dlp->next->prev;
     d96:	b3 81       	ldd	r27, Z+3	; 0x03
     d98:	bb 83       	std	Y+3, r27	; 0x03
     d9a:	aa 83       	std	Y+2, r26	; 0x02
     d9c:	cd 93       	st	X+, r28
  dlp->prev->next = dlp;
     d9e:	dc 93       	st	X, r29
     da0:	d3 83       	std	Z+3, r29	; 0x03
  dlhp->prev      = dlp;
     da2:	c2 83       	std	Z+2, r28	; 0x02
     da4:	24 81       	ldd	r18, Z+4	; 0x04

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     da6:	35 81       	ldd	r19, Z+5	; 0x05
     da8:	a9 01       	movw	r20, r18
     daa:	48 1b       	sub	r20, r24
     dac:	59 0b       	sbc	r21, r25
     dae:	55 83       	std	Z+5, r21	; 0x05
     db0:	44 83       	std	Z+4, r20	; 0x04
     db2:	f0 92 4c 03 	sts	0x034C, r15	; 0x80034c <ch0+0xc>

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     db6:	e0 92 4b 03 	sts	0x034B, r14	; 0x80034b <ch0+0xb>
     dba:	7a cf       	rjmp	.-268    	; 0xcb0 <chVTDoTickI+0x2e>
     dbc:	62 e0       	ldi	r22, 0x02	; 2
      if (nowdelta > vtp->reload) {
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
     dbe:	70 e0       	ldi	r23, 0x00	; 0
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	cd dd       	rcall	.-1126   	; 0x960 <chRFCUCollectFaultsI>
     dc6:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <ch0+0x7>
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
     dca:	f0 91 48 03 	lds	r31, 0x0348	; 0x800348 <ch0+0x8>
     dce:	53 e0       	ldi	r21, 0x03	; 3
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
     dd0:	e7 34       	cpi	r30, 0x47	; 71
     dd2:	f5 07       	cpc	r31, r21
     dd4:	59 f0       	breq	.+22     	; 0xdec <chVTDoTickI+0x16a>
     dd6:	c8 01       	movw	r24, r16
     dd8:	ca cf       	rjmp	.-108    	; 0xd6e <chVTDoTickI+0xec>
     dda:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     ddc:	cf 91       	pop	r28
     dde:	1f 91       	pop	r17
     de0:	0f 91       	pop	r16
     de2:	ff 90       	pop	r15
     de4:	ef 90       	pop	r14
     de6:	df 90       	pop	r13
     de8:	cf 90       	pop	r12
     dea:	08 95       	ret
     dec:	40 e0       	ldi	r20, 0x00	; 0
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);

        delay = (sysinterval_t)0;
     dee:	50 e0       	ldi	r21, 0x00	; 0
     df0:	b6 01       	movw	r22, r12
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     df2:	ce 01       	movw	r24, r28
     df4:	df 91       	pop	r29
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     df6:	cf 91       	pop	r28
     df8:	1f 91       	pop	r17
     dfa:	0f 91       	pop	r16
     dfc:	ff 90       	pop	r15
     dfe:	ef 90       	pop	r14
     e00:	df 90       	pop	r13
     e02:	cf 90       	pop	r12
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {

        vt_insert_first(vtlp, vtp, now, delay);
     e04:	c2 cd       	rjmp	.-1148   	; 0x98a <vt_insert_first.constprop.3>

00000e06 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     e06:	cf 93       	push	r28
     e08:	df 93       	push	r29
     e0a:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     e0c:	1f 96       	adiw	r26, 0x0f	; 15
     e0e:	8c 91       	ld	r24, X
     e10:	1f 97       	sbiw	r26, 0x0f	; 15
     e12:	84 30       	cpi	r24, 0x04	; 4
     e14:	f1 f1       	breq	.+124    	; 0xe92 <__sch_wakeup+0x8c>
     e16:	80 f5       	brcc	.+96     	; 0xe78 <__sch_wakeup+0x72>
     e18:	88 23       	and	r24, r24
     e1a:	59 f1       	breq	.+86     	; 0xe72 <__sch_wakeup+0x6c>
     e1c:	83 30       	cpi	r24, 0x03	; 3
     e1e:	31 f4       	brne	.+12     	; 0xe2c <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     e20:	52 96       	adiw	r26, 0x12	; 18
     e22:	ed 91       	ld	r30, X+
     e24:	fc 91       	ld	r31, X
     e26:	53 97       	sbiw	r26, 0x13	; 19
     e28:	11 82       	std	Z+1, r1	; 0x01
     e2a:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	9f ef       	ldi	r25, 0xFF	; 255
     e30:	53 96       	adiw	r26, 0x13	; 19
     e32:	9c 93       	st	X, r25
     e34:	8e 93       	st	-X, r24
     e36:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     e38:	1f 96       	adiw	r26, 0x0f	; 15
     e3a:	1c 92       	st	X, r1
     e3c:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     e3e:	1b 96       	adiw	r26, 0x0b	; 11
     e40:	ed 91       	ld	r30, X+
     e42:	fc 91       	ld	r31, X
     e44:	1c 97       	sbiw	r26, 0x0c	; 12
     e46:	14 96       	adiw	r26, 0x04	; 4
     e48:	9c 91       	ld	r25, X
     e4a:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     e4c:	01 90       	ld	r0, Z+
     e4e:	f0 81       	ld	r31, Z
     e50:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     e52:	84 81       	ldd	r24, Z+4	; 0x04
     e54:	89 17       	cp	r24, r25
     e56:	d0 f7       	brcc	.-12     	; 0xe4c <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     e58:	11 96       	adiw	r26, 0x01	; 1
     e5a:	fc 93       	st	X, r31
     e5c:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     e5e:	c2 81       	ldd	r28, Z+2	; 0x02
     e60:	d3 81       	ldd	r29, Z+3	; 0x03
     e62:	13 96       	adiw	r26, 0x03	; 3
     e64:	dc 93       	st	X, r29
     e66:	ce 93       	st	-X, r28
     e68:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     e6a:	b9 83       	std	Y+1, r27	; 0x01
     e6c:	a8 83       	st	Y, r26
  pqp->prev     = p;
     e6e:	b3 83       	std	Z+3, r27	; 0x03
     e70:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     e78:	87 30       	cpi	r24, 0x07	; 7
     e7a:	59 f0       	breq	.+22     	; 0xe92 <__sch_wakeup+0x8c>
     e7c:	8c 30       	cpi	r24, 0x0C	; 12
     e7e:	49 f0       	breq	.+18     	; 0xe92 <__sch_wakeup+0x8c>
     e80:	85 30       	cpi	r24, 0x05	; 5
     e82:	a1 f6       	brne	.-88     	; 0xe2c <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     e84:	52 96       	adiw	r26, 0x12	; 18
     e86:	ed 91       	ld	r30, X+
     e88:	fc 91       	ld	r31, X
     e8a:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     e8c:	84 81       	ldd	r24, Z+4	; 0x04
     e8e:	8f 5f       	subi	r24, 0xFF	; 255
     e90:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     e92:	12 96       	adiw	r26, 0x02	; 2
     e94:	ed 91       	ld	r30, X+
     e96:	fc 91       	ld	r31, X
     e98:	13 97       	sbiw	r26, 0x03	; 3
     e9a:	8d 91       	ld	r24, X+
     e9c:	9c 91       	ld	r25, X
     e9e:	11 97       	sbiw	r26, 0x01	; 1
     ea0:	91 83       	std	Z+1, r25	; 0x01
     ea2:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     ea4:	cd 91       	ld	r28, X+
     ea6:	dc 91       	ld	r29, X
     ea8:	11 97       	sbiw	r26, 0x01	; 1
     eaa:	fb 83       	std	Y+3, r31	; 0x03
     eac:	ea 83       	std	Y+2, r30	; 0x02
     eae:	be cf       	rjmp	.-132    	; 0xe2c <__sch_wakeup+0x26>

00000eb0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
     eb4:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     eb6:	1f 96       	adiw	r26, 0x0f	; 15
     eb8:	1c 92       	st	X, r1
     eba:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     ebc:	1b 96       	adiw	r26, 0x0b	; 11
     ebe:	ed 91       	ld	r30, X+
     ec0:	fc 91       	ld	r31, X
     ec2:	1c 97       	sbiw	r26, 0x0c	; 12
     ec4:	14 96       	adiw	r26, 0x04	; 4
     ec6:	2c 91       	ld	r18, X
     ec8:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     eca:	01 90       	ld	r0, Z+
     ecc:	f0 81       	ld	r31, Z
     ece:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     ed0:	94 81       	ldd	r25, Z+4	; 0x04
     ed2:	92 17       	cp	r25, r18
     ed4:	d0 f7       	brcc	.-12     	; 0xeca <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     ed6:	11 96       	adiw	r26, 0x01	; 1
     ed8:	fc 93       	st	X, r31
     eda:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     edc:	c2 81       	ldd	r28, Z+2	; 0x02
     ede:	d3 81       	ldd	r29, Z+3	; 0x03
     ee0:	13 96       	adiw	r26, 0x03	; 3
     ee2:	dc 93       	st	X, r29
     ee4:	ce 93       	st	-X, r28
     ee6:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     ee8:	b9 83       	std	Y+1, r27	; 0x01
     eea:	a8 83       	st	Y, r26
  pqp->prev     = p;
     eec:	b3 83       	std	Z+3, r27	; 0x03
     eee:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     ef0:	cd 01       	movw	r24, r26
     ef2:	df 91       	pop	r29
     ef4:	cf 91       	pop	r28
     ef6:	08 95       	ret

00000ef8 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     efc:	e0 e4       	ldi	r30, 0x40	; 64
     efe:	f3 e0       	ldi	r31, 0x03	; 3
     f00:	65 81       	ldd	r22, Z+5	; 0x05
     f02:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     f04:	db 01       	movw	r26, r22
     f06:	1f 96       	adiw	r26, 0x0f	; 15
     f08:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     f0a:	80 81       	ld	r24, Z
     f0c:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     f0e:	ec 01       	movw	r28, r24
     f10:	a8 81       	ld	r26, Y
     f12:	b9 81       	ldd	r27, Y+1	; 0x01
     f14:	b1 83       	std	Z+1, r27	; 0x01
     f16:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     f18:	13 96       	adiw	r26, 0x03	; 3
     f1a:	fc 93       	st	X, r31
     f1c:	ee 93       	st	-X, r30
     f1e:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     f20:	21 e0       	ldi	r18, 0x01	; 1
     f22:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     f24:	96 83       	std	Z+6, r25	; 0x06
     f26:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     f28:	42 d3       	rcall	.+1668   	; 0x15ae <_port_switch>
}
     f2a:	df 91       	pop	r29
     f2c:	cf 91       	pop	r28
     f2e:	08 95       	ret

00000f30 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     f30:	ff 92       	push	r15
     f32:	0f 93       	push	r16
     f34:	1f 93       	push	r17
     f36:	cf 93       	push	r28
     f38:	df 93       	push	r29
     f3a:	cd b7       	in	r28, 0x3d	; 61
     f3c:	de b7       	in	r29, 0x3e	; 62
     f3e:	2c 97       	sbiw	r28, 0x0c	; 12
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	f8 94       	cli
     f44:	de bf       	out	0x3e, r29	; 62
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	cd bf       	out	0x3d, r28	; 61
     f4a:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     f4c:	00 91 45 03 	lds	r16, 0x0345	; 0x800345 <ch0+0x5>
     f50:	10 91 46 03 	lds	r17, 0x0346	; 0x800346 <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     f54:	6f 3f       	cpi	r22, 0xFF	; 255
     f56:	8f ef       	ldi	r24, 0xFF	; 255
     f58:	78 07       	cpc	r23, r24
     f5a:	f1 f0       	breq	.+60     	; 0xf98 <chSchGoSleepTimeoutS+0x68>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     f5c:	98 01       	movw	r18, r16
     f5e:	43 e0       	ldi	r20, 0x03	; 3
     f60:	57 e0       	ldi	r21, 0x07	; 7
     f62:	ce 01       	movw	r24, r28
     f64:	01 96       	adiw	r24, 0x01	; 1
     f66:	1e de       	rcall	.-964    	; 0xba4 <chVTDoSetI>
    chSchGoSleepS(newstate);
     f68:	8f 2d       	mov	r24, r15
     f6a:	c6 df       	rcall	.-116    	; 0xef8 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     f6c:	89 81       	ldd	r24, Y+1	; 0x01
     f6e:	9a 81       	ldd	r25, Y+2	; 0x02
     f70:	89 2b       	or	r24, r25
     f72:	19 f0       	breq	.+6      	; 0xf7a <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     f74:	ce 01       	movw	r24, r28
     f76:	01 96       	adiw	r24, 0x01	; 1
     f78:	1d de       	rcall	.-966    	; 0xbb4 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     f7a:	f8 01       	movw	r30, r16
     f7c:	82 89       	ldd	r24, Z+18	; 0x12
     f7e:	93 89       	ldd	r25, Z+19	; 0x13
     f80:	2c 96       	adiw	r28, 0x0c	; 12
     f82:	0f b6       	in	r0, 0x3f	; 63
     f84:	f8 94       	cli
     f86:	de bf       	out	0x3e, r29	; 62
     f88:	0f be       	out	0x3f, r0	; 63
     f8a:	cd bf       	out	0x3d, r28	; 61
     f8c:	df 91       	pop	r29
     f8e:	cf 91       	pop	r28
     f90:	1f 91       	pop	r17
     f92:	0f 91       	pop	r16
     f94:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     f96:	08 95       	ret
     f98:	8f 2d       	mov	r24, r15
     f9a:	ae df       	rcall	.-164    	; 0xef8 <chSchGoSleepS>
     f9c:	ee cf       	rjmp	.-36     	; 0xf7a <chSchGoSleepTimeoutS+0x4a>

00000f9e <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     f9e:	cf 93       	push	r28
     fa0:	df 93       	push	r29
     fa2:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     fa4:	c0 91 45 03 	lds	r28, 0x0345	; 0x800345 <ch0+0x5>
     fa8:	d0 91 46 03 	lds	r29, 0x0346	; 0x800346 <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     fac:	53 96       	adiw	r26, 0x13	; 19
     fae:	7c 93       	st	X, r23
     fb0:	6e 93       	st	-X, r22
     fb2:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     fb4:	14 96       	adiw	r26, 0x04	; 4
     fb6:	2c 91       	ld	r18, X
     fb8:	14 97       	sbiw	r26, 0x04	; 4
     fba:	8c 81       	ldd	r24, Y+4	; 0x04
     fbc:	82 17       	cp	r24, r18
     fbe:	e8 f0       	brcs	.+58     	; 0xffa <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     fc0:	1f 96       	adiw	r26, 0x0f	; 15
     fc2:	1c 92       	st	X, r1
     fc4:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     fc6:	1b 96       	adiw	r26, 0x0b	; 11
     fc8:	ed 91       	ld	r30, X+
     fca:	fc 91       	ld	r31, X
     fcc:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     fce:	01 90       	ld	r0, Z+
     fd0:	f0 81       	ld	r31, Z
     fd2:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     fd4:	94 81       	ldd	r25, Z+4	; 0x04
     fd6:	92 17       	cp	r25, r18
     fd8:	d0 f7       	brcc	.-12     	; 0xfce <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     fda:	11 96       	adiw	r26, 0x01	; 1
     fdc:	fc 93       	st	X, r31
     fde:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     fe0:	c2 81       	ldd	r28, Z+2	; 0x02
     fe2:	d3 81       	ldd	r29, Z+3	; 0x03
     fe4:	13 96       	adiw	r26, 0x03	; 3
     fe6:	dc 93       	st	X, r29
     fe8:	ce 93       	st	-X, r28
     fea:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     fec:	b9 83       	std	Y+1, r27	; 0x01
     fee:	a8 83       	st	Y, r26
  pqp->prev     = p;
     ff0:	b3 83       	std	Z+3, r27	; 0x03
     ff2:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     ffa:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     ffc:	eb 85       	ldd	r30, Y+11	; 0x0b
     ffe:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    1000:	01 90       	ld	r0, Z+
    1002:	f0 81       	ld	r31, Z
    1004:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
    1006:	94 81       	ldd	r25, Z+4	; 0x04
    1008:	89 17       	cp	r24, r25
    100a:	d0 f3       	brcs	.-12     	; 0x1000 <chSchWakeupS+0x62>
    100c:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
    100e:	f9 83       	std	Y+1, r31	; 0x01
    1010:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
    1012:	a2 81       	ldd	r26, Z+2	; 0x02
    1014:	b3 81       	ldd	r27, Z+3	; 0x03
    1016:	bb 83       	std	Y+3, r27	; 0x03
    1018:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
    101a:	cd 93       	st	X+, r28
    101c:	dc 93       	st	X, r29
  pqp->prev     = p;
    101e:	d3 83       	std	Z+3, r29	; 0x03
    1020:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
    1022:	21 e0       	ldi	r18, 0x01	; 1
    1024:	fc 01       	movw	r30, r24
    1026:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
    1028:	90 93 46 03 	sts	0x0346, r25	; 0x800346 <ch0+0x6>
    102c:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    1030:	be 01       	movw	r22, r28
    1032:	bd d2       	rcall	.+1402   	; 0x15ae <_port_switch>
  }
}
    1034:	df 91       	pop	r29
    1036:	cf 91       	pop	r28
    1038:	08 95       	ret

0000103a <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
    103a:	a0 91 40 03 	lds	r26, 0x0340	; 0x800340 <ch0>
    103e:	b0 91 41 03 	lds	r27, 0x0341	; 0x800341 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
    1042:	e0 91 45 03 	lds	r30, 0x0345	; 0x800345 <ch0+0x5>
    1046:	f0 91 46 03 	lds	r31, 0x0346	; 0x800346 <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	14 96       	adiw	r26, 0x04	; 4
    104e:	2c 91       	ld	r18, X
    1050:	94 81       	ldd	r25, Z+4	; 0x04
    1052:	92 17       	cp	r25, r18
    1054:	08 f0       	brcs	.+2      	; 0x1058 <chSchIsPreemptionRequired+0x1e>
    1056:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
    1058:	08 95       	ret

0000105a <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
    105e:	a0 91 45 03 	lds	r26, 0x0345	; 0x800345 <ch0+0x5>
    1062:	b0 91 46 03 	lds	r27, 0x0346	; 0x800346 <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
    1066:	40 91 40 03 	lds	r20, 0x0340	; 0x800340 <ch0>
    106a:	50 91 41 03 	lds	r21, 0x0341	; 0x800341 <ch0+0x1>

  pqp->next       = p->next;
    106e:	ea 01       	movw	r28, r20
    1070:	e8 81       	ld	r30, Y
    1072:	f9 81       	ldd	r31, Y+1	; 0x01
    1074:	f0 93 41 03 	sts	0x0341, r31	; 0x800341 <ch0+0x1>
    1078:	e0 93 40 03 	sts	0x0340, r30	; 0x800340 <ch0>
  pqp->next->prev = pqp;
    107c:	80 e4       	ldi	r24, 0x40	; 64
    107e:	93 e0       	ldi	r25, 0x03	; 3
    1080:	93 83       	std	Z+3, r25	; 0x03
    1082:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
    1084:	81 e0       	ldi	r24, 0x01	; 1
    1086:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
    1088:	50 93 46 03 	sts	0x0346, r21	; 0x800346 <ch0+0x6>
    108c:	40 93 45 03 	sts	0x0345, r20	; 0x800345 <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
    1090:	1f 96       	adiw	r26, 0x0f	; 15
    1092:	1c 92       	st	X, r1
    1094:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
    1096:	1b 96       	adiw	r26, 0x0b	; 11
    1098:	ed 91       	ld	r30, X+
    109a:	fc 91       	ld	r31, X
    109c:	1c 97       	sbiw	r26, 0x0c	; 12
    109e:	14 96       	adiw	r26, 0x04	; 4
    10a0:	2c 91       	ld	r18, X
    10a2:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
    10a4:	01 90       	ld	r0, Z+
    10a6:	f0 81       	ld	r31, Z
    10a8:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
    10aa:	94 81       	ldd	r25, Z+4	; 0x04
    10ac:	29 17       	cp	r18, r25
    10ae:	d0 f3       	brcs	.-12     	; 0x10a4 <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
    10b0:	11 96       	adiw	r26, 0x01	; 1
    10b2:	fc 93       	st	X, r31
    10b4:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
    10b6:	82 81       	ldd	r24, Z+2	; 0x02
    10b8:	93 81       	ldd	r25, Z+3	; 0x03
    10ba:	13 96       	adiw	r26, 0x03	; 3
    10bc:	9c 93       	st	X, r25
    10be:	8e 93       	st	-X, r24
    10c0:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
    10c2:	ec 01       	movw	r28, r24
    10c4:	b9 83       	std	Y+1, r27	; 0x01
    10c6:	a8 83       	st	Y, r26
  pqp->prev     = p;
    10c8:	b3 83       	std	Z+3, r27	; 0x03
    10ca:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
    10cc:	bd 01       	movw	r22, r26
    10ce:	ca 01       	movw	r24, r20
    10d0:	6e d2       	rcall	.+1244   	; 0x15ae <_port_switch>
}
    10d2:	df 91       	pop	r29
    10d4:	cf 91       	pop	r28
    10d6:	08 95       	ret

000010d8 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
    10d8:	ff cf       	rjmp	.-2      	; 0x10d8 <__idle_thread>

000010da <chInstanceObjectInit>:
 * @param[in] oicp      pointer to an @p os_instance_config_t object
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
    10da:	cf 92       	push	r12
    10dc:	df 92       	push	r13
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	2b 97       	sbiw	r28, 0x0b	; 11
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	8c 01       	movw	r16, r24
    10fa:	6b 01       	movw	r12, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
    10fc:	90 93 3f 03 	sts	0x033F, r25	; 0x80033f <ch_system+0x2>
    1100:	80 93 3e 03 	sts	0x033E, r24	; 0x80033e <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
    1104:	fc 01       	movw	r30, r24
    1106:	16 8e       	std	Z+30, r1	; 0x1e
    1108:	15 8e       	std	Z+29, r1	; 0x1d

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
    110a:	74 a3       	std	Z+36, r23	; 0x24
    110c:	63 a3       	std	Z+35, r22	; 0x23

  /* Port initialization for the current instance.*/
  port_init(oip);
    110e:	ff 24       	eor	r15, r15
    1110:	f3 94       	inc	r15
    1112:	f0 92 89 03 	sts	0x0389, r15	; 0x800389 <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
    1116:	91 83       	std	Z+1, r25	; 0x01
    1118:	80 83       	st	Z, r24
  pqp->prev = pqp;
    111a:	93 83       	std	Z+3, r25	; 0x03
    111c:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
    111e:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
    1120:	49 96       	adiw	r24, 0x19	; 25
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
    1122:	92 8f       	std	Z+26, r25	; 0x1a
    1124:	81 8f       	std	Z+25, r24	; 0x19
  qp->prev = qp;
    1126:	94 8f       	std	Z+28, r25	; 0x1c
    1128:	83 8f       	std	Z+27, r24	; 0x1b
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
    112a:	17 8e       	std	Z+31, r1	; 0x1f
    112c:	10 a2       	std	Z+32, r1	; 0x20
    112e:	11 a2       	std	Z+33, r1	; 0x21
    1130:	12 a2       	std	Z+34, r1	; 0x22
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
    1132:	42 97       	sbiw	r24, 0x12	; 18
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
    1134:	90 87       	std	Z+8, r25	; 0x08
    1136:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
    1138:	92 87       	std	Z+10, r25	; 0x0a
    113a:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
    113c:	8f ef       	ldi	r24, 0xFF	; 255
    113e:	9f ef       	ldi	r25, 0xFF	; 255
    1140:	94 87       	std	Z+12, r25	; 0x0c
    1142:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
    1144:	16 86       	std	Z+14, r1	; 0x0e
    1146:	15 86       	std	Z+13, r1	; 0x0d
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    1148:	82 e0       	ldi	r24, 0x02	; 2
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	90 8b       	std	Z+16, r25	; 0x10
    114e:	87 87       	std	Z+15, r24	; 0x0f
    1150:	0e 94 6b 00 	call	0xd6	; 0xd6 <stGetCounter>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
    1154:	9c 01       	movw	r18, r24
    1156:	f8 01       	movw	r30, r16
    1158:	21 8b       	std	Z+17, r18	; 0x11
    115a:	32 8b       	std	Z+18, r19	; 0x12
    115c:	13 8a       	std	Z+19, r1	; 0x13
    115e:	14 8a       	std	Z+20, r1	; 0x14
    1160:	15 8a       	std	Z+21, r1	; 0x15
    1162:	16 8a       	std	Z+22, r1	; 0x16
    1164:	17 8a       	std	Z+23, r1	; 0x17
    1166:	10 8e       	std	Z+24, r1	; 0x18
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
    1168:	ed 5b       	subi	r30, 0xBD	; 189
    116a:	ff 4f       	sbci	r31, 0xFF	; 255
    116c:	11 82       	std	Z+1, r1	; 0x01
    116e:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
    1170:	b8 01       	movw	r22, r16
    1172:	6b 5d       	subi	r22, 0xDB	; 219
    1174:	7f 4f       	sbci	r23, 0xFF	; 255
    1176:	20 e8       	ldi	r18, 0x80	; 128
    1178:	42 e3       	ldi	r20, 0x32	; 50
    117a:	51 e0       	ldi	r21, 0x01	; 1
    117c:	c8 01       	movw	r24, r16
    117e:	2a d0       	rcall	.+84     	; 0x11d4 <__thd_object_init>
    1180:	f8 01       	movw	r30, r16
    1182:	96 83       	std	Z+6, r25	; 0x06
    1184:	85 83       	std	Z+5, r24	; 0x05
  oip->rlist.current->wabase = oicp->mainthread_base;
  oip->rlist.current->waend  = oicp->mainthread_end;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
    1186:	fc 01       	movw	r30, r24
    1188:	f7 86       	std	Z+15, r15	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
    118a:	86 e2       	ldi	r24, 0x26	; 38
    118c:	91 e0       	ldi	r25, 0x01	; 1
    118e:	9a 83       	std	Y+2, r25	; 0x02
    1190:	89 83       	std	Y+1, r24	; 0x01
    1192:	f6 01       	movw	r30, r12
    1194:	82 81       	ldd	r24, Z+2	; 0x02
    1196:	93 81       	ldd	r25, Z+3	; 0x03
    1198:	9c 83       	std	Y+4, r25	; 0x04
    119a:	8b 83       	std	Y+3, r24	; 0x03
    119c:	84 81       	ldd	r24, Z+4	; 0x04
    119e:	95 81       	ldd	r25, Z+5	; 0x05
    11a0:	9e 83       	std	Y+6, r25	; 0x06
    11a2:	8d 83       	std	Y+5, r24	; 0x05
    11a4:	ff 82       	std	Y+7, r15	; 0x07
    11a6:	8c e6       	ldi	r24, 0x6C	; 108
    11a8:	98 e0       	ldi	r25, 0x08	; 8
    11aa:	99 87       	std	Y+9, r25	; 0x09
    11ac:	88 87       	std	Y+8, r24	; 0x08
    11ae:	1b 86       	std	Y+11, r1	; 0x0b
    11b0:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
    11b2:	ce 01       	movw	r24, r28
    11b4:	01 96       	adiw	r24, 0x01	; 1
    11b6:	9e d0       	rcall	.+316    	; 0x12f4 <chThdCreateI>
  }
#endif
}
    11b8:	2b 96       	adiw	r28, 0x0b	; 11
    11ba:	0f b6       	in	r0, 0x3f	; 63
    11bc:	f8 94       	cli
    11be:	de bf       	out	0x3e, r29	; 62
    11c0:	0f be       	out	0x3f, r0	; 63
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	1f 91       	pop	r17
    11ca:	0f 91       	pop	r16
    11cc:	ff 90       	pop	r15
    11ce:	df 90       	pop	r13
    11d0:	cf 90       	pop	r12
    11d2:	08 95       	ret

000011d4 <__thd_object_init>:
 *
 * @param[in] tqp       pointer to a @p threads_queue_t object
 *
 * @dispose
 */
void chThdQueueObjectDispose(threads_queue_t *tqp) {
    11d4:	cf 93       	push	r28
    11d6:	df 93       	push	r29
    11d8:	fb 01       	movw	r30, r22
    11da:	24 83       	std	Z+4, r18	; 0x04
    11dc:	32 e0       	ldi	r19, 0x02	; 2
    11de:	37 87       	std	Z+15, r19	; 0x0f
    11e0:	10 8a       	std	Z+16, r1	; 0x10
    11e2:	94 87       	std	Z+12, r25	; 0x0c
    11e4:	83 87       	std	Z+11, r24	; 0x0b
    11e6:	25 8f       	std	Z+29, r18	; 0x1d
    11e8:	14 8e       	std	Z+28, r1	; 0x1c
    11ea:	13 8e       	std	Z+27, r1	; 0x1b
    11ec:	12 8e       	std	Z+26, r1	; 0x1a
    11ee:	21 e0       	ldi	r18, 0x01	; 1
    11f0:	21 8b       	std	Z+17, r18	; 0x11
    11f2:	56 87       	std	Z+14, r21	; 0x0e
    11f4:	45 87       	std	Z+13, r20	; 0x0d
    11f6:	9b 01       	movw	r18, r22
    11f8:	29 5f       	subi	r18, 0xF9	; 249
    11fa:	3f 4f       	sbci	r19, 0xFF	; 255
    11fc:	ac 01       	movw	r20, r24
    11fe:	47 5e       	subi	r20, 0xE7	; 231
    1200:	5f 4f       	sbci	r21, 0xFF	; 255
    1202:	50 87       	std	Z+8, r21	; 0x08
    1204:	47 83       	std	Z+7, r20	; 0x07
    1206:	ec 01       	movw	r28, r24
    1208:	ab 8d       	ldd	r26, Y+27	; 0x1b
    120a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    120c:	b2 87       	std	Z+10, r27	; 0x0a
    120e:	a1 87       	std	Z+9, r26	; 0x09
    1210:	2d 93       	st	X+, r18
    1212:	3c 93       	st	X, r19
    1214:	3c 8f       	std	Y+28, r19	; 0x1c
    1216:	2b 8f       	std	Y+27, r18	; 0x1b
    1218:	cb 01       	movw	r24, r22
    121a:	44 96       	adiw	r24, 0x14	; 20
    121c:	95 8b       	std	Z+21, r25	; 0x15
    121e:	84 8b       	std	Z+20, r24	; 0x14
    1220:	02 96       	adiw	r24, 0x02	; 2
    1222:	97 8b       	std	Z+23, r25	; 0x17
    1224:	86 8b       	std	Z+22, r24	; 0x16
    1226:	91 8f       	std	Z+25, r25	; 0x19
    1228:	80 8f       	std	Z+24, r24	; 0x18
    122a:	cb 01       	movw	r24, r22
    122c:	df 91       	pop	r29
    122e:	cf 91       	pop	r28
    1230:	08 95       	ret

00001232 <chThdCreateSuspendedI>:
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	dc 01       	movw	r26, r24
    1238:	14 96       	adiw	r26, 0x04	; 4
    123a:	2d 91       	ld	r18, X+
    123c:	3c 91       	ld	r19, X
    123e:	15 97       	sbiw	r26, 0x05	; 5
    1240:	f9 01       	movw	r30, r18
    1242:	7e 97       	sbiw	r30, 0x1e	; 30
    1244:	e9 01       	movw	r28, r18
    1246:	e3 97       	sbiw	r28, 0x33	; 51
    1248:	d6 83       	std	Z+6, r29	; 0x06
    124a:	c5 83       	std	Z+5, r28	; 0x05
    124c:	17 96       	adiw	r26, 0x07	; 7
    124e:	8c 91       	ld	r24, X
    1250:	17 97       	sbiw	r26, 0x07	; 7
    1252:	8a 8b       	std	Y+18, r24	; 0x12
    1254:	18 96       	adiw	r26, 0x08	; 8
    1256:	8c 91       	ld	r24, X
    1258:	18 97       	sbiw	r26, 0x08	; 8
    125a:	89 8b       	std	Y+17, r24	; 0x11
    125c:	19 96       	adiw	r26, 0x09	; 9
    125e:	8c 91       	ld	r24, X
    1260:	19 97       	sbiw	r26, 0x09	; 9
    1262:	88 8b       	std	Y+16, r24	; 0x10
    1264:	1a 96       	adiw	r26, 0x0a	; 10
    1266:	8c 91       	ld	r24, X
    1268:	1a 97       	sbiw	r26, 0x0a	; 10
    126a:	8f 87       	std	Y+15, r24	; 0x0f
    126c:	86 e0       	ldi	r24, 0x06	; 6
    126e:	9b e0       	ldi	r25, 0x0B	; 11
    1270:	9b 8b       	std	Y+19, r25	; 0x13
    1272:	8c 8b       	std	Y+20, r24	; 0x14
    1274:	16 96       	adiw	r26, 0x06	; 6
    1276:	8c 91       	ld	r24, X
    1278:	16 97       	sbiw	r26, 0x06	; 6
    127a:	4d 91       	ld	r20, X+
    127c:	5c 91       	ld	r21, X
    127e:	84 83       	std	Z+4, r24	; 0x04
    1280:	92 e0       	ldi	r25, 0x02	; 2
    1282:	97 87       	std	Z+15, r25	; 0x0f
    1284:	10 8a       	std	Z+16, r1	; 0x10
    1286:	60 e4       	ldi	r22, 0x40	; 64
    1288:	73 e0       	ldi	r23, 0x03	; 3
    128a:	74 87       	std	Z+12, r23	; 0x0c
    128c:	63 87       	std	Z+11, r22	; 0x0b
    128e:	85 8f       	std	Z+29, r24	; 0x1d
    1290:	14 8e       	std	Z+28, r1	; 0x1c
    1292:	13 8e       	std	Z+27, r1	; 0x1b
    1294:	12 8e       	std	Z+26, r1	; 0x1a
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	81 8b       	std	Z+17, r24	; 0x11
    129a:	56 87       	std	Z+14, r21	; 0x0e
    129c:	45 87       	std	Z+13, r20	; 0x0d
    129e:	d9 01       	movw	r26, r18
    12a0:	57 97       	sbiw	r26, 0x17	; 23
    12a2:	89 e5       	ldi	r24, 0x59	; 89
    12a4:	93 e0       	ldi	r25, 0x03	; 3
    12a6:	11 96       	adiw	r26, 0x01	; 1
    12a8:	9c 93       	st	X, r25
    12aa:	8e 93       	st	-X, r24
    12ac:	eb 01       	movw	r28, r22
    12ae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12b0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    12b2:	13 96       	adiw	r26, 0x03	; 3
    12b4:	9c 93       	st	X, r25
    12b6:	8e 93       	st	-X, r24
    12b8:	12 97       	sbiw	r26, 0x02	; 2
    12ba:	ec 01       	movw	r28, r24
    12bc:	b9 83       	std	Y+1, r27	; 0x01
    12be:	a8 83       	st	Y, r26
    12c0:	eb 01       	movw	r28, r22
    12c2:	bc 8f       	std	Y+28, r27	; 0x1c
    12c4:	ab 8f       	std	Y+27, r26	; 0x1b
    12c6:	1d 96       	adiw	r26, 0x0d	; 13
    12c8:	0b 2e       	mov	r0, r27
    12ca:	11 96       	adiw	r26, 0x01	; 1
    12cc:	0c 92       	st	X, r0
    12ce:	11 97       	sbiw	r26, 0x01	; 1
    12d0:	ac 93       	st	X, r26
    12d2:	12 96       	adiw	r26, 0x02	; 2
    12d4:	0b 2e       	mov	r0, r27
    12d6:	11 96       	adiw	r26, 0x01	; 1
    12d8:	0c 92       	st	X, r0
    12da:	11 97       	sbiw	r26, 0x01	; 1
    12dc:	ac 93       	st	X, r26
    12de:	0a 2e       	mov	r0, r26
    12e0:	1b 2e       	mov	r1, r27
    12e2:	13 96       	adiw	r26, 0x03	; 3
    12e4:	1c 92       	st	X, r1
    12e6:	0e 92       	st	-X, r0
    12e8:	11 24       	eor	r1, r1
    12ea:	12 97       	sbiw	r26, 0x02	; 2
    12ec:	cf 01       	movw	r24, r30
    12ee:	df 91       	pop	r29
    12f0:	cf 91       	pop	r28
    12f2:	08 95       	ret

000012f4 <chThdCreateI>:
    12f4:	9e df       	rcall	.-196    	; 0x1232 <chThdCreateSuspendedI>
    12f6:	dc cd       	rjmp	.-1096   	; 0xeb0 <chSchReadyI>

000012f8 <chThdCreateStatic>:
    12f8:	0f 93       	push	r16
    12fa:	1f 93       	push	r17
    12fc:	cf 93       	push	r28
    12fe:	df 93       	push	r29
    1300:	f8 94       	cli
    1302:	6e 51       	subi	r22, 0x1E	; 30
    1304:	71 09       	sbc	r23, r1
    1306:	ec 01       	movw	r28, r24
    1308:	c6 0f       	add	r28, r22
    130a:	d7 1f       	adc	r29, r23
    130c:	fe 01       	movw	r30, r28
    130e:	75 97       	sbiw	r30, 0x15	; 21
    1310:	fe 83       	std	Y+6, r31	; 0x06
    1312:	ed 83       	std	Y+5, r30	; 0x05
    1314:	22 8b       	std	Z+18, r18	; 0x12
    1316:	31 8b       	std	Z+17, r19	; 0x11
    1318:	00 8b       	std	Z+16, r16	; 0x10
    131a:	17 87       	std	Z+15, r17	; 0x0f
    131c:	86 e0       	ldi	r24, 0x06	; 6
    131e:	9b e0       	ldi	r25, 0x0B	; 11
    1320:	93 8b       	std	Z+19, r25	; 0x13
    1322:	84 8b       	std	Z+20, r24	; 0x14
    1324:	4c 83       	std	Y+4, r20	; 0x04
    1326:	82 e0       	ldi	r24, 0x02	; 2
    1328:	8f 87       	std	Y+15, r24	; 0x0f
    132a:	18 8a       	std	Y+16, r1	; 0x10
    132c:	e0 e4       	ldi	r30, 0x40	; 64
    132e:	f3 e0       	ldi	r31, 0x03	; 3
    1330:	fc 87       	std	Y+12, r31	; 0x0c
    1332:	eb 87       	std	Y+11, r30	; 0x0b
    1334:	4d 8f       	std	Y+29, r20	; 0x1d
    1336:	1c 8e       	std	Y+28, r1	; 0x1c
    1338:	1b 8e       	std	Y+27, r1	; 0x1b
    133a:	1a 8e       	std	Y+26, r1	; 0x1a
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	89 8b       	std	Y+17, r24	; 0x11
    1340:	8b e2       	ldi	r24, 0x2B	; 43
    1342:	91 e0       	ldi	r25, 0x01	; 1
    1344:	9e 87       	std	Y+14, r25	; 0x0e
    1346:	8d 87       	std	Y+13, r24	; 0x0d
    1348:	ce 01       	movw	r24, r28
    134a:	07 96       	adiw	r24, 0x07	; 7
    134c:	29 e5       	ldi	r18, 0x59	; 89
    134e:	33 e0       	ldi	r19, 0x03	; 3
    1350:	38 87       	std	Y+8, r19	; 0x08
    1352:	2f 83       	std	Y+7, r18	; 0x07
    1354:	a3 8d       	ldd	r26, Z+27	; 0x1b
    1356:	b4 8d       	ldd	r27, Z+28	; 0x1c
    1358:	ba 87       	std	Y+10, r27	; 0x0a
    135a:	a9 87       	std	Y+9, r26	; 0x09
    135c:	8d 93       	st	X+, r24
    135e:	9c 93       	st	X, r25
    1360:	94 8f       	std	Z+28, r25	; 0x1c
    1362:	83 8f       	std	Z+27, r24	; 0x1b
    1364:	0d 96       	adiw	r24, 0x0d	; 13
    1366:	9d 8b       	std	Y+21, r25	; 0x15
    1368:	8c 8b       	std	Y+20, r24	; 0x14
    136a:	02 96       	adiw	r24, 0x02	; 2
    136c:	9f 8b       	std	Y+23, r25	; 0x17
    136e:	8e 8b       	std	Y+22, r24	; 0x16
    1370:	99 8f       	std	Y+25, r25	; 0x19
    1372:	88 8f       	std	Y+24, r24	; 0x18
    1374:	60 e0       	ldi	r22, 0x00	; 0
    1376:	70 e0       	ldi	r23, 0x00	; 0
    1378:	ce 01       	movw	r24, r28
    137a:	11 de       	rcall	.-990    	; 0xf9e <chSchWakeupS>
    137c:	78 94       	sei
    137e:	ce 01       	movw	r24, r28
    1380:	df 91       	pop	r29
    1382:	cf 91       	pop	r28
    1384:	1f 91       	pop	r17
    1386:	0f 91       	pop	r16
    1388:	08 95       	ret

0000138a <chThdExitS>:
    138a:	0f 93       	push	r16
    138c:	1f 93       	push	r17
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	c0 91 45 03 	lds	r28, 0x0345	; 0x800345 <ch0+0x5>
    1396:	d0 91 46 03 	lds	r29, 0x0346	; 0x800346 <ch0+0x6>
    139a:	9b 8b       	std	Y+19, r25	; 0x13
    139c:	8a 8b       	std	Y+18, r24	; 0x12
    139e:	8e 01       	movw	r16, r28
    13a0:	0c 5e       	subi	r16, 0xEC	; 236
    13a2:	1f 4f       	sbci	r17, 0xFF	; 255
    13a4:	8c 89       	ldd	r24, Y+20	; 0x14
    13a6:	9d 89       	ldd	r25, Y+21	; 0x15
    13a8:	08 17       	cp	r16, r24
    13aa:	19 07       	cpc	r17, r25
    13ac:	59 f0       	breq	.+22     	; 0x13c4 <chThdExitS+0x3a>
    13ae:	fc 01       	movw	r30, r24
    13b0:	20 81       	ld	r18, Z
    13b2:	31 81       	ldd	r19, Z+1	; 0x01
    13b4:	3d 8b       	std	Y+21, r19	; 0x15
    13b6:	2c 8b       	std	Y+20, r18	; 0x14
    13b8:	7b dd       	rcall	.-1290   	; 0xeb0 <chSchReadyI>
    13ba:	8c 89       	ldd	r24, Y+20	; 0x14
    13bc:	9d 89       	ldd	r25, Y+21	; 0x15
    13be:	80 17       	cp	r24, r16
    13c0:	91 07       	cpc	r25, r17
    13c2:	a9 f7       	brne	.-22     	; 0x13ae <chThdExitS+0x24>
    13c4:	89 89       	ldd	r24, Y+17	; 0x11
    13c6:	81 11       	cpse	r24, r1
    13c8:	0c c0       	rjmp	.+24     	; 0x13e2 <chThdExitS+0x58>
    13ca:	e9 85       	ldd	r30, Y+9	; 0x09
    13cc:	fa 85       	ldd	r31, Y+10	; 0x0a
    13ce:	8f 81       	ldd	r24, Y+7	; 0x07
    13d0:	98 85       	ldd	r25, Y+8	; 0x08
    13d2:	91 83       	std	Z+1, r25	; 0x01
    13d4:	80 83       	st	Z, r24
    13d6:	af 81       	ldd	r26, Y+7	; 0x07
    13d8:	b8 85       	ldd	r27, Y+8	; 0x08
    13da:	13 96       	adiw	r26, 0x03	; 3
    13dc:	fc 93       	st	X, r31
    13de:	ee 93       	st	-X, r30
    13e0:	12 97       	sbiw	r26, 0x02	; 2
    13e2:	8f e0       	ldi	r24, 0x0F	; 15
    13e4:	df 91       	pop	r29
    13e6:	cf 91       	pop	r28
    13e8:	1f 91       	pop	r17
    13ea:	0f 91       	pop	r16
    13ec:	85 cd       	rjmp	.-1270   	; 0xef8 <chSchGoSleepS>

000013ee <chThdExit>:
    13ee:	f8 94       	cli
    13f0:	cc cf       	rjmp	.-104    	; 0x138a <chThdExitS>

000013f2 <chThdSleep>:
    13f2:	f8 94       	cli
    13f4:	bc 01       	movw	r22, r24
    13f6:	88 e0       	ldi	r24, 0x08	; 8
    13f8:	9b dd       	rcall	.-1226   	; 0xf30 <chSchGoSleepTimeoutS>
    13fa:	78 94       	sei
    13fc:	08 95       	ret

000013fe <chThdQueueObjectInit>:
    13fe:	fc 01       	movw	r30, r24
    1400:	91 83       	std	Z+1, r25	; 0x01
    1402:	80 83       	st	Z, r24
    1404:	93 83       	std	Z+3, r25	; 0x03
    1406:	82 83       	std	Z+2, r24	; 0x02
    1408:	08 95       	ret

0000140a <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    140a:	cf 93       	push	r28
    140c:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    140e:	e0 91 45 03 	lds	r30, 0x0345	; 0x800345 <ch0+0x5>
    1412:	f0 91 46 03 	lds	r31, 0x0346	; 0x800346 <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    1416:	61 15       	cp	r22, r1
    1418:	71 05       	cpc	r23, r1
    141a:	79 f0       	breq	.+30     	; 0x143a <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    141c:	91 83       	std	Z+1, r25	; 0x01
    141e:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    1420:	ec 01       	movw	r28, r24
    1422:	aa 81       	ldd	r26, Y+2	; 0x02
    1424:	bb 81       	ldd	r27, Y+3	; 0x03
    1426:	b3 83       	std	Z+3, r27	; 0x03
    1428:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    142a:	ed 93       	st	X+, r30
    142c:	fc 93       	st	X, r31
  qp->prev      = p;
    142e:	fb 83       	std	Y+3, r31	; 0x03
    1430:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1432:	84 e0       	ldi	r24, 0x04	; 4
}
    1434:	df 91       	pop	r29
    1436:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    1438:	7b cd       	rjmp	.-1290   	; 0xf30 <chSchGoSleepTimeoutS>
}
    143a:	8f ef       	ldi	r24, 0xFF	; 255
    143c:	9f ef       	ldi	r25, 0xFF	; 255
    143e:	df 91       	pop	r29
    1440:	cf 91       	pop	r28
    1442:	08 95       	ret

00001444 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    144a:	80 81       	ld	r24, Z
    144c:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    144e:	e8 17       	cp	r30, r24
    1450:	f9 07       	cpc	r31, r25
    1452:	71 f0       	breq	.+28     	; 0x1470 <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    1454:	ec 01       	movw	r28, r24
    1456:	a8 81       	ld	r26, Y
    1458:	b9 81       	ldd	r27, Y+1	; 0x01
    145a:	b1 83       	std	Z+1, r27	; 0x01
    145c:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    145e:	13 96       	adiw	r26, 0x03	; 3
    1460:	fc 93       	st	X, r31
    1462:	ee 93       	st	-X, r30
    1464:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1466:	7b 8b       	std	Y+19, r23	; 0x13
    1468:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    146a:	df 91       	pop	r29
    146c:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    146e:	20 cd       	rjmp	.-1472   	; 0xeb0 <chSchReadyI>
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	08 95       	ret

00001476 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t object
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    1476:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
    1478:	91 83       	std	Z+1, r25	; 0x01
    147a:	80 83       	st	Z, r24
  qp->prev = qp;
    147c:	93 83       	std	Z+3, r25	; 0x03
    147e:	82 83       	std	Z+2, r24	; 0x02

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
    1480:	15 82       	std	Z+5, r1	; 0x05
    1482:	14 82       	std	Z+4, r1	; 0x04
    1484:	08 95       	ret

00001486 <chEvtObjectInit>:
    1486:	fc 01       	movw	r30, r24
    1488:	91 83       	std	Z+1, r25	; 0x01
    148a:	80 83       	st	Z, r24
    148c:	08 95       	ret

0000148e <chEvtSignalI>:
    148e:	fc 01       	movw	r30, r24
    1490:	92 8d       	ldd	r25, Z+26	; 0x1a
    1492:	69 2b       	or	r22, r25
    1494:	62 8f       	std	Z+26, r22	; 0x1a
    1496:	87 85       	ldd	r24, Z+15	; 0x0f
    1498:	8a 30       	cpi	r24, 0x0A	; 10
    149a:	59 f0       	breq	.+22     	; 0x14b2 <chEvtSignalI+0x24>
    149c:	8b 30       	cpi	r24, 0x0B	; 11
    149e:	09 f0       	breq	.+2      	; 0x14a2 <chEvtSignalI+0x14>
    14a0:	08 95       	ret
    14a2:	82 89       	ldd	r24, Z+18	; 0x12
    14a4:	68 23       	and	r22, r24
    14a6:	86 13       	cpse	r24, r22
    14a8:	fb cf       	rjmp	.-10     	; 0x14a0 <chEvtSignalI+0x12>
    14aa:	13 8a       	std	Z+19, r1	; 0x13
    14ac:	12 8a       	std	Z+18, r1	; 0x12
    14ae:	cf 01       	movw	r24, r30
    14b0:	ff cc       	rjmp	.-1538   	; 0xeb0 <chSchReadyI>
    14b2:	82 89       	ldd	r24, Z+18	; 0x12
    14b4:	68 23       	and	r22, r24
    14b6:	c9 f7       	brne	.-14     	; 0x14aa <chEvtSignalI+0x1c>
    14b8:	08 95       	ret

000014ba <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    14ba:	ef 92       	push	r14
    14bc:	ff 92       	push	r15
    14be:	1f 93       	push	r17
    14c0:	cf 93       	push	r28
    14c2:	df 93       	push	r29
    14c4:	7c 01       	movw	r14, r24
    14c6:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    14c8:	fc 01       	movw	r30, r24
    14ca:	c0 81       	ld	r28, Z
    14cc:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    14ce:	8c 17       	cp	r24, r28
    14d0:	9d 07       	cpc	r25, r29
    14d2:	91 f0       	breq	.+36     	; 0x14f8 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    14d4:	8d 81       	ldd	r24, Y+5	; 0x05
    14d6:	81 2b       	or	r24, r17
    14d8:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    14da:	11 23       	and	r17, r17
    14dc:	19 f0       	breq	.+6      	; 0x14e4 <chEvtBroadcastFlagsI+0x2a>
    14de:	8e 81       	ldd	r24, Y+6	; 0x06
    14e0:	81 23       	and	r24, r17
    14e2:	21 f0       	breq	.+8      	; 0x14ec <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    14e4:	6c 81       	ldd	r22, Y+4	; 0x04
    14e6:	8a 81       	ldd	r24, Y+2	; 0x02
    14e8:	9b 81       	ldd	r25, Y+3	; 0x03
    14ea:	d1 df       	rcall	.-94     	; 0x148e <chEvtSignalI>
    }
    elp = elp->next;
    14ec:	09 90       	ld	r0, Y+
    14ee:	d8 81       	ld	r29, Y
    14f0:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    14f2:	ec 16       	cp	r14, r28
    14f4:	fd 06       	cpc	r15, r29
    14f6:	71 f7       	brne	.-36     	; 0x14d4 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	ff 90       	pop	r15
    1500:	ef 90       	pop	r14
    1502:	08 95       	ret

00001504 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    1504:	e5 e8       	ldi	r30, 0x85	; 133
    1506:	f3 e0       	ldi	r31, 0x03	; 3
    1508:	8f ed       	ldi	r24, 0xDF	; 223
    150a:	91 e0       	ldi	r25, 0x01	; 1
    150c:	91 83       	std	Z+1, r25	; 0x01
    150e:	80 83       	st	Z, r24
    1510:	8f e5       	ldi	r24, 0x5F	; 95
    1512:	92 e0       	ldi	r25, 0x02	; 2
    1514:	93 83       	std	Z+3, r25	; 0x03
    1516:	82 83       	std	Z+2, r24	; 0x02
    1518:	08 95       	ret

0000151a <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    151a:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    151c:	20 91 87 03 	lds	r18, 0x0387	; 0x800387 <ch_memcore+0x2>
    1520:	30 91 88 03 	lds	r19, 0x0388	; 0x800388 <ch_memcore+0x3>
    1524:	f9 01       	movw	r30, r18
    1526:	e8 1b       	sub	r30, r24
    1528:	f9 0b       	sbc	r31, r25
    152a:	71 95       	neg	r23
    152c:	61 95       	neg	r22
    152e:	71 09       	sbc	r23, r1
    1530:	6e 23       	and	r22, r30
    1532:	7f 23       	and	r23, r31
  prev = p - offset;
    1534:	cb 01       	movw	r24, r22
    1536:	84 1b       	sub	r24, r20
    1538:	95 0b       	sbc	r25, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    153a:	40 91 85 03 	lds	r20, 0x0385	; 0x800385 <ch_memcore>
    153e:	50 91 86 03 	lds	r21, 0x0386	; 0x800386 <ch_memcore+0x1>
    1542:	84 17       	cp	r24, r20
    1544:	95 07       	cpc	r25, r21
    1546:	50 f0       	brcs	.+20     	; 0x155c <chCoreAllocFromTop+0x42>
    1548:	28 17       	cp	r18, r24
    154a:	39 07       	cpc	r19, r25
    154c:	38 f0       	brcs	.+14     	; 0x155c <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    154e:	90 93 88 03 	sts	0x0388, r25	; 0x800388 <ch_memcore+0x3>
    1552:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <ch_memcore+0x2>

  return p;
    1556:	cb 01       	movw	r24, r22
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1558:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    155a:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    155c:	80 e0       	ldi	r24, 0x00	; 0
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    1562:	08 95       	ret

00001564 <chCoreGetStatusX>:
 *
 * @xclass
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
    1564:	e5 e8       	ldi	r30, 0x85	; 133
    1566:	f3 e0       	ldi	r31, 0x03	; 3
    1568:	40 81       	ld	r20, Z
    156a:	51 81       	ldd	r21, Z+1	; 0x01
    156c:	dc 01       	movw	r26, r24
    156e:	11 96       	adiw	r26, 0x01	; 1
    1570:	5c 93       	st	X, r21
    1572:	4e 93       	st	-X, r20
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
    1574:	22 81       	ldd	r18, Z+2	; 0x02
    1576:	33 81       	ldd	r19, Z+3	; 0x03
    1578:	24 1b       	sub	r18, r20
    157a:	35 0b       	sbc	r19, r21
    157c:	13 96       	adiw	r26, 0x03	; 3
    157e:	3c 93       	st	X, r19
    1580:	2e 93       	st	-X, r18
    1582:	12 97       	sbiw	r26, 0x02	; 2
    1584:	08 95       	ret

00001586 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
    1586:	cf 93       	push	r28
    1588:	df 93       	push	r29

  default_heap.provider = chCoreAllocAlignedWithOffset;
    158a:	cf e5       	ldi	r28, 0x5F	; 95
    158c:	d2 e0       	ldi	r29, 0x02	; 2
    158e:	8d e8       	ldi	r24, 0x8D	; 141
    1590:	9a e0       	ldi	r25, 0x0A	; 10
    1592:	99 83       	std	Y+1, r25	; 0x01
    1594:	88 83       	st	Y, r24
  chCoreGetStatusX(&default_heap.area);
    1596:	81 e6       	ldi	r24, 0x61	; 97
    1598:	92 e0       	ldi	r25, 0x02	; 2
    159a:	e4 df       	rcall	.-56     	; 0x1564 <chCoreGetStatusX>
  H_FREE_NEXT(&default_heap.header) = NULL;
    159c:	1f 82       	std	Y+7, r1	; 0x07
    159e:	1e 82       	std	Y+6, r1	; 0x06
  H_FREE_PAGES(&default_heap.header) = 0;
    15a0:	19 86       	std	Y+9, r1	; 0x09
    15a2:	18 86       	std	Y+8, r1	; 0x08
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15a4:	89 e6       	ldi	r24, 0x69	; 105
    15a6:	92 e0       	ldi	r25, 0x02	; 2
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
    15a8:	df 91       	pop	r29
  default_heap.provider = chCoreAllocAlignedWithOffset;
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    15aa:	cf 91       	pop	r28
    15ac:	64 cf       	rjmp	.-312    	; 0x1476 <chMtxObjectInit>

000015ae <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    15ae:	2f 92       	push	r2
  asm volatile ("push    r3");
    15b0:	3f 92       	push	r3
  asm volatile ("push    r4");
    15b2:	4f 92       	push	r4
  asm volatile ("push    r5");
    15b4:	5f 92       	push	r5
  asm volatile ("push    r6");
    15b6:	6f 92       	push	r6
  asm volatile ("push    r7");
    15b8:	7f 92       	push	r7
  asm volatile ("push    r8");
    15ba:	8f 92       	push	r8
  asm volatile ("push    r9");
    15bc:	9f 92       	push	r9
  asm volatile ("push    r10");
    15be:	af 92       	push	r10
  asm volatile ("push    r11");
    15c0:	bf 92       	push	r11
  asm volatile ("push    r12");
    15c2:	cf 92       	push	r12
  asm volatile ("push    r13");
    15c4:	df 92       	push	r13
  asm volatile ("push    r14");
    15c6:	ef 92       	push	r14
  asm volatile ("push    r15");
    15c8:	ff 92       	push	r15
  asm volatile ("push    r16");
    15ca:	0f 93       	push	r16
  asm volatile ("push    r17");
    15cc:	1f 93       	push	r17
  asm volatile ("push    r28");
    15ce:	cf 93       	push	r28
  asm volatile ("push    r29");
    15d0:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    15d2:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    15d4:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    15d6:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    15d8:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    15da:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    15dc:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    15de:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    15e0:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    15e2:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    15e4:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    15e6:	df 91       	pop	r29
  asm volatile ("pop     r28");
    15e8:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    15ea:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    15ec:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    15ee:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    15f0:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    15f2:	df 90       	pop	r13
  asm volatile ("pop     r12");
    15f4:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    15f6:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    15f8:	af 90       	pop	r10
  asm volatile ("pop     r9");
    15fa:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    15fc:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    15fe:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    1600:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    1602:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    1604:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    1606:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    1608:	2f 90       	pop	r2
  asm volatile ("ret");
    160a:	08 95       	ret

0000160c <_port_thread_start>:
    160c:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    160e:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    1610:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    1612:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    1614:	ec ce       	rjmp	.-552    	; 0x13ee <chThdExit>

00001616 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    1616:	e0 91 45 03 	lds	r30, 0x0345	; 0x800345 <ch0+0x5>
    161a:	f0 91 46 03 	lds	r31, 0x0346	; 0x800346 <ch0+0x6>
    161e:	8d e5       	ldi	r24, 0x5D	; 93
    1620:	91 e0       	ldi	r25, 0x01	; 1
    1622:	96 87       	std	Z+14, r25	; 0x0e
    1624:	85 87       	std	Z+13, r24	; 0x0d
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("Blinker");
  while (true) {
    palTogglePad(IOPORT2, PORTB_LED1);
    1626:	c0 e2       	ldi	r28, 0x20	; 32
    1628:	85 b1       	in	r24, 0x05	; 5
    162a:	8c 27       	eor	r24, r28
    162c:	85 b9       	out	0x05, r24	; 5
    chThdSleepMilliseconds(1000);
    162e:	88 e0       	ldi	r24, 0x08	; 8
    1630:	9d e3       	ldi	r25, 0x3D	; 61
    1632:	df de       	rcall	.-578    	; 0x13f2 <chThdSleep>
    1634:	f9 cf       	rjmp	.-14     	; 0x1628 <Thread1+0x12>

00001636 <main>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    1636:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>
  chSysInit();
    163a:	7c d9       	rcall	.-3336   	; 0x934 <chSysInit>

  /*
   * Activates the serial driver 1 using the driver default configuration.
   */
  sdStart(&SD1, NULL);
    163c:	60 e0       	ldi	r22, 0x00	; 0
    163e:	70 e0       	ldi	r23, 0x00	; 0
    1640:	84 ef       	ldi	r24, 0xF4	; 244
    1642:	92 e0       	ldi	r25, 0x02	; 2
    1644:	24 d8       	rcall	.-4024   	; 0x68e <sdStart>

  /*
   * Starts the LED blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    1646:	00 e0       	ldi	r16, 0x00	; 0
    1648:	10 e0       	ldi	r17, 0x00	; 0
    164a:	2b e0       	ldi	r18, 0x0B	; 11
    164c:	3b e0       	ldi	r19, 0x0B	; 11
    164e:	40 e8       	ldi	r20, 0x80	; 128
    1650:	63 e8       	ldi	r22, 0x83	; 131
    1652:	70 e0       	ldi	r23, 0x00	; 0
    1654:	81 e7       	ldi	r24, 0x71	; 113
    1656:	92 e0       	ldi	r25, 0x02	; 2
    1658:	4f de       	rcall	.-866    	; 0x12f8 <chThdCreateStatic>

  chnWrite(&SD1, (const uint8_t *)"Hello World!\r\n", 14);
    165a:	e0 91 f4 02 	lds	r30, 0x02F4	; 0x8002f4 <SD1>
    165e:	f0 91 f5 02 	lds	r31, 0x02F5	; 0x8002f5 <SD1+0x1>
    1662:	02 80       	ldd	r0, Z+2	; 0x02
    1664:	f3 81       	ldd	r31, Z+3	; 0x03
    1666:	e0 2d       	mov	r30, r0
    1668:	4e e0       	ldi	r20, 0x0E	; 14
    166a:	50 e0       	ldi	r21, 0x00	; 0
    166c:	65 e6       	ldi	r22, 0x65	; 101
    166e:	71 e0       	ldi	r23, 0x01	; 1
    1670:	84 ef       	ldi	r24, 0xF4	; 244
    1672:	92 e0       	ldi	r25, 0x02	; 2
    1674:	09 95       	icall

  while (true) {
    chThdSleepMilliseconds(1000);
    1676:	88 e0       	ldi	r24, 0x08	; 8
    1678:	9d e3       	ldi	r25, 0x3D	; 61
    167a:	bb de       	rcall	.-650    	; 0x13f2 <chThdSleep>
    167c:	fc cf       	rjmp	.-8      	; 0x1676 <main+0x40>

0000167e <vfprintf>:
    167e:	ab e0       	ldi	r26, 0x0B	; 11
    1680:	b0 e0       	ldi	r27, 0x00	; 0
    1682:	e4 e4       	ldi	r30, 0x44	; 68
    1684:	fb e0       	ldi	r31, 0x0B	; 11
    1686:	d3 c2       	rjmp	.+1446   	; 0x1c2e <__prologue_saves__+0x8>
    1688:	6c 01       	movw	r12, r24
    168a:	7b 01       	movw	r14, r22
    168c:	3a 01       	movw	r6, r20
    168e:	fc 01       	movw	r30, r24
    1690:	17 82       	std	Z+7, r1	; 0x07
    1692:	16 82       	std	Z+6, r1	; 0x06
    1694:	83 81       	ldd	r24, Z+3	; 0x03
    1696:	81 ff       	sbrs	r24, 1
    1698:	f9 c0       	rjmp	.+498    	; 0x188c <vfprintf+0x20e>
    169a:	ce 01       	movw	r24, r28
    169c:	01 96       	adiw	r24, 0x01	; 1
    169e:	4c 01       	movw	r8, r24
    16a0:	f6 01       	movw	r30, r12
    16a2:	b3 80       	ldd	r11, Z+3	; 0x03
    16a4:	f7 01       	movw	r30, r14
    16a6:	b3 fc       	sbrc	r11, 3
    16a8:	05 91       	lpm	r16, Z+
    16aa:	b3 fe       	sbrs	r11, 3
    16ac:	01 91       	ld	r16, Z+
    16ae:	7f 01       	movw	r14, r30
    16b0:	00 23       	and	r16, r16
    16b2:	09 f4       	brne	.+2      	; 0x16b6 <vfprintf+0x38>
    16b4:	e7 c0       	rjmp	.+462    	; 0x1884 <vfprintf+0x206>
    16b6:	05 32       	cpi	r16, 0x25	; 37
    16b8:	49 f4       	brne	.+18     	; 0x16cc <vfprintf+0x4e>
    16ba:	b3 fc       	sbrc	r11, 3
    16bc:	05 91       	lpm	r16, Z+
    16be:	b3 fe       	sbrs	r11, 3
    16c0:	01 91       	ld	r16, Z+
    16c2:	7f 01       	movw	r14, r30
    16c4:	05 32       	cpi	r16, 0x25	; 37
    16c6:	11 f0       	breq	.+4      	; 0x16cc <vfprintf+0x4e>
    16c8:	10 e0       	ldi	r17, 0x00	; 0
    16ca:	17 c0       	rjmp	.+46     	; 0x16fa <vfprintf+0x7c>
    16cc:	b6 01       	movw	r22, r12
    16ce:	80 2f       	mov	r24, r16
    16d0:	90 e0       	ldi	r25, 0x00	; 0
    16d2:	3a d3       	rcall	.+1652   	; 0x1d48 <fputc>
    16d4:	53 01       	movw	r10, r6
    16d6:	35 01       	movw	r6, r10
    16d8:	e3 cf       	rjmp	.-58     	; 0x16a0 <vfprintf+0x22>
    16da:	00 23       	and	r16, r16
    16dc:	09 f4       	brne	.+2      	; 0x16e0 <vfprintf+0x62>
    16de:	d2 c0       	rjmp	.+420    	; 0x1884 <vfprintf+0x206>
    16e0:	60 2f       	mov	r22, r16
    16e2:	70 e0       	ldi	r23, 0x00	; 0
    16e4:	8f e6       	ldi	r24, 0x6F	; 111
    16e6:	90 e0       	ldi	r25, 0x00	; 0
    16e8:	dd d2       	rcall	.+1466   	; 0x1ca4 <strchr_P>
    16ea:	89 2b       	or	r24, r25
    16ec:	49 f0       	breq	.+18     	; 0x1700 <vfprintf+0x82>
    16ee:	f7 01       	movw	r30, r14
    16f0:	b3 fc       	sbrc	r11, 3
    16f2:	05 91       	lpm	r16, Z+
    16f4:	b3 fe       	sbrs	r11, 3
    16f6:	01 91       	ld	r16, Z+
    16f8:	7f 01       	movw	r14, r30
    16fa:	17 ff       	sbrs	r17, 7
    16fc:	ee cf       	rjmp	.-36     	; 0x16da <vfprintf+0x5c>
    16fe:	04 c0       	rjmp	.+8      	; 0x1708 <vfprintf+0x8a>
    1700:	03 32       	cpi	r16, 0x23	; 35
    1702:	39 f0       	breq	.+14     	; 0x1712 <vfprintf+0x94>
    1704:	0c 36       	cpi	r16, 0x6C	; 108
    1706:	19 f0       	breq	.+6      	; 0x170e <vfprintf+0x90>
    1708:	01 11       	cpse	r16, r1
    170a:	05 c0       	rjmp	.+10     	; 0x1716 <vfprintf+0x98>
    170c:	bb c0       	rjmp	.+374    	; 0x1884 <vfprintf+0x206>
    170e:	10 68       	ori	r17, 0x80	; 128
    1710:	ee cf       	rjmp	.-36     	; 0x16ee <vfprintf+0x70>
    1712:	10 e1       	ldi	r17, 0x10	; 16
    1714:	ec cf       	rjmp	.-40     	; 0x16ee <vfprintf+0x70>
    1716:	60 2f       	mov	r22, r16
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	88 e6       	ldi	r24, 0x68	; 104
    171c:	90 e0       	ldi	r25, 0x00	; 0
    171e:	c2 d2       	rcall	.+1412   	; 0x1ca4 <strchr_P>
    1720:	89 2b       	or	r24, r25
    1722:	41 f0       	breq	.+16     	; 0x1734 <vfprintf+0xb6>
    1724:	53 01       	movw	r10, r6
    1726:	f4 e0       	ldi	r31, 0x04	; 4
    1728:	af 0e       	add	r10, r31
    172a:	b1 1c       	adc	r11, r1
    172c:	b6 01       	movw	r22, r12
    172e:	8f e3       	ldi	r24, 0x3F	; 63
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	10 c0       	rjmp	.+32     	; 0x1754 <vfprintf+0xd6>
    1734:	03 36       	cpi	r16, 0x63	; 99
    1736:	31 f0       	breq	.+12     	; 0x1744 <vfprintf+0xc6>
    1738:	03 37       	cpi	r16, 0x73	; 115
    173a:	71 f0       	breq	.+28     	; 0x1758 <vfprintf+0xda>
    173c:	03 35       	cpi	r16, 0x53	; 83
    173e:	01 f5       	brne	.+64     	; 0x1780 <vfprintf+0x102>
    1740:	11 60       	ori	r17, 0x01	; 1
    1742:	0a c0       	rjmp	.+20     	; 0x1758 <vfprintf+0xda>
    1744:	53 01       	movw	r10, r6
    1746:	82 e0       	ldi	r24, 0x02	; 2
    1748:	a8 0e       	add	r10, r24
    174a:	b1 1c       	adc	r11, r1
    174c:	b6 01       	movw	r22, r12
    174e:	f3 01       	movw	r30, r6
    1750:	80 81       	ld	r24, Z
    1752:	91 81       	ldd	r25, Z+1	; 0x01
    1754:	f9 d2       	rcall	.+1522   	; 0x1d48 <fputc>
    1756:	bf cf       	rjmp	.-130    	; 0x16d6 <vfprintf+0x58>
    1758:	53 01       	movw	r10, r6
    175a:	f2 e0       	ldi	r31, 0x02	; 2
    175c:	af 0e       	add	r10, r31
    175e:	b1 1c       	adc	r11, r1
    1760:	f3 01       	movw	r30, r6
    1762:	60 80       	ld	r6, Z
    1764:	71 80       	ldd	r7, Z+1	; 0x01
    1766:	f3 01       	movw	r30, r6
    1768:	10 fd       	sbrc	r17, 0
    176a:	85 91       	lpm	r24, Z+
    176c:	10 ff       	sbrs	r17, 0
    176e:	81 91       	ld	r24, Z+
    1770:	3f 01       	movw	r6, r30
    1772:	88 23       	and	r24, r24
    1774:	09 f4       	brne	.+2      	; 0x1778 <vfprintf+0xfa>
    1776:	af cf       	rjmp	.-162    	; 0x16d6 <vfprintf+0x58>
    1778:	b6 01       	movw	r22, r12
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	e5 d2       	rcall	.+1482   	; 0x1d48 <fputc>
    177e:	f3 cf       	rjmp	.-26     	; 0x1766 <vfprintf+0xe8>
    1780:	04 36       	cpi	r16, 0x64	; 100
    1782:	11 f0       	breq	.+4      	; 0x1788 <vfprintf+0x10a>
    1784:	09 36       	cpi	r16, 0x69	; 105
    1786:	21 f5       	brne	.+72     	; 0x17d0 <vfprintf+0x152>
    1788:	53 01       	movw	r10, r6
    178a:	17 ff       	sbrs	r17, 7
    178c:	09 c0       	rjmp	.+18     	; 0x17a0 <vfprintf+0x122>
    178e:	f4 e0       	ldi	r31, 0x04	; 4
    1790:	af 0e       	add	r10, r31
    1792:	b1 1c       	adc	r11, r1
    1794:	f3 01       	movw	r30, r6
    1796:	60 81       	ld	r22, Z
    1798:	71 81       	ldd	r23, Z+1	; 0x01
    179a:	82 81       	ldd	r24, Z+2	; 0x02
    179c:	93 81       	ldd	r25, Z+3	; 0x03
    179e:	0a c0       	rjmp	.+20     	; 0x17b4 <vfprintf+0x136>
    17a0:	f2 e0       	ldi	r31, 0x02	; 2
    17a2:	af 0e       	add	r10, r31
    17a4:	b1 1c       	adc	r11, r1
    17a6:	f3 01       	movw	r30, r6
    17a8:	60 81       	ld	r22, Z
    17aa:	71 81       	ldd	r23, Z+1	; 0x01
    17ac:	07 2e       	mov	r0, r23
    17ae:	00 0c       	add	r0, r0
    17b0:	88 0b       	sbc	r24, r24
    17b2:	99 0b       	sbc	r25, r25
    17b4:	1f 7e       	andi	r17, 0xEF	; 239
    17b6:	97 ff       	sbrs	r25, 7
    17b8:	08 c0       	rjmp	.+16     	; 0x17ca <vfprintf+0x14c>
    17ba:	90 95       	com	r25
    17bc:	80 95       	com	r24
    17be:	70 95       	com	r23
    17c0:	61 95       	neg	r22
    17c2:	7f 4f       	sbci	r23, 0xFF	; 255
    17c4:	8f 4f       	sbci	r24, 0xFF	; 255
    17c6:	9f 4f       	sbci	r25, 0xFF	; 255
    17c8:	10 64       	ori	r17, 0x40	; 64
    17ca:	2a e0       	ldi	r18, 0x0A	; 10
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	30 c0       	rjmp	.+96     	; 0x1830 <vfprintf+0x1b2>
    17d0:	00 37       	cpi	r16, 0x70	; 112
    17d2:	91 f0       	breq	.+36     	; 0x17f8 <vfprintf+0x17a>
    17d4:	40 f4       	brcc	.+16     	; 0x17e6 <vfprintf+0x168>
    17d6:	08 35       	cpi	r16, 0x58	; 88
    17d8:	a1 f0       	breq	.+40     	; 0x1802 <vfprintf+0x184>
    17da:	0f 36       	cpi	r16, 0x6F	; 111
    17dc:	09 f0       	breq	.+2      	; 0x17e0 <vfprintf+0x162>
    17de:	52 c0       	rjmp	.+164    	; 0x1884 <vfprintf+0x206>
    17e0:	28 e0       	ldi	r18, 0x08	; 8
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	11 c0       	rjmp	.+34     	; 0x1808 <vfprintf+0x18a>
    17e6:	05 37       	cpi	r16, 0x75	; 117
    17e8:	19 f0       	breq	.+6      	; 0x17f0 <vfprintf+0x172>
    17ea:	08 37       	cpi	r16, 0x78	; 120
    17ec:	31 f0       	breq	.+12     	; 0x17fa <vfprintf+0x17c>
    17ee:	4a c0       	rjmp	.+148    	; 0x1884 <vfprintf+0x206>
    17f0:	1f 7e       	andi	r17, 0xEF	; 239
    17f2:	2a e0       	ldi	r18, 0x0A	; 10
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	08 c0       	rjmp	.+16     	; 0x1808 <vfprintf+0x18a>
    17f8:	10 61       	ori	r17, 0x10	; 16
    17fa:	14 62       	ori	r17, 0x24	; 36
    17fc:	20 e1       	ldi	r18, 0x10	; 16
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	03 c0       	rjmp	.+6      	; 0x1808 <vfprintf+0x18a>
    1802:	14 60       	ori	r17, 0x04	; 4
    1804:	20 e1       	ldi	r18, 0x10	; 16
    1806:	32 e0       	ldi	r19, 0x02	; 2
    1808:	53 01       	movw	r10, r6
    180a:	17 ff       	sbrs	r17, 7
    180c:	09 c0       	rjmp	.+18     	; 0x1820 <vfprintf+0x1a2>
    180e:	f4 e0       	ldi	r31, 0x04	; 4
    1810:	af 0e       	add	r10, r31
    1812:	b1 1c       	adc	r11, r1
    1814:	f3 01       	movw	r30, r6
    1816:	60 81       	ld	r22, Z
    1818:	71 81       	ldd	r23, Z+1	; 0x01
    181a:	82 81       	ldd	r24, Z+2	; 0x02
    181c:	93 81       	ldd	r25, Z+3	; 0x03
    181e:	08 c0       	rjmp	.+16     	; 0x1830 <vfprintf+0x1b2>
    1820:	f2 e0       	ldi	r31, 0x02	; 2
    1822:	af 0e       	add	r10, r31
    1824:	b1 1c       	adc	r11, r1
    1826:	f3 01       	movw	r30, r6
    1828:	60 81       	ld	r22, Z
    182a:	71 81       	ldd	r23, Z+1	; 0x01
    182c:	80 e0       	ldi	r24, 0x00	; 0
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	a4 01       	movw	r20, r8
    1832:	df d2       	rcall	.+1470   	; 0x1df2 <__ultoa_invert>
    1834:	08 2f       	mov	r16, r24
    1836:	08 19       	sub	r16, r8
    1838:	16 ff       	sbrs	r17, 6
    183a:	04 c0       	rjmp	.+8      	; 0x1844 <vfprintf+0x1c6>
    183c:	b6 01       	movw	r22, r12
    183e:	8d e2       	ldi	r24, 0x2D	; 45
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	82 d2       	rcall	.+1284   	; 0x1d48 <fputc>
    1844:	14 ff       	sbrs	r17, 4
    1846:	13 c0       	rjmp	.+38     	; 0x186e <vfprintf+0x1f0>
    1848:	fe 01       	movw	r30, r28
    184a:	e0 0f       	add	r30, r16
    184c:	f1 1d       	adc	r31, r1
    184e:	80 81       	ld	r24, Z
    1850:	80 33       	cpi	r24, 0x30	; 48
    1852:	69 f0       	breq	.+26     	; 0x186e <vfprintf+0x1f0>
    1854:	b6 01       	movw	r22, r12
    1856:	80 e3       	ldi	r24, 0x30	; 48
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	76 d2       	rcall	.+1260   	; 0x1d48 <fputc>
    185c:	12 ff       	sbrs	r17, 2
    185e:	07 c0       	rjmp	.+14     	; 0x186e <vfprintf+0x1f0>
    1860:	10 72       	andi	r17, 0x20	; 32
    1862:	81 2f       	mov	r24, r17
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	b6 01       	movw	r22, r12
    1868:	88 5a       	subi	r24, 0xA8	; 168
    186a:	9f 4f       	sbci	r25, 0xFF	; 255
    186c:	6d d2       	rcall	.+1242   	; 0x1d48 <fputc>
    186e:	01 50       	subi	r16, 0x01	; 1
    1870:	f4 01       	movw	r30, r8
    1872:	e0 0f       	add	r30, r16
    1874:	f1 1d       	adc	r31, r1
    1876:	80 81       	ld	r24, Z
    1878:	b6 01       	movw	r22, r12
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	65 d2       	rcall	.+1226   	; 0x1d48 <fputc>
    187e:	01 11       	cpse	r16, r1
    1880:	f6 cf       	rjmp	.-20     	; 0x186e <vfprintf+0x1f0>
    1882:	29 cf       	rjmp	.-430    	; 0x16d6 <vfprintf+0x58>
    1884:	f6 01       	movw	r30, r12
    1886:	86 81       	ldd	r24, Z+6	; 0x06
    1888:	97 81       	ldd	r25, Z+7	; 0x07
    188a:	02 c0       	rjmp	.+4      	; 0x1890 <vfprintf+0x212>
    188c:	8f ef       	ldi	r24, 0xFF	; 255
    188e:	9f ef       	ldi	r25, 0xFF	; 255
    1890:	2b 96       	adiw	r28, 0x0b	; 11
    1892:	ee e0       	ldi	r30, 0x0E	; 14
    1894:	e8 c1       	rjmp	.+976    	; 0x1c66 <__epilogue_restores__+0x8>

00001896 <putval>:
    1896:	20 fd       	sbrc	r18, 0
    1898:	09 c0       	rjmp	.+18     	; 0x18ac <putval+0x16>
    189a:	fc 01       	movw	r30, r24
    189c:	23 fd       	sbrc	r18, 3
    189e:	05 c0       	rjmp	.+10     	; 0x18aa <putval+0x14>
    18a0:	22 ff       	sbrs	r18, 2
    18a2:	02 c0       	rjmp	.+4      	; 0x18a8 <putval+0x12>
    18a4:	73 83       	std	Z+3, r23	; 0x03
    18a6:	62 83       	std	Z+2, r22	; 0x02
    18a8:	51 83       	std	Z+1, r21	; 0x01
    18aa:	40 83       	st	Z, r20
    18ac:	08 95       	ret

000018ae <mulacc>:
    18ae:	44 fd       	sbrc	r20, 4
    18b0:	17 c0       	rjmp	.+46     	; 0x18e0 <mulacc+0x32>
    18b2:	46 fd       	sbrc	r20, 6
    18b4:	17 c0       	rjmp	.+46     	; 0x18e4 <mulacc+0x36>
    18b6:	ab 01       	movw	r20, r22
    18b8:	bc 01       	movw	r22, r24
    18ba:	da 01       	movw	r26, r20
    18bc:	fb 01       	movw	r30, r22
    18be:	aa 0f       	add	r26, r26
    18c0:	bb 1f       	adc	r27, r27
    18c2:	ee 1f       	adc	r30, r30
    18c4:	ff 1f       	adc	r31, r31
    18c6:	10 94       	com	r1
    18c8:	d1 f7       	brne	.-12     	; 0x18be <mulacc+0x10>
    18ca:	4a 0f       	add	r20, r26
    18cc:	5b 1f       	adc	r21, r27
    18ce:	6e 1f       	adc	r22, r30
    18d0:	7f 1f       	adc	r23, r31
    18d2:	cb 01       	movw	r24, r22
    18d4:	ba 01       	movw	r22, r20
    18d6:	66 0f       	add	r22, r22
    18d8:	77 1f       	adc	r23, r23
    18da:	88 1f       	adc	r24, r24
    18dc:	99 1f       	adc	r25, r25
    18de:	09 c0       	rjmp	.+18     	; 0x18f2 <mulacc+0x44>
    18e0:	33 e0       	ldi	r19, 0x03	; 3
    18e2:	01 c0       	rjmp	.+2      	; 0x18e6 <mulacc+0x38>
    18e4:	34 e0       	ldi	r19, 0x04	; 4
    18e6:	66 0f       	add	r22, r22
    18e8:	77 1f       	adc	r23, r23
    18ea:	88 1f       	adc	r24, r24
    18ec:	99 1f       	adc	r25, r25
    18ee:	31 50       	subi	r19, 0x01	; 1
    18f0:	d1 f7       	brne	.-12     	; 0x18e6 <mulacc+0x38>
    18f2:	62 0f       	add	r22, r18
    18f4:	71 1d       	adc	r23, r1
    18f6:	81 1d       	adc	r24, r1
    18f8:	91 1d       	adc	r25, r1
    18fa:	08 95       	ret

000018fc <skip_spaces>:
    18fc:	0f 93       	push	r16
    18fe:	1f 93       	push	r17
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	8c 01       	movw	r16, r24
    1906:	c8 01       	movw	r24, r16
    1908:	e1 d1       	rcall	.+962    	; 0x1ccc <fgetc>
    190a:	ec 01       	movw	r28, r24
    190c:	97 fd       	sbrc	r25, 7
    190e:	06 c0       	rjmp	.+12     	; 0x191c <skip_spaces+0x20>
    1910:	c1 d1       	rcall	.+898    	; 0x1c94 <isspace>
    1912:	89 2b       	or	r24, r25
    1914:	c1 f7       	brne	.-16     	; 0x1906 <skip_spaces+0xa>
    1916:	b8 01       	movw	r22, r16
    1918:	ce 01       	movw	r24, r28
    191a:	52 d2       	rcall	.+1188   	; 0x1dc0 <ungetc>
    191c:	ce 01       	movw	r24, r28
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	08 95       	ret

00001928 <conv_int>:
    1928:	8f 92       	push	r8
    192a:	9f 92       	push	r9
    192c:	af 92       	push	r10
    192e:	bf 92       	push	r11
    1930:	ef 92       	push	r14
    1932:	ff 92       	push	r15
    1934:	0f 93       	push	r16
    1936:	1f 93       	push	r17
    1938:	cf 93       	push	r28
    193a:	df 93       	push	r29
    193c:	8c 01       	movw	r16, r24
    193e:	d6 2f       	mov	r29, r22
    1940:	7a 01       	movw	r14, r20
    1942:	b2 2e       	mov	r11, r18
    1944:	c3 d1       	rcall	.+902    	; 0x1ccc <fgetc>
    1946:	9c 01       	movw	r18, r24
    1948:	33 27       	eor	r19, r19
    194a:	2b 32       	cpi	r18, 0x2B	; 43
    194c:	31 05       	cpc	r19, r1
    194e:	31 f0       	breq	.+12     	; 0x195c <conv_int+0x34>
    1950:	2d 32       	cpi	r18, 0x2D	; 45
    1952:	31 05       	cpc	r19, r1
    1954:	59 f4       	brne	.+22     	; 0x196c <conv_int+0x44>
    1956:	8b 2d       	mov	r24, r11
    1958:	80 68       	ori	r24, 0x80	; 128
    195a:	b8 2e       	mov	r11, r24
    195c:	d1 50       	subi	r29, 0x01	; 1
    195e:	11 f4       	brne	.+4      	; 0x1964 <conv_int+0x3c>
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	61 c0       	rjmp	.+194    	; 0x1a26 <conv_int+0xfe>
    1964:	c8 01       	movw	r24, r16
    1966:	b2 d1       	rcall	.+868    	; 0x1ccc <fgetc>
    1968:	97 fd       	sbrc	r25, 7
    196a:	fa cf       	rjmp	.-12     	; 0x1960 <conv_int+0x38>
    196c:	cb 2d       	mov	r28, r11
    196e:	cd 7f       	andi	r28, 0xFD	; 253
    1970:	2b 2d       	mov	r18, r11
    1972:	20 73       	andi	r18, 0x30	; 48
    1974:	f9 f4       	brne	.+62     	; 0x19b4 <conv_int+0x8c>
    1976:	80 33       	cpi	r24, 0x30	; 48
    1978:	e9 f4       	brne	.+58     	; 0x19b4 <conv_int+0x8c>
    197a:	aa 24       	eor	r10, r10
    197c:	aa 94       	dec	r10
    197e:	ad 0e       	add	r10, r29
    1980:	09 f4       	brne	.+2      	; 0x1984 <conv_int+0x5c>
    1982:	3e c0       	rjmp	.+124    	; 0x1a00 <conv_int+0xd8>
    1984:	c8 01       	movw	r24, r16
    1986:	a2 d1       	rcall	.+836    	; 0x1ccc <fgetc>
    1988:	97 fd       	sbrc	r25, 7
    198a:	3a c0       	rjmp	.+116    	; 0x1a00 <conv_int+0xd8>
    198c:	9c 01       	movw	r18, r24
    198e:	2f 7d       	andi	r18, 0xDF	; 223
    1990:	33 27       	eor	r19, r19
    1992:	28 35       	cpi	r18, 0x58	; 88
    1994:	31 05       	cpc	r19, r1
    1996:	41 f4       	brne	.+16     	; 0x19a8 <conv_int+0x80>
    1998:	c2 64       	ori	r28, 0x42	; 66
    199a:	d2 50       	subi	r29, 0x02	; 2
    199c:	89 f1       	breq	.+98     	; 0x1a00 <conv_int+0xd8>
    199e:	c8 01       	movw	r24, r16
    19a0:	95 d1       	rcall	.+810    	; 0x1ccc <fgetc>
    19a2:	97 ff       	sbrs	r25, 7
    19a4:	07 c0       	rjmp	.+14     	; 0x19b4 <conv_int+0x8c>
    19a6:	2c c0       	rjmp	.+88     	; 0x1a00 <conv_int+0xd8>
    19a8:	b6 fe       	sbrs	r11, 6
    19aa:	02 c0       	rjmp	.+4      	; 0x19b0 <conv_int+0x88>
    19ac:	c2 60       	ori	r28, 0x02	; 2
    19ae:	01 c0       	rjmp	.+2      	; 0x19b2 <conv_int+0x8a>
    19b0:	c2 61       	ori	r28, 0x12	; 18
    19b2:	da 2d       	mov	r29, r10
    19b4:	81 2c       	mov	r8, r1
    19b6:	91 2c       	mov	r9, r1
    19b8:	54 01       	movw	r10, r8
    19ba:	20 ed       	ldi	r18, 0xD0	; 208
    19bc:	28 0f       	add	r18, r24
    19be:	28 30       	cpi	r18, 0x08	; 8
    19c0:	78 f0       	brcs	.+30     	; 0x19e0 <conv_int+0xb8>
    19c2:	c4 ff       	sbrs	r28, 4
    19c4:	03 c0       	rjmp	.+6      	; 0x19cc <conv_int+0xa4>
    19c6:	b8 01       	movw	r22, r16
    19c8:	fb d1       	rcall	.+1014   	; 0x1dc0 <ungetc>
    19ca:	17 c0       	rjmp	.+46     	; 0x19fa <conv_int+0xd2>
    19cc:	2a 30       	cpi	r18, 0x0A	; 10
    19ce:	40 f0       	brcs	.+16     	; 0x19e0 <conv_int+0xb8>
    19d0:	c6 ff       	sbrs	r28, 6
    19d2:	f9 cf       	rjmp	.-14     	; 0x19c6 <conv_int+0x9e>
    19d4:	2f 7d       	andi	r18, 0xDF	; 223
    19d6:	3f ee       	ldi	r19, 0xEF	; 239
    19d8:	32 0f       	add	r19, r18
    19da:	36 30       	cpi	r19, 0x06	; 6
    19dc:	a0 f7       	brcc	.-24     	; 0x19c6 <conv_int+0x9e>
    19de:	27 50       	subi	r18, 0x07	; 7
    19e0:	4c 2f       	mov	r20, r28
    19e2:	c5 01       	movw	r24, r10
    19e4:	b4 01       	movw	r22, r8
    19e6:	63 df       	rcall	.-314    	; 0x18ae <mulacc>
    19e8:	4b 01       	movw	r8, r22
    19ea:	5c 01       	movw	r10, r24
    19ec:	c2 60       	ori	r28, 0x02	; 2
    19ee:	d1 50       	subi	r29, 0x01	; 1
    19f0:	51 f0       	breq	.+20     	; 0x1a06 <conv_int+0xde>
    19f2:	c8 01       	movw	r24, r16
    19f4:	6b d1       	rcall	.+726    	; 0x1ccc <fgetc>
    19f6:	97 ff       	sbrs	r25, 7
    19f8:	e0 cf       	rjmp	.-64     	; 0x19ba <conv_int+0x92>
    19fa:	c1 fd       	sbrc	r28, 1
    19fc:	04 c0       	rjmp	.+8      	; 0x1a06 <conv_int+0xde>
    19fe:	b0 cf       	rjmp	.-160    	; 0x1960 <conv_int+0x38>
    1a00:	81 2c       	mov	r8, r1
    1a02:	91 2c       	mov	r9, r1
    1a04:	54 01       	movw	r10, r8
    1a06:	c7 ff       	sbrs	r28, 7
    1a08:	08 c0       	rjmp	.+16     	; 0x1a1a <conv_int+0xf2>
    1a0a:	b0 94       	com	r11
    1a0c:	a0 94       	com	r10
    1a0e:	90 94       	com	r9
    1a10:	80 94       	com	r8
    1a12:	81 1c       	adc	r8, r1
    1a14:	91 1c       	adc	r9, r1
    1a16:	a1 1c       	adc	r10, r1
    1a18:	b1 1c       	adc	r11, r1
    1a1a:	2c 2f       	mov	r18, r28
    1a1c:	b5 01       	movw	r22, r10
    1a1e:	a4 01       	movw	r20, r8
    1a20:	c7 01       	movw	r24, r14
    1a22:	39 df       	rcall	.-398    	; 0x1896 <putval>
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	df 91       	pop	r29
    1a28:	cf 91       	pop	r28
    1a2a:	1f 91       	pop	r17
    1a2c:	0f 91       	pop	r16
    1a2e:	ff 90       	pop	r15
    1a30:	ef 90       	pop	r14
    1a32:	bf 90       	pop	r11
    1a34:	af 90       	pop	r10
    1a36:	9f 90       	pop	r9
    1a38:	8f 90       	pop	r8
    1a3a:	08 95       	ret

00001a3c <vfscanf>:
    1a3c:	a0 e0       	ldi	r26, 0x00	; 0
    1a3e:	b0 e0       	ldi	r27, 0x00	; 0
    1a40:	e3 e2       	ldi	r30, 0x23	; 35
    1a42:	fd e0       	ldi	r31, 0x0D	; 13
    1a44:	f3 c0       	rjmp	.+486    	; 0x1c2c <__prologue_saves__+0x6>
    1a46:	6c 01       	movw	r12, r24
    1a48:	eb 01       	movw	r28, r22
    1a4a:	5a 01       	movw	r10, r20
    1a4c:	fc 01       	movw	r30, r24
    1a4e:	17 82       	std	Z+7, r1	; 0x07
    1a50:	16 82       	std	Z+6, r1	; 0x06
    1a52:	51 2c       	mov	r5, r1
    1a54:	f6 01       	movw	r30, r12
    1a56:	f3 80       	ldd	r15, Z+3	; 0x03
    1a58:	fe 01       	movw	r30, r28
    1a5a:	f3 fc       	sbrc	r15, 3
    1a5c:	85 91       	lpm	r24, Z+
    1a5e:	f3 fe       	sbrs	r15, 3
    1a60:	81 91       	ld	r24, Z+
    1a62:	18 2f       	mov	r17, r24
    1a64:	ef 01       	movw	r28, r30
    1a66:	88 23       	and	r24, r24
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <vfscanf+0x30>
    1a6a:	d4 c0       	rjmp	.+424    	; 0x1c14 <vfscanf+0x1d8>
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	12 d1       	rcall	.+548    	; 0x1c94 <isspace>
    1a70:	89 2b       	or	r24, r25
    1a72:	19 f0       	breq	.+6      	; 0x1a7a <vfscanf+0x3e>
    1a74:	c6 01       	movw	r24, r12
    1a76:	42 df       	rcall	.-380    	; 0x18fc <skip_spaces>
    1a78:	ed cf       	rjmp	.-38     	; 0x1a54 <vfscanf+0x18>
    1a7a:	15 32       	cpi	r17, 0x25	; 37
    1a7c:	41 f4       	brne	.+16     	; 0x1a8e <vfscanf+0x52>
    1a7e:	fe 01       	movw	r30, r28
    1a80:	f3 fc       	sbrc	r15, 3
    1a82:	15 91       	lpm	r17, Z+
    1a84:	f3 fe       	sbrs	r15, 3
    1a86:	11 91       	ld	r17, Z+
    1a88:	ef 01       	movw	r28, r30
    1a8a:	15 32       	cpi	r17, 0x25	; 37
    1a8c:	71 f4       	brne	.+28     	; 0x1aaa <vfscanf+0x6e>
    1a8e:	c6 01       	movw	r24, r12
    1a90:	1d d1       	rcall	.+570    	; 0x1ccc <fgetc>
    1a92:	97 fd       	sbrc	r25, 7
    1a94:	bd c0       	rjmp	.+378    	; 0x1c10 <vfscanf+0x1d4>
    1a96:	41 2f       	mov	r20, r17
    1a98:	50 e0       	ldi	r21, 0x00	; 0
    1a9a:	9c 01       	movw	r18, r24
    1a9c:	33 27       	eor	r19, r19
    1a9e:	24 17       	cp	r18, r20
    1aa0:	35 07       	cpc	r19, r21
    1aa2:	c1 f2       	breq	.-80     	; 0x1a54 <vfscanf+0x18>
    1aa4:	b6 01       	movw	r22, r12
    1aa6:	8c d1       	rcall	.+792    	; 0x1dc0 <ungetc>
    1aa8:	b5 c0       	rjmp	.+362    	; 0x1c14 <vfscanf+0x1d8>
    1aaa:	1a 32       	cpi	r17, 0x2A	; 42
    1aac:	39 f4       	brne	.+14     	; 0x1abc <vfscanf+0x80>
    1aae:	f3 fc       	sbrc	r15, 3
    1ab0:	15 91       	lpm	r17, Z+
    1ab2:	f3 fe       	sbrs	r15, 3
    1ab4:	11 91       	ld	r17, Z+
    1ab6:	ef 01       	movw	r28, r30
    1ab8:	01 e0       	ldi	r16, 0x01	; 1
    1aba:	01 c0       	rjmp	.+2      	; 0x1abe <vfscanf+0x82>
    1abc:	00 e0       	ldi	r16, 0x00	; 0
    1abe:	e1 2c       	mov	r14, r1
    1ac0:	20 ed       	ldi	r18, 0xD0	; 208
    1ac2:	21 0f       	add	r18, r17
    1ac4:	2a 30       	cpi	r18, 0x0A	; 10
    1ac6:	78 f4       	brcc	.+30     	; 0x1ae6 <vfscanf+0xaa>
    1ac8:	02 60       	ori	r16, 0x02	; 2
    1aca:	6e 2d       	mov	r22, r14
    1acc:	70 e0       	ldi	r23, 0x00	; 0
    1ace:	80 e0       	ldi	r24, 0x00	; 0
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	40 e2       	ldi	r20, 0x20	; 32
    1ad4:	ec de       	rcall	.-552    	; 0x18ae <mulacc>
    1ad6:	e6 2e       	mov	r14, r22
    1ad8:	fe 01       	movw	r30, r28
    1ada:	f3 fc       	sbrc	r15, 3
    1adc:	15 91       	lpm	r17, Z+
    1ade:	f3 fe       	sbrs	r15, 3
    1ae0:	11 91       	ld	r17, Z+
    1ae2:	ef 01       	movw	r28, r30
    1ae4:	ed cf       	rjmp	.-38     	; 0x1ac0 <vfscanf+0x84>
    1ae6:	01 ff       	sbrs	r16, 1
    1ae8:	03 c0       	rjmp	.+6      	; 0x1af0 <vfscanf+0xb4>
    1aea:	e1 10       	cpse	r14, r1
    1aec:	03 c0       	rjmp	.+6      	; 0x1af4 <vfscanf+0xb8>
    1aee:	92 c0       	rjmp	.+292    	; 0x1c14 <vfscanf+0x1d8>
    1af0:	ee 24       	eor	r14, r14
    1af2:	ea 94       	dec	r14
    1af4:	18 36       	cpi	r17, 0x68	; 104
    1af6:	19 f0       	breq	.+6      	; 0x1afe <vfscanf+0xc2>
    1af8:	1c 36       	cpi	r17, 0x6C	; 108
    1afa:	51 f0       	breq	.+20     	; 0x1b10 <vfscanf+0xd4>
    1afc:	10 c0       	rjmp	.+32     	; 0x1b1e <vfscanf+0xe2>
    1afe:	fe 01       	movw	r30, r28
    1b00:	f3 fc       	sbrc	r15, 3
    1b02:	15 91       	lpm	r17, Z+
    1b04:	f3 fe       	sbrs	r15, 3
    1b06:	11 91       	ld	r17, Z+
    1b08:	ef 01       	movw	r28, r30
    1b0a:	18 36       	cpi	r17, 0x68	; 104
    1b0c:	41 f4       	brne	.+16     	; 0x1b1e <vfscanf+0xe2>
    1b0e:	08 60       	ori	r16, 0x08	; 8
    1b10:	04 60       	ori	r16, 0x04	; 4
    1b12:	fe 01       	movw	r30, r28
    1b14:	f3 fc       	sbrc	r15, 3
    1b16:	15 91       	lpm	r17, Z+
    1b18:	f3 fe       	sbrs	r15, 3
    1b1a:	11 91       	ld	r17, Z+
    1b1c:	ef 01       	movw	r28, r30
    1b1e:	11 23       	and	r17, r17
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <vfscanf+0xe8>
    1b22:	78 c0       	rjmp	.+240    	; 0x1c14 <vfscanf+0x1d8>
    1b24:	61 2f       	mov	r22, r17
    1b26:	70 e0       	ldi	r23, 0x00	; 0
    1b28:	8f e7       	ldi	r24, 0x7F	; 127
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	bb d0       	rcall	.+374    	; 0x1ca4 <strchr_P>
    1b2e:	89 2b       	or	r24, r25
    1b30:	09 f4       	brne	.+2      	; 0x1b34 <vfscanf+0xf8>
    1b32:	70 c0       	rjmp	.+224    	; 0x1c14 <vfscanf+0x1d8>
    1b34:	00 fd       	sbrc	r16, 0
    1b36:	07 c0       	rjmp	.+14     	; 0x1b46 <vfscanf+0x10a>
    1b38:	f5 01       	movw	r30, r10
    1b3a:	80 80       	ld	r8, Z
    1b3c:	91 80       	ldd	r9, Z+1	; 0x01
    1b3e:	c5 01       	movw	r24, r10
    1b40:	02 96       	adiw	r24, 0x02	; 2
    1b42:	5c 01       	movw	r10, r24
    1b44:	02 c0       	rjmp	.+4      	; 0x1b4a <vfscanf+0x10e>
    1b46:	81 2c       	mov	r8, r1
    1b48:	91 2c       	mov	r9, r1
    1b4a:	1e 36       	cpi	r17, 0x6E	; 110
    1b4c:	49 f4       	brne	.+18     	; 0x1b60 <vfscanf+0x124>
    1b4e:	f6 01       	movw	r30, r12
    1b50:	46 81       	ldd	r20, Z+6	; 0x06
    1b52:	57 81       	ldd	r21, Z+7	; 0x07
    1b54:	60 e0       	ldi	r22, 0x00	; 0
    1b56:	70 e0       	ldi	r23, 0x00	; 0
    1b58:	20 2f       	mov	r18, r16
    1b5a:	c4 01       	movw	r24, r8
    1b5c:	9c de       	rcall	.-712    	; 0x1896 <putval>
    1b5e:	7a cf       	rjmp	.-268    	; 0x1a54 <vfscanf+0x18>
    1b60:	13 36       	cpi	r17, 0x63	; 99
    1b62:	a1 f4       	brne	.+40     	; 0x1b8c <vfscanf+0x150>
    1b64:	01 fd       	sbrc	r16, 1
    1b66:	02 c0       	rjmp	.+4      	; 0x1b6c <vfscanf+0x130>
    1b68:	ee 24       	eor	r14, r14
    1b6a:	e3 94       	inc	r14
    1b6c:	c6 01       	movw	r24, r12
    1b6e:	ae d0       	rcall	.+348    	; 0x1ccc <fgetc>
    1b70:	97 fd       	sbrc	r25, 7
    1b72:	4e c0       	rjmp	.+156    	; 0x1c10 <vfscanf+0x1d4>
    1b74:	81 14       	cp	r8, r1
    1b76:	91 04       	cpc	r9, r1
    1b78:	29 f0       	breq	.+10     	; 0x1b84 <vfscanf+0x148>
    1b7a:	f4 01       	movw	r30, r8
    1b7c:	80 83       	st	Z, r24
    1b7e:	c4 01       	movw	r24, r8
    1b80:	01 96       	adiw	r24, 0x01	; 1
    1b82:	4c 01       	movw	r8, r24
    1b84:	ea 94       	dec	r14
    1b86:	e1 10       	cpse	r14, r1
    1b88:	f1 cf       	rjmp	.-30     	; 0x1b6c <vfscanf+0x130>
    1b8a:	3e c0       	rjmp	.+124    	; 0x1c08 <vfscanf+0x1cc>
    1b8c:	c6 01       	movw	r24, r12
    1b8e:	b6 de       	rcall	.-660    	; 0x18fc <skip_spaces>
    1b90:	97 fd       	sbrc	r25, 7
    1b92:	3e c0       	rjmp	.+124    	; 0x1c10 <vfscanf+0x1d4>
    1b94:	1f 36       	cpi	r17, 0x6F	; 111
    1b96:	49 f1       	breq	.+82     	; 0x1bea <vfscanf+0x1ae>
    1b98:	28 f4       	brcc	.+10     	; 0x1ba4 <vfscanf+0x168>
    1b9a:	14 36       	cpi	r17, 0x64	; 100
    1b9c:	21 f1       	breq	.+72     	; 0x1be6 <vfscanf+0x1aa>
    1b9e:	19 36       	cpi	r17, 0x69	; 105
    1ba0:	39 f1       	breq	.+78     	; 0x1bf0 <vfscanf+0x1b4>
    1ba2:	25 c0       	rjmp	.+74     	; 0x1bee <vfscanf+0x1b2>
    1ba4:	13 37       	cpi	r17, 0x73	; 115
    1ba6:	71 f0       	breq	.+28     	; 0x1bc4 <vfscanf+0x188>
    1ba8:	15 37       	cpi	r17, 0x75	; 117
    1baa:	e9 f0       	breq	.+58     	; 0x1be6 <vfscanf+0x1aa>
    1bac:	20 c0       	rjmp	.+64     	; 0x1bee <vfscanf+0x1b2>
    1bae:	81 14       	cp	r8, r1
    1bb0:	91 04       	cpc	r9, r1
    1bb2:	29 f0       	breq	.+10     	; 0x1bbe <vfscanf+0x182>
    1bb4:	f4 01       	movw	r30, r8
    1bb6:	60 82       	st	Z, r6
    1bb8:	c4 01       	movw	r24, r8
    1bba:	01 96       	adiw	r24, 0x01	; 1
    1bbc:	4c 01       	movw	r8, r24
    1bbe:	ea 94       	dec	r14
    1bc0:	ee 20       	and	r14, r14
    1bc2:	59 f0       	breq	.+22     	; 0x1bda <vfscanf+0x19e>
    1bc4:	c6 01       	movw	r24, r12
    1bc6:	82 d0       	rcall	.+260    	; 0x1ccc <fgetc>
    1bc8:	3c 01       	movw	r6, r24
    1bca:	97 fd       	sbrc	r25, 7
    1bcc:	06 c0       	rjmp	.+12     	; 0x1bda <vfscanf+0x19e>
    1bce:	62 d0       	rcall	.+196    	; 0x1c94 <isspace>
    1bd0:	89 2b       	or	r24, r25
    1bd2:	69 f3       	breq	.-38     	; 0x1bae <vfscanf+0x172>
    1bd4:	b6 01       	movw	r22, r12
    1bd6:	c3 01       	movw	r24, r6
    1bd8:	f3 d0       	rcall	.+486    	; 0x1dc0 <ungetc>
    1bda:	81 14       	cp	r8, r1
    1bdc:	91 04       	cpc	r9, r1
    1bde:	a1 f0       	breq	.+40     	; 0x1c08 <vfscanf+0x1cc>
    1be0:	f4 01       	movw	r30, r8
    1be2:	10 82       	st	Z, r1
    1be4:	11 c0       	rjmp	.+34     	; 0x1c08 <vfscanf+0x1cc>
    1be6:	00 62       	ori	r16, 0x20	; 32
    1be8:	03 c0       	rjmp	.+6      	; 0x1bf0 <vfscanf+0x1b4>
    1bea:	00 61       	ori	r16, 0x10	; 16
    1bec:	01 c0       	rjmp	.+2      	; 0x1bf0 <vfscanf+0x1b4>
    1bee:	00 64       	ori	r16, 0x40	; 64
    1bf0:	20 2f       	mov	r18, r16
    1bf2:	a4 01       	movw	r20, r8
    1bf4:	6e 2d       	mov	r22, r14
    1bf6:	c6 01       	movw	r24, r12
    1bf8:	97 de       	rcall	.-722    	; 0x1928 <conv_int>
    1bfa:	81 11       	cpse	r24, r1
    1bfc:	05 c0       	rjmp	.+10     	; 0x1c08 <vfscanf+0x1cc>
    1bfe:	f6 01       	movw	r30, r12
    1c00:	83 81       	ldd	r24, Z+3	; 0x03
    1c02:	80 73       	andi	r24, 0x30	; 48
    1c04:	29 f4       	brne	.+10     	; 0x1c10 <vfscanf+0x1d4>
    1c06:	06 c0       	rjmp	.+12     	; 0x1c14 <vfscanf+0x1d8>
    1c08:	00 fd       	sbrc	r16, 0
    1c0a:	24 cf       	rjmp	.-440    	; 0x1a54 <vfscanf+0x18>
    1c0c:	53 94       	inc	r5
    1c0e:	22 cf       	rjmp	.-444    	; 0x1a54 <vfscanf+0x18>
    1c10:	55 20       	and	r5, r5
    1c12:	19 f0       	breq	.+6      	; 0x1c1a <vfscanf+0x1de>
    1c14:	85 2d       	mov	r24, r5
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	02 c0       	rjmp	.+4      	; 0x1c1e <vfscanf+0x1e2>
    1c1a:	8f ef       	ldi	r24, 0xFF	; 255
    1c1c:	9f ef       	ldi	r25, 0xFF	; 255
    1c1e:	cd b7       	in	r28, 0x3d	; 61
    1c20:	de b7       	in	r29, 0x3e	; 62
    1c22:	ef e0       	ldi	r30, 0x0F	; 15
    1c24:	1f c0       	rjmp	.+62     	; 0x1c64 <__epilogue_restores__+0x6>

00001c26 <__prologue_saves__>:
    1c26:	2f 92       	push	r2
    1c28:	3f 92       	push	r3
    1c2a:	4f 92       	push	r4
    1c2c:	5f 92       	push	r5
    1c2e:	6f 92       	push	r6
    1c30:	7f 92       	push	r7
    1c32:	8f 92       	push	r8
    1c34:	9f 92       	push	r9
    1c36:	af 92       	push	r10
    1c38:	bf 92       	push	r11
    1c3a:	cf 92       	push	r12
    1c3c:	df 92       	push	r13
    1c3e:	ef 92       	push	r14
    1c40:	ff 92       	push	r15
    1c42:	0f 93       	push	r16
    1c44:	1f 93       	push	r17
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	cd b7       	in	r28, 0x3d	; 61
    1c4c:	de b7       	in	r29, 0x3e	; 62
    1c4e:	ca 1b       	sub	r28, r26
    1c50:	db 0b       	sbc	r29, r27
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	de bf       	out	0x3e, r29	; 62
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	cd bf       	out	0x3d, r28	; 61
    1c5c:	09 94       	ijmp

00001c5e <__epilogue_restores__>:
    1c5e:	2a 88       	ldd	r2, Y+18	; 0x12
    1c60:	39 88       	ldd	r3, Y+17	; 0x11
    1c62:	48 88       	ldd	r4, Y+16	; 0x10
    1c64:	5f 84       	ldd	r5, Y+15	; 0x0f
    1c66:	6e 84       	ldd	r6, Y+14	; 0x0e
    1c68:	7d 84       	ldd	r7, Y+13	; 0x0d
    1c6a:	8c 84       	ldd	r8, Y+12	; 0x0c
    1c6c:	9b 84       	ldd	r9, Y+11	; 0x0b
    1c6e:	aa 84       	ldd	r10, Y+10	; 0x0a
    1c70:	b9 84       	ldd	r11, Y+9	; 0x09
    1c72:	c8 84       	ldd	r12, Y+8	; 0x08
    1c74:	df 80       	ldd	r13, Y+7	; 0x07
    1c76:	ee 80       	ldd	r14, Y+6	; 0x06
    1c78:	fd 80       	ldd	r15, Y+5	; 0x05
    1c7a:	0c 81       	ldd	r16, Y+4	; 0x04
    1c7c:	1b 81       	ldd	r17, Y+3	; 0x03
    1c7e:	aa 81       	ldd	r26, Y+2	; 0x02
    1c80:	b9 81       	ldd	r27, Y+1	; 0x01
    1c82:	ce 0f       	add	r28, r30
    1c84:	d1 1d       	adc	r29, r1
    1c86:	0f b6       	in	r0, 0x3f	; 63
    1c88:	f8 94       	cli
    1c8a:	de bf       	out	0x3e, r29	; 62
    1c8c:	0f be       	out	0x3f, r0	; 63
    1c8e:	cd bf       	out	0x3d, r28	; 61
    1c90:	ed 01       	movw	r28, r26
    1c92:	08 95       	ret

00001c94 <isspace>:
    1c94:	91 11       	cpse	r25, r1
    1c96:	0b c1       	rjmp	.+534    	; 0x1eae <__ctype_isfalse>
    1c98:	80 32       	cpi	r24, 0x20	; 32
    1c9a:	19 f0       	breq	.+6      	; 0x1ca2 <isspace+0xe>
    1c9c:	89 50       	subi	r24, 0x09	; 9
    1c9e:	85 50       	subi	r24, 0x05	; 5
    1ca0:	d0 f7       	brcc	.-12     	; 0x1c96 <isspace+0x2>
    1ca2:	08 95       	ret

00001ca4 <strchr_P>:
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	05 90       	lpm	r0, Z+
    1ca8:	06 16       	cp	r0, r22
    1caa:	21 f0       	breq	.+8      	; 0x1cb4 <strchr_P+0x10>
    1cac:	00 20       	and	r0, r0
    1cae:	d9 f7       	brne	.-10     	; 0x1ca6 <strchr_P+0x2>
    1cb0:	c0 01       	movw	r24, r0
    1cb2:	08 95       	ret
    1cb4:	31 97       	sbiw	r30, 0x01	; 1
    1cb6:	cf 01       	movw	r24, r30
    1cb8:	08 95       	ret

00001cba <memcpy>:
    1cba:	fb 01       	movw	r30, r22
    1cbc:	dc 01       	movw	r26, r24
    1cbe:	02 c0       	rjmp	.+4      	; 0x1cc4 <memcpy+0xa>
    1cc0:	01 90       	ld	r0, Z+
    1cc2:	0d 92       	st	X+, r0
    1cc4:	41 50       	subi	r20, 0x01	; 1
    1cc6:	50 40       	sbci	r21, 0x00	; 0
    1cc8:	d8 f7       	brcc	.-10     	; 0x1cc0 <memcpy+0x6>
    1cca:	08 95       	ret

00001ccc <fgetc>:
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	ec 01       	movw	r28, r24
    1cd2:	2b 81       	ldd	r18, Y+3	; 0x03
    1cd4:	20 ff       	sbrs	r18, 0
    1cd6:	33 c0       	rjmp	.+102    	; 0x1d3e <fgetc+0x72>
    1cd8:	26 ff       	sbrs	r18, 6
    1cda:	0a c0       	rjmp	.+20     	; 0x1cf0 <fgetc+0x24>
    1cdc:	2f 7b       	andi	r18, 0xBF	; 191
    1cde:	2b 83       	std	Y+3, r18	; 0x03
    1ce0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ce2:	9f 81       	ldd	r25, Y+7	; 0x07
    1ce4:	01 96       	adiw	r24, 0x01	; 1
    1ce6:	9f 83       	std	Y+7, r25	; 0x07
    1ce8:	8e 83       	std	Y+6, r24	; 0x06
    1cea:	8a 81       	ldd	r24, Y+2	; 0x02
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	29 c0       	rjmp	.+82     	; 0x1d42 <fgetc+0x76>
    1cf0:	22 ff       	sbrs	r18, 2
    1cf2:	0f c0       	rjmp	.+30     	; 0x1d12 <fgetc+0x46>
    1cf4:	e8 81       	ld	r30, Y
    1cf6:	f9 81       	ldd	r31, Y+1	; 0x01
    1cf8:	80 81       	ld	r24, Z
    1cfa:	08 2e       	mov	r0, r24
    1cfc:	00 0c       	add	r0, r0
    1cfe:	99 0b       	sbc	r25, r25
    1d00:	00 97       	sbiw	r24, 0x00	; 0
    1d02:	19 f4       	brne	.+6      	; 0x1d0a <fgetc+0x3e>
    1d04:	20 62       	ori	r18, 0x20	; 32
    1d06:	2b 83       	std	Y+3, r18	; 0x03
    1d08:	1a c0       	rjmp	.+52     	; 0x1d3e <fgetc+0x72>
    1d0a:	31 96       	adiw	r30, 0x01	; 1
    1d0c:	f9 83       	std	Y+1, r31	; 0x01
    1d0e:	e8 83       	st	Y, r30
    1d10:	0e c0       	rjmp	.+28     	; 0x1d2e <fgetc+0x62>
    1d12:	ea 85       	ldd	r30, Y+10	; 0x0a
    1d14:	fb 85       	ldd	r31, Y+11	; 0x0b
    1d16:	09 95       	icall
    1d18:	97 ff       	sbrs	r25, 7
    1d1a:	09 c0       	rjmp	.+18     	; 0x1d2e <fgetc+0x62>
    1d1c:	2b 81       	ldd	r18, Y+3	; 0x03
    1d1e:	01 96       	adiw	r24, 0x01	; 1
    1d20:	11 f0       	breq	.+4      	; 0x1d26 <fgetc+0x5a>
    1d22:	80 e2       	ldi	r24, 0x20	; 32
    1d24:	01 c0       	rjmp	.+2      	; 0x1d28 <fgetc+0x5c>
    1d26:	80 e1       	ldi	r24, 0x10	; 16
    1d28:	82 2b       	or	r24, r18
    1d2a:	8b 83       	std	Y+3, r24	; 0x03
    1d2c:	08 c0       	rjmp	.+16     	; 0x1d3e <fgetc+0x72>
    1d2e:	2e 81       	ldd	r18, Y+6	; 0x06
    1d30:	3f 81       	ldd	r19, Y+7	; 0x07
    1d32:	2f 5f       	subi	r18, 0xFF	; 255
    1d34:	3f 4f       	sbci	r19, 0xFF	; 255
    1d36:	3f 83       	std	Y+7, r19	; 0x07
    1d38:	2e 83       	std	Y+6, r18	; 0x06
    1d3a:	99 27       	eor	r25, r25
    1d3c:	02 c0       	rjmp	.+4      	; 0x1d42 <fgetc+0x76>
    1d3e:	8f ef       	ldi	r24, 0xFF	; 255
    1d40:	9f ef       	ldi	r25, 0xFF	; 255
    1d42:	df 91       	pop	r29
    1d44:	cf 91       	pop	r28
    1d46:	08 95       	ret

00001d48 <fputc>:
    1d48:	0f 93       	push	r16
    1d4a:	1f 93       	push	r17
    1d4c:	cf 93       	push	r28
    1d4e:	df 93       	push	r29
    1d50:	fb 01       	movw	r30, r22
    1d52:	23 81       	ldd	r18, Z+3	; 0x03
    1d54:	21 fd       	sbrc	r18, 1
    1d56:	03 c0       	rjmp	.+6      	; 0x1d5e <fputc+0x16>
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
    1d5a:	9f ef       	ldi	r25, 0xFF	; 255
    1d5c:	2c c0       	rjmp	.+88     	; 0x1db6 <fputc+0x6e>
    1d5e:	22 ff       	sbrs	r18, 2
    1d60:	16 c0       	rjmp	.+44     	; 0x1d8e <fputc+0x46>
    1d62:	46 81       	ldd	r20, Z+6	; 0x06
    1d64:	57 81       	ldd	r21, Z+7	; 0x07
    1d66:	24 81       	ldd	r18, Z+4	; 0x04
    1d68:	35 81       	ldd	r19, Z+5	; 0x05
    1d6a:	42 17       	cp	r20, r18
    1d6c:	53 07       	cpc	r21, r19
    1d6e:	44 f4       	brge	.+16     	; 0x1d80 <fputc+0x38>
    1d70:	a0 81       	ld	r26, Z
    1d72:	b1 81       	ldd	r27, Z+1	; 0x01
    1d74:	9d 01       	movw	r18, r26
    1d76:	2f 5f       	subi	r18, 0xFF	; 255
    1d78:	3f 4f       	sbci	r19, 0xFF	; 255
    1d7a:	31 83       	std	Z+1, r19	; 0x01
    1d7c:	20 83       	st	Z, r18
    1d7e:	8c 93       	st	X, r24
    1d80:	26 81       	ldd	r18, Z+6	; 0x06
    1d82:	37 81       	ldd	r19, Z+7	; 0x07
    1d84:	2f 5f       	subi	r18, 0xFF	; 255
    1d86:	3f 4f       	sbci	r19, 0xFF	; 255
    1d88:	37 83       	std	Z+7, r19	; 0x07
    1d8a:	26 83       	std	Z+6, r18	; 0x06
    1d8c:	14 c0       	rjmp	.+40     	; 0x1db6 <fputc+0x6e>
    1d8e:	8b 01       	movw	r16, r22
    1d90:	ec 01       	movw	r28, r24
    1d92:	fb 01       	movw	r30, r22
    1d94:	00 84       	ldd	r0, Z+8	; 0x08
    1d96:	f1 85       	ldd	r31, Z+9	; 0x09
    1d98:	e0 2d       	mov	r30, r0
    1d9a:	09 95       	icall
    1d9c:	89 2b       	or	r24, r25
    1d9e:	e1 f6       	brne	.-72     	; 0x1d58 <fputc+0x10>
    1da0:	d8 01       	movw	r26, r16
    1da2:	16 96       	adiw	r26, 0x06	; 6
    1da4:	8d 91       	ld	r24, X+
    1da6:	9c 91       	ld	r25, X
    1da8:	17 97       	sbiw	r26, 0x07	; 7
    1daa:	01 96       	adiw	r24, 0x01	; 1
    1dac:	17 96       	adiw	r26, 0x07	; 7
    1dae:	9c 93       	st	X, r25
    1db0:	8e 93       	st	-X, r24
    1db2:	16 97       	sbiw	r26, 0x06	; 6
    1db4:	ce 01       	movw	r24, r28
    1db6:	df 91       	pop	r29
    1db8:	cf 91       	pop	r28
    1dba:	1f 91       	pop	r17
    1dbc:	0f 91       	pop	r16
    1dbe:	08 95       	ret

00001dc0 <ungetc>:
    1dc0:	fb 01       	movw	r30, r22
    1dc2:	23 81       	ldd	r18, Z+3	; 0x03
    1dc4:	20 ff       	sbrs	r18, 0
    1dc6:	12 c0       	rjmp	.+36     	; 0x1dec <ungetc+0x2c>
    1dc8:	26 fd       	sbrc	r18, 6
    1dca:	10 c0       	rjmp	.+32     	; 0x1dec <ungetc+0x2c>
    1dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dce:	3f ef       	ldi	r19, 0xFF	; 255
    1dd0:	93 07       	cpc	r25, r19
    1dd2:	61 f0       	breq	.+24     	; 0x1dec <ungetc+0x2c>
    1dd4:	82 83       	std	Z+2, r24	; 0x02
    1dd6:	2f 7d       	andi	r18, 0xDF	; 223
    1dd8:	20 64       	ori	r18, 0x40	; 64
    1dda:	23 83       	std	Z+3, r18	; 0x03
    1ddc:	26 81       	ldd	r18, Z+6	; 0x06
    1dde:	37 81       	ldd	r19, Z+7	; 0x07
    1de0:	21 50       	subi	r18, 0x01	; 1
    1de2:	31 09       	sbc	r19, r1
    1de4:	37 83       	std	Z+7, r19	; 0x07
    1de6:	26 83       	std	Z+6, r18	; 0x06
    1de8:	99 27       	eor	r25, r25
    1dea:	08 95       	ret
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	9f ef       	ldi	r25, 0xFF	; 255
    1df0:	08 95       	ret

00001df2 <__ultoa_invert>:
    1df2:	fa 01       	movw	r30, r20
    1df4:	aa 27       	eor	r26, r26
    1df6:	28 30       	cpi	r18, 0x08	; 8
    1df8:	51 f1       	breq	.+84     	; 0x1e4e <__ultoa_invert+0x5c>
    1dfa:	20 31       	cpi	r18, 0x10	; 16
    1dfc:	81 f1       	breq	.+96     	; 0x1e5e <__ultoa_invert+0x6c>
    1dfe:	e8 94       	clt
    1e00:	6f 93       	push	r22
    1e02:	6e 7f       	andi	r22, 0xFE	; 254
    1e04:	6e 5f       	subi	r22, 0xFE	; 254
    1e06:	7f 4f       	sbci	r23, 0xFF	; 255
    1e08:	8f 4f       	sbci	r24, 0xFF	; 255
    1e0a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e0c:	af 4f       	sbci	r26, 0xFF	; 255
    1e0e:	b1 e0       	ldi	r27, 0x01	; 1
    1e10:	3e d0       	rcall	.+124    	; 0x1e8e <__ultoa_invert+0x9c>
    1e12:	b4 e0       	ldi	r27, 0x04	; 4
    1e14:	3c d0       	rcall	.+120    	; 0x1e8e <__ultoa_invert+0x9c>
    1e16:	67 0f       	add	r22, r23
    1e18:	78 1f       	adc	r23, r24
    1e1a:	89 1f       	adc	r24, r25
    1e1c:	9a 1f       	adc	r25, r26
    1e1e:	a1 1d       	adc	r26, r1
    1e20:	68 0f       	add	r22, r24
    1e22:	79 1f       	adc	r23, r25
    1e24:	8a 1f       	adc	r24, r26
    1e26:	91 1d       	adc	r25, r1
    1e28:	a1 1d       	adc	r26, r1
    1e2a:	6a 0f       	add	r22, r26
    1e2c:	71 1d       	adc	r23, r1
    1e2e:	81 1d       	adc	r24, r1
    1e30:	91 1d       	adc	r25, r1
    1e32:	a1 1d       	adc	r26, r1
    1e34:	20 d0       	rcall	.+64     	; 0x1e76 <__ultoa_invert+0x84>
    1e36:	09 f4       	brne	.+2      	; 0x1e3a <__ultoa_invert+0x48>
    1e38:	68 94       	set
    1e3a:	3f 91       	pop	r19
    1e3c:	2a e0       	ldi	r18, 0x0A	; 10
    1e3e:	26 9f       	mul	r18, r22
    1e40:	11 24       	eor	r1, r1
    1e42:	30 19       	sub	r19, r0
    1e44:	30 5d       	subi	r19, 0xD0	; 208
    1e46:	31 93       	st	Z+, r19
    1e48:	de f6       	brtc	.-74     	; 0x1e00 <__ultoa_invert+0xe>
    1e4a:	cf 01       	movw	r24, r30
    1e4c:	08 95       	ret
    1e4e:	46 2f       	mov	r20, r22
    1e50:	47 70       	andi	r20, 0x07	; 7
    1e52:	40 5d       	subi	r20, 0xD0	; 208
    1e54:	41 93       	st	Z+, r20
    1e56:	b3 e0       	ldi	r27, 0x03	; 3
    1e58:	0f d0       	rcall	.+30     	; 0x1e78 <__ultoa_invert+0x86>
    1e5a:	c9 f7       	brne	.-14     	; 0x1e4e <__ultoa_invert+0x5c>
    1e5c:	f6 cf       	rjmp	.-20     	; 0x1e4a <__ultoa_invert+0x58>
    1e5e:	46 2f       	mov	r20, r22
    1e60:	4f 70       	andi	r20, 0x0F	; 15
    1e62:	40 5d       	subi	r20, 0xD0	; 208
    1e64:	4a 33       	cpi	r20, 0x3A	; 58
    1e66:	18 f0       	brcs	.+6      	; 0x1e6e <__ultoa_invert+0x7c>
    1e68:	49 5d       	subi	r20, 0xD9	; 217
    1e6a:	31 fd       	sbrc	r19, 1
    1e6c:	40 52       	subi	r20, 0x20	; 32
    1e6e:	41 93       	st	Z+, r20
    1e70:	02 d0       	rcall	.+4      	; 0x1e76 <__ultoa_invert+0x84>
    1e72:	a9 f7       	brne	.-22     	; 0x1e5e <__ultoa_invert+0x6c>
    1e74:	ea cf       	rjmp	.-44     	; 0x1e4a <__ultoa_invert+0x58>
    1e76:	b4 e0       	ldi	r27, 0x04	; 4
    1e78:	a6 95       	lsr	r26
    1e7a:	97 95       	ror	r25
    1e7c:	87 95       	ror	r24
    1e7e:	77 95       	ror	r23
    1e80:	67 95       	ror	r22
    1e82:	ba 95       	dec	r27
    1e84:	c9 f7       	brne	.-14     	; 0x1e78 <__ultoa_invert+0x86>
    1e86:	00 97       	sbiw	r24, 0x00	; 0
    1e88:	61 05       	cpc	r22, r1
    1e8a:	71 05       	cpc	r23, r1
    1e8c:	08 95       	ret
    1e8e:	9b 01       	movw	r18, r22
    1e90:	ac 01       	movw	r20, r24
    1e92:	0a 2e       	mov	r0, r26
    1e94:	06 94       	lsr	r0
    1e96:	57 95       	ror	r21
    1e98:	47 95       	ror	r20
    1e9a:	37 95       	ror	r19
    1e9c:	27 95       	ror	r18
    1e9e:	ba 95       	dec	r27
    1ea0:	c9 f7       	brne	.-14     	; 0x1e94 <__ultoa_invert+0xa2>
    1ea2:	62 0f       	add	r22, r18
    1ea4:	73 1f       	adc	r23, r19
    1ea6:	84 1f       	adc	r24, r20
    1ea8:	95 1f       	adc	r25, r21
    1eaa:	a0 1d       	adc	r26, r0
    1eac:	08 95       	ret

00001eae <__ctype_isfalse>:
    1eae:	99 27       	eor	r25, r25
    1eb0:	88 27       	eor	r24, r24

00001eb2 <__ctype_istrue>:
    1eb2:	08 95       	ret

00001eb4 <_exit>:
    1eb4:	f8 94       	cli

00001eb6 <__stop_program>:
    1eb6:	ff cf       	rjmp	.-2      	; 0x1eb6 <__stop_program>
