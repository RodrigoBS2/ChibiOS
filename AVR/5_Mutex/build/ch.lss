
build/ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000006c  00800100  00001dd8  00001e6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001dd8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000035f  0080016c  0080016c  00001ed8  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00001ed8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001eec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000700  00000000  00000000  00001f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013a81  00000000  00000000  0000262c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004041  00000000  00000000  000160ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005284  00000000  00000000  0001a0ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013b0  00000000  00000000  0001f374  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e59  00000000  00000000  00020724  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000066ee  00000000  00000000  0002257d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008e8  00000000  00000000  00028c6b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4b c0       	rjmp	.+150    	; 0xc4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	86 c3       	rjmp	.+1804   	; 0x746 <__vector_14>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	b9 c3       	rjmp	.+1906   	; 0x7bc <__vector_18>
      4a:	00 00       	nop
      4c:	f5 c3       	rjmp	.+2026   	; 0x838 <__vector_19>
      4e:	00 00       	nop
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	37 c0       	rjmp	.+110    	; 0xc4 <__bad_interrupt>
      56:	00 00       	nop
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2314>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2449>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	e8 ed       	ldi	r30, 0xD8	; 216
      9e:	fd e1       	ldi	r31, 0x1D	; 29
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	ac 36       	cpi	r26, 0x6C	; 108
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	24 e0       	ldi	r18, 0x04	; 4
      ae:	ac e6       	ldi	r26, 0x6C	; 108
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	ab 3c       	cpi	r26, 0xCB	; 203
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 a7 0a 	call	0x154e	; 0x154e <main>
      c0:	0c 94 ea 0e 	jmp	0x1dd4	; 0x1dd4 <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
      c6:	0c d3       	rcall	.+1560   	; 0x6e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
      c8:	84 e1       	ldi	r24, 0x14	; 20
      ca:	91 e0       	ldi	r25, 0x01	; 1
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
      cc:	0a d3       	rcall	.+1556   	; 0x6e2 <_pal_lld_init>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
      ce:	95 d2       	rcall	.+1322   	; 0x5fa <sdInit>
      d0:	03 d3       	rcall	.+1542   	; 0x6d8 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
      d2:	00 c0       	rjmp	.+0      	; 0xd4 <stInit>

000000d4 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
      d4:	63 c3       	rjmp	.+1734   	; 0x79c <st_lld_init>

000000d6 <iq_read>:
  if ((wr > (size_t)0) && (nfy != NULL)) {
    nfy(oqp);
  }

  return wr;
}
      d6:	af 92       	push	r10
      d8:	bf 92       	push	r11
      da:	cf 92       	push	r12
      dc:	df 92       	push	r13
      de:	ef 92       	push	r14
      e0:	ff 92       	push	r15
      e2:	0f 93       	push	r16
      e4:	1f 93       	push	r17
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	ec 01       	movw	r28, r24
      ec:	6b 01       	movw	r12, r22
      ee:	8a 01       	movw	r16, r20
      f0:	8c 81       	ldd	r24, Y+4	; 0x04
      f2:	9d 81       	ldd	r25, Y+5	; 0x05
      f4:	84 17       	cp	r24, r20
      f6:	95 07       	cpc	r25, r21
      f8:	10 f4       	brcc	.+4      	; 0xfe <iq_read+0x28>
      fa:	0c 81       	ldd	r16, Y+4	; 0x04
      fc:	1d 81       	ldd	r17, Y+5	; 0x05
      fe:	6c 85       	ldd	r22, Y+12	; 0x0c
     100:	7d 85       	ldd	r23, Y+13	; 0x0d
     102:	e8 84       	ldd	r14, Y+8	; 0x08
     104:	f9 84       	ldd	r15, Y+9	; 0x09
     106:	e6 1a       	sub	r14, r22
     108:	f7 0a       	sbc	r15, r23
     10a:	0e 15       	cp	r16, r14
     10c:	1f 05       	cpc	r17, r15
     10e:	98 f1       	brcs	.+102    	; 0x176 <iq_read+0xa0>
     110:	e0 16       	cp	r14, r16
     112:	f1 06       	cpc	r15, r17
     114:	d0 f0       	brcs	.+52     	; 0x14a <iq_read+0x74>
     116:	a8 01       	movw	r20, r16
     118:	c6 01       	movw	r24, r12
     11a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     11e:	8e 81       	ldd	r24, Y+6	; 0x06
     120:	9f 81       	ldd	r25, Y+7	; 0x07
     122:	9d 87       	std	Y+13, r25	; 0x0d
     124:	8c 87       	std	Y+12, r24	; 0x0c
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	80 1b       	sub	r24, r16
     12c:	91 0b       	sbc	r25, r17
     12e:	9d 83       	std	Y+5, r25	; 0x05
     130:	8c 83       	std	Y+4, r24	; 0x04
     132:	c8 01       	movw	r24, r16
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	ff 90       	pop	r15
     13e:	ef 90       	pop	r14
     140:	df 90       	pop	r13
     142:	cf 90       	pop	r12
     144:	bf 90       	pop	r11
     146:	af 90       	pop	r10
     148:	08 95       	ret
     14a:	a7 01       	movw	r20, r14
     14c:	c6 01       	movw	r24, r12
     14e:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     152:	58 01       	movw	r10, r16
     154:	ae 18       	sub	r10, r14
     156:	bf 08       	sbc	r11, r15
     158:	6e 81       	ldd	r22, Y+6	; 0x06
     15a:	7f 81       	ldd	r23, Y+7	; 0x07
     15c:	a5 01       	movw	r20, r10
     15e:	c6 01       	movw	r24, r12
     160:	8e 0d       	add	r24, r14
     162:	9f 1d       	adc	r25, r15
     164:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     168:	8e 81       	ldd	r24, Y+6	; 0x06
     16a:	9f 81       	ldd	r25, Y+7	; 0x07
     16c:	a8 0e       	add	r10, r24
     16e:	b9 1e       	adc	r11, r25
     170:	bd 86       	std	Y+13, r11	; 0x0d
     172:	ac 86       	std	Y+12, r10	; 0x0c
     174:	d8 cf       	rjmp	.-80     	; 0x126 <iq_read+0x50>
     176:	a8 01       	movw	r20, r16
     178:	c6 01       	movw	r24, r12
     17a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     17e:	8c 85       	ldd	r24, Y+12	; 0x0c
     180:	9d 85       	ldd	r25, Y+13	; 0x0d
     182:	80 0f       	add	r24, r16
     184:	91 1f       	adc	r25, r17
     186:	9d 87       	std	Y+13, r25	; 0x0d
     188:	8c 87       	std	Y+12, r24	; 0x0c
     18a:	cd cf       	rjmp	.-102    	; 0x126 <iq_read+0x50>

0000018c <oq_write>:
     18c:	af 92       	push	r10
     18e:	bf 92       	push	r11
     190:	cf 92       	push	r12
     192:	df 92       	push	r13
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	0f 93       	push	r16
     19a:	1f 93       	push	r17
     19c:	cf 93       	push	r28
     19e:	df 93       	push	r29
     1a0:	ec 01       	movw	r28, r24
     1a2:	6b 01       	movw	r12, r22
     1a4:	8a 01       	movw	r16, r20
     1a6:	8c 81       	ldd	r24, Y+4	; 0x04
     1a8:	9d 81       	ldd	r25, Y+5	; 0x05
     1aa:	84 17       	cp	r24, r20
     1ac:	95 07       	cpc	r25, r21
     1ae:	10 f4       	brcc	.+4      	; 0x1b4 <oq_write+0x28>
     1b0:	0c 81       	ldd	r16, Y+4	; 0x04
     1b2:	1d 81       	ldd	r17, Y+5	; 0x05
     1b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     1b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     1b8:	e8 84       	ldd	r14, Y+8	; 0x08
     1ba:	f9 84       	ldd	r15, Y+9	; 0x09
     1bc:	e8 1a       	sub	r14, r24
     1be:	f9 0a       	sbc	r15, r25
     1c0:	0e 15       	cp	r16, r14
     1c2:	1f 05       	cpc	r17, r15
     1c4:	98 f1       	brcs	.+102    	; 0x22c <oq_write+0xa0>
     1c6:	e0 16       	cp	r14, r16
     1c8:	f1 06       	cpc	r15, r17
     1ca:	d0 f0       	brcs	.+52     	; 0x200 <oq_write+0x74>
     1cc:	a8 01       	movw	r20, r16
     1ce:	b6 01       	movw	r22, r12
     1d0:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     1d4:	8e 81       	ldd	r24, Y+6	; 0x06
     1d6:	9f 81       	ldd	r25, Y+7	; 0x07
     1d8:	9b 87       	std	Y+11, r25	; 0x0b
     1da:	8a 87       	std	Y+10, r24	; 0x0a
     1dc:	8c 81       	ldd	r24, Y+4	; 0x04
     1de:	9d 81       	ldd	r25, Y+5	; 0x05
     1e0:	80 1b       	sub	r24, r16
     1e2:	91 0b       	sbc	r25, r17
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04
     1e8:	c8 01       	movw	r24, r16
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	1f 91       	pop	r17
     1f0:	0f 91       	pop	r16
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	bf 90       	pop	r11
     1fc:	af 90       	pop	r10
     1fe:	08 95       	ret
     200:	a7 01       	movw	r20, r14
     202:	b6 01       	movw	r22, r12
     204:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     208:	58 01       	movw	r10, r16
     20a:	ae 18       	sub	r10, r14
     20c:	bf 08       	sbc	r11, r15
     20e:	b6 01       	movw	r22, r12
     210:	6e 0d       	add	r22, r14
     212:	7f 1d       	adc	r23, r15
     214:	a5 01       	movw	r20, r10
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f 81       	ldd	r25, Y+7	; 0x07
     21a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     21e:	8e 81       	ldd	r24, Y+6	; 0x06
     220:	9f 81       	ldd	r25, Y+7	; 0x07
     222:	a8 0e       	add	r10, r24
     224:	b9 1e       	adc	r11, r25
     226:	bb 86       	std	Y+11, r11	; 0x0b
     228:	aa 86       	std	Y+10, r10	; 0x0a
     22a:	d8 cf       	rjmp	.-80     	; 0x1dc <oq_write+0x50>
     22c:	a8 01       	movw	r20, r16
     22e:	b6 01       	movw	r22, r12
     230:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <memcpy>
     234:	8a 85       	ldd	r24, Y+10	; 0x0a
     236:	9b 85       	ldd	r25, Y+11	; 0x0b
     238:	80 0f       	add	r24, r16
     23a:	91 1f       	adc	r25, r17
     23c:	9b 87       	std	Y+11, r25	; 0x0b
     23e:	8a 87       	std	Y+10, r24	; 0x0a
     240:	cd cf       	rjmp	.-102    	; 0x1dc <oq_write+0x50>

00000242 <iqObjectInit>:
     242:	af 92       	push	r10
     244:	bf 92       	push	r11
     246:	cf 92       	push	r12
     248:	df 92       	push	r13
     24a:	ef 92       	push	r14
     24c:	ff 92       	push	r15
     24e:	0f 93       	push	r16
     250:	1f 93       	push	r17
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	ec 01       	movw	r28, r24
     258:	7b 01       	movw	r14, r22
     25a:	6a 01       	movw	r12, r20
     25c:	59 01       	movw	r10, r18
     25e:	1d d7       	rcall	.+3642   	; 0x109a <chThdQueueObjectInit>
     260:	1d 82       	std	Y+5, r1	; 0x05
     262:	1c 82       	std	Y+4, r1	; 0x04
     264:	ff 82       	std	Y+7, r15	; 0x07
     266:	ee 82       	std	Y+6, r14	; 0x06
     268:	fd 86       	std	Y+13, r15	; 0x0d
     26a:	ec 86       	std	Y+12, r14	; 0x0c
     26c:	fb 86       	std	Y+11, r15	; 0x0b
     26e:	ea 86       	std	Y+10, r14	; 0x0a
     270:	ec 0c       	add	r14, r12
     272:	fd 1c       	adc	r15, r13
     274:	f9 86       	std	Y+9, r15	; 0x09
     276:	e8 86       	std	Y+8, r14	; 0x08
     278:	bf 86       	std	Y+15, r11	; 0x0f
     27a:	ae 86       	std	Y+14, r10	; 0x0e
     27c:	19 8b       	std	Y+17, r17	; 0x11
     27e:	08 8b       	std	Y+16, r16	; 0x10
     280:	df 91       	pop	r29
     282:	cf 91       	pop	r28
     284:	1f 91       	pop	r17
     286:	0f 91       	pop	r16
     288:	ff 90       	pop	r15
     28a:	ef 90       	pop	r14
     28c:	df 90       	pop	r13
     28e:	cf 90       	pop	r12
     290:	bf 90       	pop	r11
     292:	af 90       	pop	r10
     294:	08 95       	ret

00000296 <iqPutI>:
     296:	fc 01       	movw	r30, r24
     298:	a2 85       	ldd	r26, Z+10	; 0x0a
     29a:	b3 85       	ldd	r27, Z+11	; 0x0b
     29c:	84 85       	ldd	r24, Z+12	; 0x0c
     29e:	95 85       	ldd	r25, Z+13	; 0x0d
     2a0:	a8 17       	cp	r26, r24
     2a2:	b9 07       	cpc	r27, r25
     2a4:	e1 f0       	breq	.+56     	; 0x2de <iqPutI+0x48>
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	95 81       	ldd	r25, Z+5	; 0x05
     2aa:	01 96       	adiw	r24, 0x01	; 1
     2ac:	95 83       	std	Z+5, r25	; 0x05
     2ae:	84 83       	std	Z+4, r24	; 0x04
     2b0:	cd 01       	movw	r24, r26
     2b2:	01 96       	adiw	r24, 0x01	; 1
     2b4:	93 87       	std	Z+11, r25	; 0x0b
     2b6:	82 87       	std	Z+10, r24	; 0x0a
     2b8:	6c 93       	st	X, r22
     2ba:	22 85       	ldd	r18, Z+10	; 0x0a
     2bc:	33 85       	ldd	r19, Z+11	; 0x0b
     2be:	80 85       	ldd	r24, Z+8	; 0x08
     2c0:	91 85       	ldd	r25, Z+9	; 0x09
     2c2:	28 17       	cp	r18, r24
     2c4:	39 07       	cpc	r19, r25
     2c6:	20 f0       	brcs	.+8      	; 0x2d0 <iqPutI+0x3a>
     2c8:	86 81       	ldd	r24, Z+6	; 0x06
     2ca:	97 81       	ldd	r25, Z+7	; 0x07
     2cc:	93 87       	std	Z+11, r25	; 0x0b
     2ce:	82 87       	std	Z+10, r24	; 0x0a
     2d0:	cf 01       	movw	r24, r30
     2d2:	60 e0       	ldi	r22, 0x00	; 0
     2d4:	70 e0       	ldi	r23, 0x00	; 0
     2d6:	04 d7       	rcall	.+3592   	; 0x10e0 <chThdDequeueNextI>
     2d8:	80 e0       	ldi	r24, 0x00	; 0
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	08 95       	ret
     2de:	84 81       	ldd	r24, Z+4	; 0x04
     2e0:	95 81       	ldd	r25, Z+5	; 0x05
     2e2:	89 2b       	or	r24, r25
     2e4:	01 f3       	breq	.-64     	; 0x2a6 <iqPutI+0x10>
     2e6:	8f ef       	ldi	r24, 0xFF	; 255
     2e8:	9f ef       	ldi	r25, 0xFF	; 255
     2ea:	08 95       	ret

000002ec <iqGetTimeout>:
     2ec:	0f 93       	push	r16
     2ee:	1f 93       	push	r17
     2f0:	cf 93       	push	r28
     2f2:	df 93       	push	r29
     2f4:	ec 01       	movw	r28, r24
     2f6:	8b 01       	movw	r16, r22
     2f8:	f8 94       	cli
     2fa:	05 c0       	rjmp	.+10     	; 0x306 <iqGetTimeout+0x1a>
     2fc:	b8 01       	movw	r22, r16
     2fe:	ce 01       	movw	r24, r28
     300:	d2 d6       	rcall	.+3492   	; 0x10a6 <chThdEnqueueTimeoutS>
     302:	97 fd       	sbrc	r25, 7
     304:	27 c0       	rjmp	.+78     	; 0x354 <iqGetTimeout+0x68>
     306:	8c 81       	ldd	r24, Y+4	; 0x04
     308:	9d 81       	ldd	r25, Y+5	; 0x05
     30a:	89 2b       	or	r24, r25
     30c:	b9 f3       	breq	.-18     	; 0x2fc <iqGetTimeout+0x10>
     30e:	8c 81       	ldd	r24, Y+4	; 0x04
     310:	9d 81       	ldd	r25, Y+5	; 0x05
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9d 83       	std	Y+5, r25	; 0x05
     316:	8c 83       	std	Y+4, r24	; 0x04
     318:	ec 85       	ldd	r30, Y+12	; 0x0c
     31a:	fd 85       	ldd	r31, Y+13	; 0x0d
     31c:	cf 01       	movw	r24, r30
     31e:	01 96       	adiw	r24, 0x01	; 1
     320:	9d 87       	std	Y+13, r25	; 0x0d
     322:	8c 87       	std	Y+12, r24	; 0x0c
     324:	10 81       	ld	r17, Z
     326:	28 85       	ldd	r18, Y+8	; 0x08
     328:	39 85       	ldd	r19, Y+9	; 0x09
     32a:	82 17       	cp	r24, r18
     32c:	93 07       	cpc	r25, r19
     32e:	20 f0       	brcs	.+8      	; 0x338 <iqGetTimeout+0x4c>
     330:	8e 81       	ldd	r24, Y+6	; 0x06
     332:	9f 81       	ldd	r25, Y+7	; 0x07
     334:	9d 87       	std	Y+13, r25	; 0x0d
     336:	8c 87       	std	Y+12, r24	; 0x0c
     338:	ee 85       	ldd	r30, Y+14	; 0x0e
     33a:	ff 85       	ldd	r31, Y+15	; 0x0f
     33c:	30 97       	sbiw	r30, 0x00	; 0
     33e:	11 f0       	breq	.+4      	; 0x344 <iqGetTimeout+0x58>
     340:	ce 01       	movw	r24, r28
     342:	09 95       	icall
     344:	78 94       	sei
     346:	81 2f       	mov	r24, r17
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	1f 91       	pop	r17
     350:	0f 91       	pop	r16
     352:	08 95       	ret
     354:	78 94       	sei
     356:	df 91       	pop	r29
     358:	cf 91       	pop	r28
     35a:	1f 91       	pop	r17
     35c:	0f 91       	pop	r16
     35e:	08 95       	ret

00000360 <iqReadTimeout>:
     360:	6f 92       	push	r6
     362:	7f 92       	push	r7
     364:	8f 92       	push	r8
     366:	9f 92       	push	r9
     368:	af 92       	push	r10
     36a:	bf 92       	push	r11
     36c:	cf 92       	push	r12
     36e:	df 92       	push	r13
     370:	ef 92       	push	r14
     372:	ff 92       	push	r15
     374:	0f 93       	push	r16
     376:	1f 93       	push	r17
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	6c 01       	movw	r12, r24
     37e:	7b 01       	movw	r14, r22
     380:	3a 01       	movw	r6, r20
     382:	49 01       	movw	r8, r18
     384:	fc 01       	movw	r30, r24
     386:	a6 84       	ldd	r10, Z+14	; 0x0e
     388:	b7 84       	ldd	r11, Z+15	; 0x0f
     38a:	f8 94       	cli
     38c:	41 15       	cp	r20, r1
     38e:	51 05       	cpc	r21, r1
     390:	b9 f0       	breq	.+46     	; 0x3c0 <iqReadTimeout+0x60>
     392:	8a 01       	movw	r16, r20
     394:	a8 01       	movw	r20, r16
     396:	b7 01       	movw	r22, r14
     398:	c6 01       	movw	r24, r12
     39a:	9d de       	rcall	.-710    	; 0xd6 <iq_read>
     39c:	ec 01       	movw	r28, r24
     39e:	89 2b       	or	r24, r25
     3a0:	21 f1       	breq	.+72     	; 0x3ea <iqReadTimeout+0x8a>
     3a2:	a1 14       	cp	r10, r1
     3a4:	b1 04       	cpc	r11, r1
     3a6:	19 f0       	breq	.+6      	; 0x3ae <iqReadTimeout+0x4e>
     3a8:	c6 01       	movw	r24, r12
     3aa:	f5 01       	movw	r30, r10
     3ac:	09 95       	icall
     3ae:	78 94       	sei
     3b0:	0c 1b       	sub	r16, r28
     3b2:	1d 0b       	sbc	r17, r29
     3b4:	ec 0e       	add	r14, r28
     3b6:	fd 1e       	adc	r15, r29
     3b8:	f8 94       	cli
     3ba:	01 15       	cp	r16, r1
     3bc:	11 05       	cpc	r17, r1
     3be:	51 f7       	brne	.-44     	; 0x394 <iqReadTimeout+0x34>
     3c0:	00 e0       	ldi	r16, 0x00	; 0
     3c2:	10 e0       	ldi	r17, 0x00	; 0
     3c4:	78 94       	sei
     3c6:	c3 01       	movw	r24, r6
     3c8:	80 1b       	sub	r24, r16
     3ca:	91 0b       	sbc	r25, r17
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	08 95       	ret
     3ea:	b4 01       	movw	r22, r8
     3ec:	c6 01       	movw	r24, r12
     3ee:	5b d6       	rcall	.+3254   	; 0x10a6 <chThdEnqueueTimeoutS>
     3f0:	89 2b       	or	r24, r25
     3f2:	81 f2       	breq	.-96     	; 0x394 <iqReadTimeout+0x34>
     3f4:	e7 cf       	rjmp	.-50     	; 0x3c4 <iqReadTimeout+0x64>

000003f6 <oqObjectInit>:
     3f6:	af 92       	push	r10
     3f8:	bf 92       	push	r11
     3fa:	cf 92       	push	r12
     3fc:	df 92       	push	r13
     3fe:	ef 92       	push	r14
     400:	ff 92       	push	r15
     402:	0f 93       	push	r16
     404:	1f 93       	push	r17
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	ec 01       	movw	r28, r24
     40c:	5b 01       	movw	r10, r22
     40e:	7a 01       	movw	r14, r20
     410:	69 01       	movw	r12, r18
     412:	43 d6       	rcall	.+3206   	; 0x109a <chThdQueueObjectInit>
     414:	fd 82       	std	Y+5, r15	; 0x05
     416:	ec 82       	std	Y+4, r14	; 0x04
     418:	bf 82       	std	Y+7, r11	; 0x07
     41a:	ae 82       	std	Y+6, r10	; 0x06
     41c:	bd 86       	std	Y+13, r11	; 0x0d
     41e:	ac 86       	std	Y+12, r10	; 0x0c
     420:	bb 86       	std	Y+11, r11	; 0x0b
     422:	aa 86       	std	Y+10, r10	; 0x0a
     424:	ea 0c       	add	r14, r10
     426:	fb 1c       	adc	r15, r11
     428:	f9 86       	std	Y+9, r15	; 0x09
     42a:	e8 86       	std	Y+8, r14	; 0x08
     42c:	df 86       	std	Y+15, r13	; 0x0f
     42e:	ce 86       	std	Y+14, r12	; 0x0e
     430:	19 8b       	std	Y+17, r17	; 0x11
     432:	08 8b       	std	Y+16, r16	; 0x10
     434:	df 91       	pop	r29
     436:	cf 91       	pop	r28
     438:	1f 91       	pop	r17
     43a:	0f 91       	pop	r16
     43c:	ff 90       	pop	r15
     43e:	ef 90       	pop	r14
     440:	df 90       	pop	r13
     442:	cf 90       	pop	r12
     444:	bf 90       	pop	r11
     446:	af 90       	pop	r10
     448:	08 95       	ret

0000044a <oqPutTimeout>:
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
     456:	f6 2e       	mov	r15, r22
     458:	8a 01       	movw	r16, r20
     45a:	f8 94       	cli
     45c:	05 c0       	rjmp	.+10     	; 0x468 <oqPutTimeout+0x1e>
     45e:	b8 01       	movw	r22, r16
     460:	ce 01       	movw	r24, r28
     462:	21 d6       	rcall	.+3138   	; 0x10a6 <chThdEnqueueTimeoutS>
     464:	97 fd       	sbrc	r25, 7
     466:	2a c0       	rjmp	.+84     	; 0x4bc <oqPutTimeout+0x72>
     468:	8c 81       	ldd	r24, Y+4	; 0x04
     46a:	9d 81       	ldd	r25, Y+5	; 0x05
     46c:	89 2b       	or	r24, r25
     46e:	b9 f3       	breq	.-18     	; 0x45e <oqPutTimeout+0x14>
     470:	8c 81       	ldd	r24, Y+4	; 0x04
     472:	9d 81       	ldd	r25, Y+5	; 0x05
     474:	01 97       	sbiw	r24, 0x01	; 1
     476:	9d 83       	std	Y+5, r25	; 0x05
     478:	8c 83       	std	Y+4, r24	; 0x04
     47a:	ea 85       	ldd	r30, Y+10	; 0x0a
     47c:	fb 85       	ldd	r31, Y+11	; 0x0b
     47e:	cf 01       	movw	r24, r30
     480:	01 96       	adiw	r24, 0x01	; 1
     482:	9b 87       	std	Y+11, r25	; 0x0b
     484:	8a 87       	std	Y+10, r24	; 0x0a
     486:	f0 82       	st	Z, r15
     488:	2a 85       	ldd	r18, Y+10	; 0x0a
     48a:	3b 85       	ldd	r19, Y+11	; 0x0b
     48c:	88 85       	ldd	r24, Y+8	; 0x08
     48e:	99 85       	ldd	r25, Y+9	; 0x09
     490:	28 17       	cp	r18, r24
     492:	39 07       	cpc	r19, r25
     494:	20 f0       	brcs	.+8      	; 0x49e <oqPutTimeout+0x54>
     496:	8e 81       	ldd	r24, Y+6	; 0x06
     498:	9f 81       	ldd	r25, Y+7	; 0x07
     49a:	9b 87       	std	Y+11, r25	; 0x0b
     49c:	8a 87       	std	Y+10, r24	; 0x0a
     49e:	ee 85       	ldd	r30, Y+14	; 0x0e
     4a0:	ff 85       	ldd	r31, Y+15	; 0x0f
     4a2:	30 97       	sbiw	r30, 0x00	; 0
     4a4:	11 f0       	breq	.+4      	; 0x4aa <oqPutTimeout+0x60>
     4a6:	ce 01       	movw	r24, r28
     4a8:	09 95       	icall
     4aa:	78 94       	sei
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	df 91       	pop	r29
     4b2:	cf 91       	pop	r28
     4b4:	1f 91       	pop	r17
     4b6:	0f 91       	pop	r16
     4b8:	ff 90       	pop	r15
     4ba:	08 95       	ret
     4bc:	78 94       	sei
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	08 95       	ret

000004ca <oqGetI>:
     4ca:	cf 93       	push	r28
     4cc:	fc 01       	movw	r30, r24
     4ce:	a4 85       	ldd	r26, Z+12	; 0x0c
     4d0:	b5 85       	ldd	r27, Z+13	; 0x0d
     4d2:	82 85       	ldd	r24, Z+10	; 0x0a
     4d4:	93 85       	ldd	r25, Z+11	; 0x0b
     4d6:	8a 17       	cp	r24, r26
     4d8:	9b 07       	cpc	r25, r27
     4da:	e1 f0       	breq	.+56     	; 0x514 <oqGetI+0x4a>
     4dc:	84 81       	ldd	r24, Z+4	; 0x04
     4de:	95 81       	ldd	r25, Z+5	; 0x05
     4e0:	01 96       	adiw	r24, 0x01	; 1
     4e2:	95 83       	std	Z+5, r25	; 0x05
     4e4:	84 83       	std	Z+4, r24	; 0x04
     4e6:	cd 01       	movw	r24, r26
     4e8:	01 96       	adiw	r24, 0x01	; 1
     4ea:	95 87       	std	Z+13, r25	; 0x0d
     4ec:	84 87       	std	Z+12, r24	; 0x0c
     4ee:	cc 91       	ld	r28, X
     4f0:	20 85       	ldd	r18, Z+8	; 0x08
     4f2:	31 85       	ldd	r19, Z+9	; 0x09
     4f4:	82 17       	cp	r24, r18
     4f6:	93 07       	cpc	r25, r19
     4f8:	40 f4       	brcc	.+16     	; 0x50a <oqGetI+0x40>
     4fa:	cf 01       	movw	r24, r30
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	ef d5       	rcall	.+3038   	; 0x10e0 <chThdDequeueNextI>
     502:	8c 2f       	mov	r24, r28
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	cf 91       	pop	r28
     508:	08 95       	ret
     50a:	86 81       	ldd	r24, Z+6	; 0x06
     50c:	97 81       	ldd	r25, Z+7	; 0x07
     50e:	95 87       	std	Z+13, r25	; 0x0d
     510:	84 87       	std	Z+12, r24	; 0x0c
     512:	f3 cf       	rjmp	.-26     	; 0x4fa <oqGetI+0x30>
     514:	84 81       	ldd	r24, Z+4	; 0x04
     516:	95 81       	ldd	r25, Z+5	; 0x05
     518:	89 2b       	or	r24, r25
     51a:	01 f3       	breq	.-64     	; 0x4dc <oqGetI+0x12>
     51c:	8f ef       	ldi	r24, 0xFF	; 255
     51e:	9f ef       	ldi	r25, 0xFF	; 255
     520:	f2 cf       	rjmp	.-28     	; 0x506 <oqGetI+0x3c>

00000522 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     522:	6f 92       	push	r6
     524:	7f 92       	push	r7
     526:	8f 92       	push	r8
     528:	9f 92       	push	r9
     52a:	af 92       	push	r10
     52c:	bf 92       	push	r11
     52e:	cf 92       	push	r12
     530:	df 92       	push	r13
     532:	ef 92       	push	r14
     534:	ff 92       	push	r15
     536:	0f 93       	push	r16
     538:	1f 93       	push	r17
     53a:	cf 93       	push	r28
     53c:	df 93       	push	r29
     53e:	6c 01       	movw	r12, r24
     540:	7b 01       	movw	r14, r22
     542:	3a 01       	movw	r6, r20
     544:	49 01       	movw	r8, r18
  qnotify_t nfy = oqp->q_notify;
     546:	fc 01       	movw	r30, r24
     548:	a6 84       	ldd	r10, Z+14	; 0x0e
     54a:	b7 84       	ldd	r11, Z+15	; 0x0f
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     54c:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     54e:	41 15       	cp	r20, r1
     550:	51 05       	cpc	r21, r1
     552:	b9 f0       	breq	.+46     	; 0x582 <oqWriteTimeout+0x60>
     554:	8a 01       	movw	r16, r20
    size_t done;

    done = oq_write(oqp, bp, n);
     556:	a8 01       	movw	r20, r16
     558:	b7 01       	movw	r22, r14
     55a:	c6 01       	movw	r24, r12
     55c:	17 de       	rcall	.-978    	; 0x18c <oq_write>
     55e:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     560:	89 2b       	or	r24, r25
     562:	21 f1       	breq	.+72     	; 0x5ac <oqWriteTimeout+0x8a>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     564:	a1 14       	cp	r10, r1
     566:	b1 04       	cpc	r11, r1
     568:	19 f0       	breq	.+6      	; 0x570 <oqWriteTimeout+0x4e>
        nfy(oqp);
     56a:	c6 01       	movw	r24, r12
     56c:	f5 01       	movw	r30, r10
     56e:	09 95       	icall
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     570:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
     572:	0c 1b       	sub	r16, r28
     574:	1d 0b       	sbc	r17, r29
      bp += done;
     576:	ec 0e       	add	r14, r28
     578:	fd 1e       	adc	r15, r29
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
     57a:	f8 94       	cli

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
     57c:	01 15       	cp	r16, r1
     57e:	11 05       	cpc	r17, r1
     580:	51 f7       	brne	.-44     	; 0x556 <oqWriteTimeout+0x34>
     582:	00 e0       	ldi	r16, 0x00	; 0
     584:	10 e0       	ldi	r17, 0x00	; 0
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
     586:	78 94       	sei
    }
  }

  osalSysUnlock();
  return max - n;
}
     588:	c3 01       	movw	r24, r6
     58a:	80 1b       	sub	r24, r16
     58c:	91 0b       	sbc	r25, r17
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	1f 91       	pop	r17
     594:	0f 91       	pop	r16
     596:	ff 90       	pop	r15
     598:	ef 90       	pop	r14
     59a:	df 90       	pop	r13
     59c:	cf 90       	pop	r12
     59e:	bf 90       	pop	r11
     5a0:	af 90       	pop	r10
     5a2:	9f 90       	pop	r9
     5a4:	8f 90       	pop	r8
     5a6:	7f 90       	pop	r7
     5a8:	6f 90       	pop	r6
     5aa:	08 95       	ret
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
     5ac:	b4 01       	movw	r22, r8
     5ae:	c6 01       	movw	r24, r12
     5b0:	7a d5       	rcall	.+2804   	; 0x10a6 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
     5b2:	89 2b       	or	r24, r25
     5b4:	81 f2       	breq	.-96     	; 0x556 <oqWriteTimeout+0x34>
     5b6:	e7 cf       	rjmp	.-50     	; 0x586 <oqWriteTimeout+0x64>

000005b8 <_readt>:
  oqResetI(&sdp->oqueue);
  iqResetI(&sdp->iqueue);
  osalOsRescheduleS();

  osalSysUnlock();
}
     5b8:	05 96       	adiw	r24, 0x05	; 5
     5ba:	d2 ce       	rjmp	.-604    	; 0x360 <iqReadTimeout>

000005bc <_read>:
     5bc:	2f ef       	ldi	r18, 0xFF	; 255
     5be:	3f ef       	ldi	r19, 0xFF	; 255
     5c0:	05 96       	adiw	r24, 0x05	; 5
     5c2:	ce ce       	rjmp	.-612    	; 0x360 <iqReadTimeout>

000005c4 <_writet>:
     5c4:	47 96       	adiw	r24, 0x17	; 23
     5c6:	ad cf       	rjmp	.-166    	; 0x522 <oqWriteTimeout>

000005c8 <_write>:
     5c8:	2f ef       	ldi	r18, 0xFF	; 255
     5ca:	3f ef       	ldi	r19, 0xFF	; 255
     5cc:	47 96       	adiw	r24, 0x17	; 23
     5ce:	a9 cf       	rjmp	.-174    	; 0x522 <oqWriteTimeout>

000005d0 <_gett>:
     5d0:	05 96       	adiw	r24, 0x05	; 5
     5d2:	8c ce       	rjmp	.-744    	; 0x2ec <iqGetTimeout>

000005d4 <_get>:
     5d4:	6f ef       	ldi	r22, 0xFF	; 255
     5d6:	7f ef       	ldi	r23, 0xFF	; 255
     5d8:	05 96       	adiw	r24, 0x05	; 5
     5da:	88 ce       	rjmp	.-752    	; 0x2ec <iqGetTimeout>

000005dc <_putt>:
     5dc:	47 96       	adiw	r24, 0x17	; 23
     5de:	35 cf       	rjmp	.-406    	; 0x44a <oqPutTimeout>

000005e0 <_put>:
     5e0:	4f ef       	ldi	r20, 0xFF	; 255
     5e2:	5f ef       	ldi	r21, 0xFF	; 255
     5e4:	47 96       	adiw	r24, 0x17	; 23
     5e6:	31 cf       	rjmp	.-414    	; 0x44a <oqPutTimeout>

000005e8 <_ctl>:
     5e8:	61 30       	cpi	r22, 0x01	; 1
     5ea:	71 05       	cpc	r23, r1
     5ec:	19 f0       	breq	.+6      	; 0x5f4 <_ctl+0xc>
     5ee:	8c ee       	ldi	r24, 0xEC	; 236
     5f0:	9f ef       	ldi	r25, 0xFF	; 255
     5f2:	08 95       	ret
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	08 95       	ret

000005fa <sdInit>:
     5fa:	55 c1       	rjmp	.+682    	; 0x8a6 <sd_lld_init>

000005fc <sdObjectInit>:
     5fc:	cf 92       	push	r12
     5fe:	df 92       	push	r13
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
     60e:	6b 01       	movw	r12, r22
     610:	7a 01       	movw	r14, r20
     612:	20 e0       	ldi	r18, 0x00	; 0
     614:	31 e0       	ldi	r19, 0x01	; 1
     616:	fc 01       	movw	r30, r24
     618:	21 93       	st	Z+, r18
     61a:	31 93       	st	Z+, r19
     61c:	cf 01       	movw	r24, r30
     61e:	9b d6       	rcall	.+3382   	; 0x1356 <chEvtObjectInit>
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	8c 83       	std	Y+4, r24	; 0x04
     624:	be 01       	movw	r22, r28
     626:	67 5d       	subi	r22, 0xD7	; 215
     628:	7f 4f       	sbci	r23, 0xFF	; 255
     62a:	8e 01       	movw	r16, r28
     62c:	96 01       	movw	r18, r12
     62e:	40 e1       	ldi	r20, 0x10	; 16
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	ce 01       	movw	r24, r28
     634:	05 96       	adiw	r24, 0x05	; 5
     636:	05 de       	rcall	.-1014   	; 0x242 <iqObjectInit>
     638:	be 01       	movw	r22, r28
     63a:	67 5c       	subi	r22, 0xC7	; 199
     63c:	7f 4f       	sbci	r23, 0xFF	; 255
     63e:	97 01       	movw	r18, r14
     640:	40 e1       	ldi	r20, 0x10	; 16
     642:	50 e0       	ldi	r21, 0x00	; 0
     644:	ce 01       	movw	r24, r28
     646:	47 96       	adiw	r24, 0x17	; 23
     648:	d6 de       	rcall	.-596    	; 0x3f6 <oqObjectInit>
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	1f 91       	pop	r17
     650:	0f 91       	pop	r16
     652:	ff 90       	pop	r15
     654:	ef 90       	pop	r14
     656:	df 90       	pop	r13
     658:	cf 90       	pop	r12
     65a:	08 95       	ret

0000065c <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	ec 01       	movw	r28, r24
     664:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
     666:	89 85       	ldd	r24, Y+9	; 0x09
     668:	9a 85       	ldd	r25, Y+10	; 0x0a
     66a:	89 2b       	or	r24, r25
     66c:	51 f0       	breq	.+20     	; 0x682 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     66e:	61 2f       	mov	r22, r17
     670:	ce 01       	movw	r24, r28
     672:	05 96       	adiw	r24, 0x05	; 5
     674:	10 de       	rcall	.-992    	; 0x296 <iqPutI>
     676:	97 fd       	sbrc	r25, 7
     678:	0e c0       	rjmp	.+28     	; 0x696 <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     67a:	df 91       	pop	r29
     67c:	cf 91       	pop	r28
     67e:	1f 91       	pop	r17
     680:	08 95       	ret
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     682:	64 e0       	ldi	r22, 0x04	; 4
     684:	ce 01       	movw	r24, r28
     686:	02 96       	adiw	r24, 0x02	; 2
     688:	80 d6       	rcall	.+3328   	; 0x138a <chEvtBroadcastFlagsI>
  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
     68a:	61 2f       	mov	r22, r17
     68c:	ce 01       	movw	r24, r28
     68e:	05 96       	adiw	r24, 0x05	; 5
     690:	02 de       	rcall	.-1020   	; 0x296 <iqPutI>
     692:	97 ff       	sbrs	r25, 7
     694:	f2 cf       	rjmp	.-28     	; 0x67a <sdIncomingDataI+0x1e>
     696:	60 e0       	ldi	r22, 0x00	; 0
     698:	ce 01       	movw	r24, r28
     69a:	02 96       	adiw	r24, 0x02	; 2
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	1f 91       	pop	r17
     6a2:	73 c6       	rjmp	.+3302   	; 0x138a <chEvtBroadcastFlagsI>

000006a4 <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	cf 93       	push	r28
     6aa:	df 93       	push	r29
     6ac:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
     6ae:	47 96       	adiw	r24, 0x17	; 23
     6b0:	0c df       	rcall	.-488    	; 0x4ca <oqGetI>
     6b2:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
     6b4:	97 fd       	sbrc	r25, 7
     6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
     6b8:	ce 01       	movw	r24, r28
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	08 95       	ret
     6c4:	68 e0       	ldi	r22, 0x08	; 8
     6c6:	c8 01       	movw	r24, r16
     6c8:	02 96       	adiw	r24, 0x02	; 2
     6ca:	5f d6       	rcall	.+3262   	; 0x138a <chEvtBroadcastFlagsI>
     6cc:	ce 01       	movw	r24, r28
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	1f 91       	pop	r17
     6d4:	0f 91       	pop	r16
     6d6:	08 95       	ret

000006d8 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
     6d8:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7f8069>
  EIMSK  = 0x00;
     6dc:	1d ba       	out	0x1d, r1	; 29
     6de:	08 95       	ret

000006e0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
     6e0:	08 95       	ret

000006e2 <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
     6e2:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
     6e4:	80 81       	ld	r24, Z
     6e6:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
     6e8:	81 81       	ldd	r24, Z+1	; 0x01
     6ea:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
     6ec:	82 81       	ldd	r24, Z+2	; 0x02
     6ee:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
     6f0:	83 81       	ldd	r24, Z+3	; 0x03
     6f2:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
     6f4:	84 81       	ldd	r24, Z+4	; 0x04
     6f6:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
     6f8:	85 81       	ldd	r24, Z+5	; 0x05
     6fa:	8a b9       	out	0x0a, r24	; 10
     6fc:	08 95       	ret

000006fe <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
     6fe:	fc 01       	movw	r30, r24

  switch (mode) {
     700:	42 30       	cpi	r20, 0x02	; 2
     702:	c9 f0       	breq	.+50     	; 0x736 <_pal_lld_setgroupmode+0x38>
     704:	98 f0       	brcs	.+38     	; 0x72c <_pal_lld_setgroupmode+0x2e>
     706:	45 30       	cpi	r20, 0x05	; 5
     708:	b1 f0       	breq	.+44     	; 0x736 <_pal_lld_setgroupmode+0x38>
     70a:	46 30       	cpi	r20, 0x06	; 6
     70c:	21 f4       	brne	.+8      	; 0x716 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
     70e:	81 81       	ldd	r24, Z+1	; 0x01
     710:	68 2b       	or	r22, r24
     712:	61 83       	std	Z+1, r22	; 0x01
     714:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     716:	43 30       	cpi	r20, 0x03	; 3
     718:	e9 f7       	brne	.-6      	; 0x714 <_pal_lld_setgroupmode+0x16>
    port->dir &= ~mask;
    port->out &= ~mask;
    break;
  case PAL_MODE_UNCONNECTED:
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
     71a:	81 81       	ldd	r24, Z+1	; 0x01
     71c:	96 2f       	mov	r25, r22
     71e:	90 95       	com	r25
     720:	89 23       	and	r24, r25
     722:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
     724:	82 81       	ldd	r24, Z+2	; 0x02
     726:	68 2b       	or	r22, r24
     728:	62 83       	std	Z+2, r22	; 0x02
    break;
     72a:	08 95       	ret
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  switch (mode) {
     72c:	44 23       	and	r20, r20
     72e:	19 f0       	breq	.+6      	; 0x736 <_pal_lld_setgroupmode+0x38>
     730:	41 30       	cpi	r20, 0x01	; 1
     732:	99 f3       	breq	.-26     	; 0x71a <_pal_lld_setgroupmode+0x1c>
     734:	08 95       	ret
  case PAL_MODE_RESET:
  case PAL_MODE_INPUT:
  case PAL_MODE_INPUT_ANALOG:
    port->dir &= ~mask;
     736:	81 81       	ldd	r24, Z+1	; 0x01
     738:	60 95       	com	r22
     73a:	86 23       	and	r24, r22
     73c:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
     73e:	82 81       	ldd	r24, Z+2	; 0x02
     740:	68 23       	and	r22, r24
     742:	62 83       	std	Z+2, r22	; 0x02
    break;
     744:	08 95       	ret

00000746 <__vector_14>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for periodic mode.
 */
OSAL_IRQ_HANDLER(AVR_TIMER_VECT) {
     746:	1f 92       	push	r1
     748:	0f 92       	push	r0
     74a:	0f b6       	in	r0, 0x3f	; 63
     74c:	0f 92       	push	r0
     74e:	11 24       	eor	r1, r1
     750:	2f 93       	push	r18
     752:	3f 93       	push	r19
     754:	4f 93       	push	r20
     756:	5f 93       	push	r21
     758:	6f 93       	push	r22
     75a:	7f 93       	push	r23
     75c:	8f 93       	push	r24
     75e:	9f 93       	push	r25
     760:	af 93       	push	r26
     762:	bf 93       	push	r27
     764:	ef 93       	push	r30
     766:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
     76e:	b7 d0       	rcall	.+366    	; 0x8de <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     770:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     774:	a4 d2       	rcall	.+1352   	; 0xcbe <chSchIsPreemptionRequired>
     776:	81 11       	cpse	r24, r1
     778:	b2 d2       	rcall	.+1380   	; 0xcde <chSchDoPreemption>
}
     77a:	ff 91       	pop	r31
     77c:	ef 91       	pop	r30
     77e:	bf 91       	pop	r27
     780:	af 91       	pop	r26
     782:	9f 91       	pop	r25
     784:	8f 91       	pop	r24
     786:	7f 91       	pop	r23
     788:	6f 91       	pop	r22
     78a:	5f 91       	pop	r21
     78c:	4f 91       	pop	r20
     78e:	3f 91       	pop	r19
     790:	2f 91       	pop	r18
     792:	0f 90       	pop	r0
     794:	0f be       	out	0x3f, r0	; 63
     796:	0f 90       	pop	r0
     798:	1f 90       	pop	r1
     79a:	18 95       	reti

0000079c <st_lld_init>:

  /*
   * Periodic mode uses Timer 0 (8 bit).
   */
#if defined(TCCR0B) /* Timer has multiple output comparators.               */
  TCCR0A  = (1 << WGM01) | (0 << WGM00) |                /* CTC mode.       */
     79c:	82 e0       	ldi	r24, 0x02	; 2
     79e:	84 bd       	out	0x24, r24	; 36
            (0 << COM0A1) | (0 << COM0A0) |              /* OC0A disabled.  */
            (0 << COM0B1) | (0 << COM0B0);               /* OC0B disabled.  */
  TCCR0B  = (0 << WGM02) | AVR_TIMER_PRESCALER_BITS;     /* CTC mode.       */
     7a0:	85 bd       	out	0x25, r24	; 37
  OCR0A   = AVR_TIMER_COUNTER - 1;
     7a2:	9f e7       	ldi	r25, 0x7F	; 127
     7a4:	97 bd       	out	0x27, r25	; 39
  TCNT0   = 0;                                           /* Reset counter.  */
     7a6:	16 bc       	out	0x26, r1	; 38
  TIFR0   = (1 << OCF0A);                                /* Reset pending.  */
     7a8:	85 bb       	out	0x15, r24	; 21
  TIMSK0  = (1 << OCIE0A);                               /* IRQ on compare. */
     7aa:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
     7ae:	08 95       	ret

000007b0 <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
     7b0:	e1 ec       	ldi	r30, 0xC1	; 193
     7b2:	f0 e0       	ldi	r31, 0x00	; 0
     7b4:	80 81       	ld	r24, Z
     7b6:	80 62       	ori	r24, 0x20	; 32
     7b8:	80 83       	st	Z, r24
     7ba:	08 95       	ret

000007bc <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
     7bc:	1f 92       	push	r1
     7be:	0f 92       	push	r0
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	0f 92       	push	r0
     7c4:	11 24       	eor	r1, r1
     7c6:	2f 93       	push	r18
     7c8:	3f 93       	push	r19
     7ca:	4f 93       	push	r20
     7cc:	5f 93       	push	r21
     7ce:	6f 93       	push	r22
     7d0:	7f 93       	push	r23
     7d2:	8f 93       	push	r24
     7d4:	9f 93       	push	r25
     7d6:	af 93       	push	r26
     7d8:	bf 93       	push	r27
     7da:	ef 93       	push	r30
     7dc:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>

  sra = UCSR0A;
     7e4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
     7e8:	98 2f       	mov	r25, r24
     7ea:	9c 71       	andi	r25, 0x1C	; 28
     7ec:	41 f0       	breq	.+16     	; 0x7fe <__vector_18+0x42>
  }
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
     7ee:	82 fd       	sbrc	r24, 2
     7f0:	21 c0       	rjmp	.+66     	; 0x834 <__DATA_REGION_LENGTH__+0x34>
     7f2:	60 e0       	ldi	r22, 0x00	; 0
    sts |= SD_PARITY_ERROR;
  if (sra & fe)
     7f4:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
     7f6:	60 64       	ori	r22, 0x40	; 64
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
     7f8:	89 e3       	ldi	r24, 0x39	; 57
     7fa:	94 e0       	ldi	r25, 0x04	; 4
     7fc:	c6 d5       	rcall	.+2956   	; 0x138a <chEvtBroadcastFlagsI>

  sra = UCSR0A;
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
     7fe:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     802:	87 e3       	ldi	r24, 0x37	; 55
     804:	94 e0       	ldi	r25, 0x04	; 4
     806:	2a df       	rcall	.-428    	; 0x65c <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
     808:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     80c:	58 d2       	rcall	.+1200   	; 0xcbe <chSchIsPreemptionRequired>
     80e:	81 11       	cpse	r24, r1
     810:	66 d2       	rcall	.+1228   	; 0xcde <chSchDoPreemption>
}
     812:	ff 91       	pop	r31
     814:	ef 91       	pop	r30
     816:	bf 91       	pop	r27
     818:	af 91       	pop	r26
     81a:	9f 91       	pop	r25
     81c:	8f 91       	pop	r24
     81e:	7f 91       	pop	r23
     820:	6f 91       	pop	r22
     822:	5f 91       	pop	r21
     824:	4f 91       	pop	r20
     826:	3f 91       	pop	r19
     828:	2f 91       	pop	r18
     82a:	0f 90       	pop	r0
     82c:	0f be       	out	0x3f, r0	; 63
     82e:	0f 90       	pop	r0
     830:	1f 90       	pop	r1
     832:	18 95       	reti
#endif

  if (sra & dor)
    sts |= SD_OVERRUN_ERROR;
  if (sra & upe)
    sts |= SD_PARITY_ERROR;
     834:	60 e2       	ldi	r22, 0x20	; 32
     836:	de cf       	rjmp	.-68     	; 0x7f4 <__vector_18+0x38>

00000838 <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
     838:	1f 92       	push	r1
     83a:	0f 92       	push	r0
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	0f 92       	push	r0
     840:	11 24       	eor	r1, r1
     842:	2f 93       	push	r18
     844:	3f 93       	push	r19
     846:	4f 93       	push	r20
     848:	5f 93       	push	r21
     84a:	6f 93       	push	r22
     84c:	7f 93       	push	r23
     84e:	8f 93       	push	r24
     850:	9f 93       	push	r25
     852:	af 93       	push	r26
     854:	bf 93       	push	r27
     856:	ef 93       	push	r30
     858:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
     860:	87 e3       	ldi	r24, 0x37	; 55
     862:	94 e0       	ldi	r25, 0x04	; 4
     864:	1f df       	rcall	.-450    	; 0x6a4 <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
     866:	97 fd       	sbrc	r25, 7
     868:	18 c0       	rjmp	.+48     	; 0x89a <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
     86a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>

  OSAL_IRQ_EPILOGUE();
     86e:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <__avr_in_isr>
     872:	25 d2       	rcall	.+1098   	; 0xcbe <chSchIsPreemptionRequired>
     874:	81 11       	cpse	r24, r1
     876:	33 d2       	rcall	.+1126   	; 0xcde <chSchDoPreemption>
}
     878:	ff 91       	pop	r31
     87a:	ef 91       	pop	r30
     87c:	bf 91       	pop	r27
     87e:	af 91       	pop	r26
     880:	9f 91       	pop	r25
     882:	8f 91       	pop	r24
     884:	7f 91       	pop	r23
     886:	6f 91       	pop	r22
     888:	5f 91       	pop	r21
     88a:	4f 91       	pop	r20
     88c:	3f 91       	pop	r19
     88e:	2f 91       	pop	r18
     890:	0f 90       	pop	r0
     892:	0f be       	out	0x3f, r0	; 63
     894:	0f 90       	pop	r0
     896:	1f 90       	pop	r1
     898:	18 95       	reti

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    UCSR0B &= ~(1 << UDRIE0);
     89a:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     89e:	8f 7d       	andi	r24, 0xDF	; 223
     8a0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     8a4:	e4 cf       	rjmp	.-56     	; 0x86e <__vector_19+0x36>

000008a6 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
     8a6:	48 ed       	ldi	r20, 0xD8	; 216
     8a8:	53 e0       	ldi	r21, 0x03	; 3
     8aa:	60 e0       	ldi	r22, 0x00	; 0
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	87 e3       	ldi	r24, 0x37	; 55
     8b0:	94 e0       	ldi	r25, 0x04	; 4
     8b2:	a4 ce       	rjmp	.-696    	; 0x5fc <sdObjectInit>

000008b4 <chSysInit>:
    /* Registry header, access to this list depends on the current
       kernel configuration.*/
    rqp = REG_HEADER(oip);

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	c0 e8       	ldi	r28, 0x80	; 128
     8ba:	d4 e0       	ldi	r29, 0x04	; 4
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	88 83       	st	Y, r24
     8c0:	1a 82       	std	Y+2, r1	; 0x02
     8c2:	19 82       	std	Y+1, r1	; 0x01
     8c4:	87 d5       	rcall	.+2830   	; 0x13d4 <__core_init>
     8c6:	c7 d5       	rcall	.+2958   	; 0x1456 <__heap_init>
     8c8:	6d e1       	ldi	r22, 0x1D	; 29
     8ca:	71 e0       	ldi	r23, 0x01	; 1
     8cc:	83 e8       	ldi	r24, 0x83	; 131
     8ce:	94 e0       	ldi	r25, 0x04	; 4
     8d0:	56 d2       	rcall	.+1196   	; 0xd7e <chInstanceObjectInit>
     8d2:	82 e0       	ldi	r24, 0x02	; 2
     8d4:	88 83       	st	Y, r24
     8d6:	78 94       	sei
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
     8de:	68 c0       	rjmp	.+208    	; 0x9b0 <chVTDoTickI>

000008e0 <chVTDoSetI>:
    dlp = dlp->next;
  } while (dlp != &vtlp->dlist);

  chDbgAssert(false, "timer not in list");

  return (sysinterval_t)-1;
     8e0:	cf 93       	push	r28
     8e2:	df 93       	push	r29
     8e4:	dc 01       	movw	r26, r24
     8e6:	19 96       	adiw	r26, 0x09	; 9
     8e8:	3c 93       	st	X, r19
     8ea:	2e 93       	st	-X, r18
     8ec:	18 97       	sbiw	r26, 0x08	; 8
     8ee:	17 96       	adiw	r26, 0x07	; 7
     8f0:	5c 93       	st	X, r21
     8f2:	4e 93       	st	-X, r20
     8f4:	16 97       	sbiw	r26, 0x06	; 6
     8f6:	1b 96       	adiw	r26, 0x0b	; 11
     8f8:	1c 92       	st	X, r1
     8fa:	1e 92       	st	-X, r1
     8fc:	1a 97       	sbiw	r26, 0x0a	; 10
     8fe:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <ch0+0x7>
     902:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <ch0+0x8>
     906:	24 81       	ldd	r18, Z+4	; 0x04
     908:	35 81       	ldd	r19, Z+5	; 0x05
     90a:	26 17       	cp	r18, r22
     90c:	37 07       	cpc	r19, r23
     90e:	50 f4       	brcc	.+20     	; 0x924 <__stack+0x25>
     910:	62 1b       	sub	r22, r18
     912:	73 0b       	sbc	r23, r19
     914:	01 90       	ld	r0, Z+
     916:	f0 81       	ld	r31, Z
     918:	e0 2d       	mov	r30, r0
     91a:	24 81       	ldd	r18, Z+4	; 0x04
     91c:	35 81       	ldd	r19, Z+5	; 0x05
     91e:	26 17       	cp	r18, r22
     920:	37 07       	cpc	r19, r23
     922:	b0 f3       	brcs	.-20     	; 0x910 <__stack+0x11>
     924:	15 96       	adiw	r26, 0x05	; 5
     926:	7c 93       	st	X, r23
     928:	6e 93       	st	-X, r22
     92a:	14 97       	sbiw	r26, 0x04	; 4
     92c:	11 96       	adiw	r26, 0x01	; 1
     92e:	fc 93       	st	X, r31
     930:	ee 93       	st	-X, r30
     932:	c2 81       	ldd	r28, Z+2	; 0x02
     934:	d3 81       	ldd	r29, Z+3	; 0x03
     936:	13 96       	adiw	r26, 0x03	; 3
     938:	dc 93       	st	X, r29
     93a:	ce 93       	st	-X, r28
     93c:	12 97       	sbiw	r26, 0x02	; 2
     93e:	b9 83       	std	Y+1, r27	; 0x01
     940:	a8 83       	st	Y, r26
     942:	b3 83       	std	Z+3, r27	; 0x03
     944:	a2 83       	std	Z+2, r26	; 0x02
     946:	84 81       	ldd	r24, Z+4	; 0x04
     948:	95 81       	ldd	r25, Z+5	; 0x05
     94a:	86 1b       	sub	r24, r22
     94c:	97 0b       	sbc	r25, r23
     94e:	95 83       	std	Z+5, r25	; 0x05
     950:	84 83       	std	Z+4, r24	; 0x04
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	9f ef       	ldi	r25, 0xFF	; 255
     956:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <ch0+0xc>
     95a:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <ch0+0xb>
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	08 95       	ret

00000964 <chVTDoResetI>:
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	fc 01       	movw	r30, r24
     96a:	a0 81       	ld	r26, Z
     96c:	b1 81       	ldd	r27, Z+1	; 0x01
     96e:	14 96       	adiw	r26, 0x04	; 4
     970:	2d 91       	ld	r18, X+
     972:	3c 91       	ld	r19, X
     974:	15 97       	sbiw	r26, 0x05	; 5
     976:	84 81       	ldd	r24, Z+4	; 0x04
     978:	95 81       	ldd	r25, Z+5	; 0x05
     97a:	82 0f       	add	r24, r18
     97c:	93 1f       	adc	r25, r19
     97e:	15 96       	adiw	r26, 0x05	; 5
     980:	9c 93       	st	X, r25
     982:	8e 93       	st	-X, r24
     984:	14 97       	sbiw	r26, 0x04	; 4
     986:	c2 81       	ldd	r28, Z+2	; 0x02
     988:	d3 81       	ldd	r29, Z+3	; 0x03
     98a:	b9 83       	std	Y+1, r27	; 0x01
     98c:	a8 83       	st	Y, r26
     98e:	a0 81       	ld	r26, Z
     990:	b1 81       	ldd	r27, Z+1	; 0x01
     992:	13 96       	adiw	r26, 0x03	; 3
     994:	dc 93       	st	X, r29
     996:	ce 93       	st	-X, r28
     998:	12 97       	sbiw	r26, 0x02	; 2
     99a:	11 82       	std	Z+1, r1	; 0x01
     99c:	10 82       	st	Z, r1
     99e:	8f ef       	ldi	r24, 0xFF	; 255
     9a0:	9f ef       	ldi	r25, 0xFF	; 255
     9a2:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <ch0+0xc>
     9a6:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <ch0+0xb>
     9aa:	df 91       	pop	r29
     9ac:	cf 91       	pop	r28
     9ae:	08 95       	ret

000009b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
     9b0:	0f 93       	push	r16
     9b2:	1f 93       	push	r17
     9b4:	cf 93       	push	r28
     9b6:	df 93       	push	r29
  virtual_timers_list_t *vtlp = &currcore->vtlist;

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
     9b8:	80 91 90 04 	lds	r24, 0x0490	; 0x800490 <ch0+0xd>
     9bc:	90 91 91 04 	lds	r25, 0x0491	; 0x800491 <ch0+0xe>
     9c0:	01 96       	adiw	r24, 0x01	; 1
     9c2:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <ch0+0xe>
     9c6:	80 93 90 04 	sts	0x0490, r24	; 0x800490 <ch0+0xd>
 *
 * @notapi
 */
static inline bool ch_dlist_notempty(ch_delta_list_t *dlhp) {

  return (bool)(dlhp != dlhp->next);
     9ca:	c0 91 8a 04 	lds	r28, 0x048A	; 0x80048a <ch0+0x7>
     9ce:	d0 91 8b 04 	lds	r29, 0x048B	; 0x80048b <ch0+0x8>
  if (ch_dlist_notempty(&vtlp->dlist)) {
     9d2:	44 e0       	ldi	r20, 0x04	; 4
     9d4:	ca 38       	cpi	r28, 0x8A	; 138
     9d6:	d4 07       	cpc	r29, r20
     9d8:	41 f1       	breq	.+80     	; 0xa2a <chVTDoTickI+0x7a>
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
     9da:	8c 81       	ldd	r24, Y+4	; 0x04
     9dc:	9d 81       	ldd	r25, Y+5	; 0x05
     9de:	01 97       	sbiw	r24, 0x01	; 1
     9e0:	9d 83       	std	Y+5, r25	; 0x05
     9e2:	8c 83       	std	Y+4, r24	; 0x04
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     9e4:	0f ef       	ldi	r16, 0xFF	; 255
     9e6:	1f ef       	ldi	r17, 0xFF	; 255
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     9e8:	1e c0       	rjmp	.+60     	; 0xa26 <chVTDoTickI+0x76>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
     9ea:	ea 81       	ldd	r30, Y+2	; 0x02
     9ec:	fb 81       	ldd	r31, Y+3	; 0x03
     9ee:	88 81       	ld	r24, Y
     9f0:	99 81       	ldd	r25, Y+1	; 0x01
     9f2:	91 83       	std	Z+1, r25	; 0x01
     9f4:	80 83       	st	Z, r24
  dlp->next->prev = dlp->prev;
     9f6:	a8 81       	ld	r26, Y
     9f8:	b9 81       	ldd	r27, Y+1	; 0x01
     9fa:	13 96       	adiw	r26, 0x03	; 3
     9fc:	fc 93       	st	X, r31
     9fe:	ee 93       	st	-X, r30
     a00:	12 97       	sbiw	r26, 0x02	; 2
      /* Triggered timer.*/
      vtp = (virtual_timer_t *)vtlp->dlist.next;

      /* Removing the element from the delta list, marking it as not armed.*/
      (void) ch_dlist_dequeue(&vtp->dlist);
      vtp->dlist.next = NULL;
     a02:	19 82       	std	Y+1, r1	; 0x01
     a04:	18 82       	st	Y, r1

      chSysUnlockFromISR();
      vtp->func(vtp, vtp->par);
     a06:	68 85       	ldd	r22, Y+8	; 0x08
     a08:	79 85       	ldd	r23, Y+9	; 0x09
     a0a:	ee 81       	ldd	r30, Y+6	; 0x06
     a0c:	ff 81       	ldd	r31, Y+7	; 0x07
     a0e:	ce 01       	movw	r24, r28
     a10:	09 95       	icall
      chSysLockFromISR();

      /* If a reload is defined the timer needs to be restarted.*/
      if (vtp->reload > (sysinterval_t)0) {
     a12:	8a 85       	ldd	r24, Y+10	; 0x0a
     a14:	9b 85       	ldd	r25, Y+11	; 0x0b
     a16:	00 97       	sbiw	r24, 0x00	; 0
     a18:	69 f4       	brne	.+26     	; 0xa34 <chVTDoTickI+0x84>
     a1a:	c0 91 8a 04 	lds	r28, 0x048A	; 0x80048a <ch0+0x7>
     a1e:	d0 91 8b 04 	lds	r29, 0x048B	; 0x80048b <ch0+0x8>
     a22:	8c 81       	ldd	r24, Y+4	; 0x04
     a24:	9d 81       	ldd	r25, Y+5	; 0x05
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime++;
  if (ch_dlist_notempty(&vtlp->dlist)) {
    /* The list is not empty, processing elements on top.*/
    --vtlp->dlist.next->delta;
    while (vtlp->dlist.next->delta == (sysinterval_t)0) {
     a26:	89 2b       	or	r24, r25
     a28:	01 f3       	breq	.-64     	; 0x9ea <chVTDoTickI+0x3a>
  vtp->dlist.delta -= nowdelta;

  /* Update alarm time to next timer.*/
  vt_set_alarm(vtlp, now, vtp->dlist.delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	1f 91       	pop	r17
     a30:	0f 91       	pop	r16
     a32:	08 95       	ret
     a34:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <ch0+0x7>
     a38:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <ch0+0x8>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a3c:	24 81       	ldd	r18, Z+4	; 0x04
     a3e:	35 81       	ldd	r19, Z+5	; 0x05
     a40:	28 17       	cp	r18, r24
     a42:	39 07       	cpc	r19, r25
     a44:	50 f4       	brcc	.+20     	; 0xa5a <chVTDoTickI+0xaa>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
     a46:	82 1b       	sub	r24, r18
     a48:	93 0b       	sbc	r25, r19
    dlp = dlp->next;
     a4a:	01 90       	ld	r0, Z+
     a4c:	f0 81       	ld	r31, Z
     a4e:	e0 2d       	mov	r30, r0
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
     a50:	24 81       	ldd	r18, Z+4	; 0x04
     a52:	35 81       	ldd	r19, Z+5	; 0x05
     a54:	28 17       	cp	r18, r24
     a56:	39 07       	cpc	r19, r25
     a58:	b0 f3       	brcs	.-20     	; 0xa46 <chVTDoTickI+0x96>
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {

  dlp->delta      = delta;
     a5a:	9d 83       	std	Y+5, r25	; 0x05
     a5c:	8c 83       	std	Y+4, r24	; 0x04
  dlp->next       = dlhp;
     a5e:	f9 83       	std	Y+1, r31	; 0x01
     a60:	e8 83       	st	Y, r30
  dlp->prev       = dlp->next->prev;
     a62:	a2 81       	ldd	r26, Z+2	; 0x02
     a64:	b3 81       	ldd	r27, Z+3	; 0x03
     a66:	bb 83       	std	Y+3, r27	; 0x03
     a68:	aa 83       	std	Y+2, r26	; 0x02
  dlp->prev->next = dlp;
     a6a:	cd 93       	st	X+, r28
     a6c:	dc 93       	st	X, r29
  dlhp->prev      = dlp;
     a6e:	d3 83       	std	Z+3, r29	; 0x03
     a70:	c2 83       	std	Z+2, r28	; 0x02

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
     a72:	24 81       	ldd	r18, Z+4	; 0x04
     a74:	35 81       	ldd	r19, Z+5	; 0x05
     a76:	a9 01       	movw	r20, r18
     a78:	48 1b       	sub	r20, r24
     a7a:	59 0b       	sbc	r21, r25
     a7c:	55 83       	std	Z+5, r21	; 0x05
     a7e:	44 83       	std	Z+4, r20	; 0x04

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
     a80:	10 93 8f 04 	sts	0x048F, r17	; 0x80048f <ch0+0xc>
     a84:	00 93 8e 04 	sts	0x048E, r16	; 0x80048e <ch0+0xb>
     a88:	c8 cf       	rjmp	.-112    	; 0xa1a <chVTDoTickI+0x6a>

00000a8a <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
     a8a:	cf 93       	push	r28
     a8c:	df 93       	push	r29
     a8e:	db 01       	movw	r26, r22
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     a90:	1f 96       	adiw	r26, 0x0f	; 15
     a92:	8c 91       	ld	r24, X
     a94:	1f 97       	sbiw	r26, 0x0f	; 15
     a96:	84 30       	cpi	r24, 0x04	; 4
     a98:	f1 f1       	breq	.+124    	; 0xb16 <__sch_wakeup+0x8c>
     a9a:	80 f5       	brcc	.+96     	; 0xafc <__sch_wakeup+0x72>
     a9c:	88 23       	and	r24, r24
     a9e:	59 f1       	breq	.+86     	; 0xaf6 <__sch_wakeup+0x6c>
     aa0:	83 30       	cpi	r24, 0x03	; 3
     aa2:	31 f4       	brne	.+12     	; 0xab0 <__sch_wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     aa4:	52 96       	adiw	r26, 0x12	; 18
     aa6:	ed 91       	ld	r30, X+
     aa8:	fc 91       	ld	r31, X
     aaa:	53 97       	sbiw	r26, 0x13	; 19
     aac:	11 82       	std	Z+1, r1	; 0x01
     aae:	10 82       	st	Z, r1
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
     ab0:	8f ef       	ldi	r24, 0xFF	; 255
     ab2:	9f ef       	ldi	r25, 0xFF	; 255
     ab4:	53 96       	adiw	r26, 0x13	; 19
     ab6:	9c 93       	st	X, r25
     ab8:	8e 93       	st	-X, r24
     aba:	52 97       	sbiw	r26, 0x12	; 18

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     abc:	1f 96       	adiw	r26, 0x0f	; 15
     abe:	1c 92       	st	X, r1
     ac0:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     ac2:	1b 96       	adiw	r26, 0x0b	; 11
     ac4:	ed 91       	ld	r30, X+
     ac6:	fc 91       	ld	r31, X
     ac8:	1c 97       	sbiw	r26, 0x0c	; 12
     aca:	14 96       	adiw	r26, 0x04	; 4
     acc:	9c 91       	ld	r25, X
     ace:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     ad0:	01 90       	ld	r0, Z+
     ad2:	f0 81       	ld	r31, Z
     ad4:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     ad6:	84 81       	ldd	r24, Z+4	; 0x04
     ad8:	89 17       	cp	r24, r25
     ada:	d0 f7       	brcc	.-12     	; 0xad0 <__sch_wakeup+0x46>

  /* Insertion on prev.*/
  p->next       = pqp;
     adc:	11 96       	adiw	r26, 0x01	; 1
     ade:	fc 93       	st	X, r31
     ae0:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     ae2:	c2 81       	ldd	r28, Z+2	; 0x02
     ae4:	d3 81       	ldd	r29, Z+3	; 0x03
     ae6:	13 96       	adiw	r26, 0x03	; 3
     ae8:	dc 93       	st	X, r29
     aea:	ce 93       	st	-X, r28
     aec:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     aee:	b9 83       	std	Y+1, r27	; 0x01
     af0:	a8 83       	st	Y, r26
  pqp->prev     = p;
     af2:	b3 83       	std	Z+3, r27	; 0x03
     af4:	a2 83       	std	Z+2, r26	; 0x02
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	08 95       	ret
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
     afc:	87 30       	cpi	r24, 0x07	; 7
     afe:	59 f0       	breq	.+22     	; 0xb16 <__sch_wakeup+0x8c>
     b00:	8c 30       	cpi	r24, 0x0C	; 12
     b02:	49 f0       	breq	.+18     	; 0xb16 <__sch_wakeup+0x8c>
     b04:	85 30       	cpi	r24, 0x05	; 5
     b06:	a1 f6       	brne	.-88     	; 0xab0 <__sch_wakeup+0x26>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
     b08:	52 96       	adiw	r26, 0x12	; 18
     b0a:	ed 91       	ld	r30, X+
     b0c:	fc 91       	ld	r31, X
     b0e:	53 97       	sbiw	r26, 0x13	; 19
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     b10:	84 81       	ldd	r24, Z+4	; 0x04
     b12:	8f 5f       	subi	r24, 0xFF	; 255
     b14:	84 83       	std	Z+4, r24	; 0x04
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
     b16:	12 96       	adiw	r26, 0x02	; 2
     b18:	ed 91       	ld	r30, X+
     b1a:	fc 91       	ld	r31, X
     b1c:	13 97       	sbiw	r26, 0x03	; 3
     b1e:	8d 91       	ld	r24, X+
     b20:	9c 91       	ld	r25, X
     b22:	11 97       	sbiw	r26, 0x01	; 1
     b24:	91 83       	std	Z+1, r25	; 0x01
     b26:	80 83       	st	Z, r24
  p->next->prev = p->prev;
     b28:	cd 91       	ld	r28, X+
     b2a:	dc 91       	ld	r29, X
     b2c:	11 97       	sbiw	r26, 0x01	; 1
     b2e:	fb 83       	std	Y+3, r31	; 0x03
     b30:	ea 83       	std	Y+2, r30	; 0x02
     b32:	be cf       	rjmp	.-132    	; 0xab0 <__sch_wakeup+0x26>

00000b34 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	dc 01       	movw	r26, r24

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     b3a:	1f 96       	adiw	r26, 0x0f	; 15
     b3c:	1c 92       	st	X, r1
     b3e:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     b40:	1b 96       	adiw	r26, 0x0b	; 11
     b42:	ed 91       	ld	r30, X+
     b44:	fc 91       	ld	r31, X
     b46:	1c 97       	sbiw	r26, 0x0c	; 12
     b48:	14 96       	adiw	r26, 0x04	; 4
     b4a:	2c 91       	ld	r18, X
     b4c:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     b4e:	01 90       	ld	r0, Z+
     b50:	f0 81       	ld	r31, Z
     b52:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     b54:	94 81       	ldd	r25, Z+4	; 0x04
     b56:	92 17       	cp	r25, r18
     b58:	d0 f7       	brcc	.-12     	; 0xb4e <chSchReadyI+0x1a>

  /* Insertion on prev.*/
  p->next       = pqp;
     b5a:	11 96       	adiw	r26, 0x01	; 1
     b5c:	fc 93       	st	X, r31
     b5e:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     b60:	c2 81       	ldd	r28, Z+2	; 0x02
     b62:	d3 81       	ldd	r29, Z+3	; 0x03
     b64:	13 96       	adiw	r26, 0x03	; 3
     b66:	dc 93       	st	X, r29
     b68:	ce 93       	st	-X, r28
     b6a:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     b6c:	b9 83       	std	Y+1, r27	; 0x01
     b6e:	a8 83       	st	Y, r26
  pqp->prev     = p;
     b70:	b3 83       	std	Z+3, r27	; 0x03
     b72:	a2 83       	std	Z+2, r26	; 0x02
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
     b74:	cd 01       	movw	r24, r26
     b76:	df 91       	pop	r29
     b78:	cf 91       	pop	r28
     b7a:	08 95       	ret

00000b7c <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     b80:	e3 e8       	ldi	r30, 0x83	; 131
     b82:	f4 e0       	ldi	r31, 0x04	; 4
     b84:	65 81       	ldd	r22, Z+5	; 0x05
     b86:	76 81       	ldd	r23, Z+6	; 0x06

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
     b88:	db 01       	movw	r26, r22
     b8a:	1f 96       	adiw	r26, 0x0f	; 15
     b8c:	8c 93       	st	X, r24
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     b8e:	80 81       	ld	r24, Z
     b90:	91 81       	ldd	r25, Z+1	; 0x01

  pqp->next       = p->next;
     b92:	ec 01       	movw	r28, r24
     b94:	a8 81       	ld	r26, Y
     b96:	b9 81       	ldd	r27, Y+1	; 0x01
     b98:	b1 83       	std	Z+1, r27	; 0x01
     b9a:	a0 83       	st	Z, r26
  pqp->next->prev = pqp;
     b9c:	13 96       	adiw	r26, 0x03	; 3
     b9e:	fc 93       	st	X, r31
     ba0:	ee 93       	st	-X, r30
     ba2:	12 97       	sbiw	r26, 0x02	; 2
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     ba4:	21 e0       	ldi	r18, 0x01	; 1
     ba6:	2f 87       	std	Y+15, r18	; 0x0f
  __instance_set_currthread(oip, ntp);
     ba8:	96 83       	std	Z+6, r25	; 0x06
     baa:	85 83       	std	Z+5, r24	; 0x05
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     bac:	68 d4       	rcall	.+2256   	; 0x147e <_port_switch>
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     bb4:	ff 92       	push	r15
     bb6:	0f 93       	push	r16
     bb8:	1f 93       	push	r17
     bba:	cf 93       	push	r28
     bbc:	df 93       	push	r29
     bbe:	cd b7       	in	r28, 0x3d	; 61
     bc0:	de b7       	in	r29, 0x3e	; 62
     bc2:	2c 97       	sbiw	r28, 0x0c	; 12
     bc4:	0f b6       	in	r0, 0x3f	; 63
     bc6:	f8 94       	cli
     bc8:	de bf       	out	0x3e, r29	; 62
     bca:	0f be       	out	0x3f, r0	; 63
     bcc:	cd bf       	out	0x3d, r28	; 61
     bce:	f8 2e       	mov	r15, r24
  thread_t *tp = __instance_get_currthread(currcore);
     bd0:	00 91 88 04 	lds	r16, 0x0488	; 0x800488 <ch0+0x5>
     bd4:	10 91 89 04 	lds	r17, 0x0489	; 0x800489 <ch0+0x6>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     bd8:	6f 3f       	cpi	r22, 0xFF	; 255
     bda:	8f ef       	ldi	r24, 0xFF	; 255
     bdc:	78 07       	cpc	r23, r24
     bde:	f1 f0       	breq	.+60     	; 0xc1c <chSchGoSleepTimeoutS+0x68>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
     be0:	98 01       	movw	r18, r16
     be2:	45 e4       	ldi	r20, 0x45	; 69
     be4:	55 e0       	ldi	r21, 0x05	; 5
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	7a de       	rcall	.-780    	; 0x8e0 <chVTDoSetI>
    chSchGoSleepS(newstate);
     bec:	8f 2d       	mov	r24, r15
     bee:	c6 df       	rcall	.-116    	; 0xb7c <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     bf0:	89 81       	ldd	r24, Y+1	; 0x01
     bf2:	9a 81       	ldd	r25, Y+2	; 0x02
     bf4:	89 2b       	or	r24, r25
     bf6:	19 f0       	breq	.+6      	; 0xbfe <chSchGoSleepTimeoutS+0x4a>
      chVTDoResetI(&vt);
     bf8:	ce 01       	movw	r24, r28
     bfa:	01 96       	adiw	r24, 0x01	; 1
     bfc:	b3 de       	rcall	.-666    	; 0x964 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
     bfe:	f8 01       	movw	r30, r16
     c00:	82 89       	ldd	r24, Z+18	; 0x12
     c02:	93 89       	ldd	r25, Z+19	; 0x13
     c04:	2c 96       	adiw	r28, 0x0c	; 12
     c06:	0f b6       	in	r0, 0x3f	; 63
     c08:	f8 94       	cli
     c0a:	de bf       	out	0x3e, r29	; 62
     c0c:	0f be       	out	0x3f, r0	; 63
     c0e:	cd bf       	out	0x3d, r28	; 61
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	1f 91       	pop	r17
     c16:	0f 91       	pop	r16
     c18:	ff 90       	pop	r15
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
     c1a:	08 95       	ret
     c1c:	8f 2d       	mov	r24, r15
     c1e:	ae df       	rcall	.-164    	; 0xb7c <chSchGoSleepS>
     c20:	ee cf       	rjmp	.-36     	; 0xbfe <chSchGoSleepTimeoutS+0x4a>

00000c22 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	dc 01       	movw	r26, r24
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     c28:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
     c2c:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     c30:	53 96       	adiw	r26, 0x13	; 19
     c32:	7c 93       	st	X, r23
     c34:	6e 93       	st	-X, r22
     c36:	52 97       	sbiw	r26, 0x12	; 18
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
     c38:	14 96       	adiw	r26, 0x04	; 4
     c3a:	2c 91       	ld	r18, X
     c3c:	14 97       	sbiw	r26, 0x04	; 4
     c3e:	8c 81       	ldd	r24, Y+4	; 0x04
     c40:	82 17       	cp	r24, r18
     c42:	e8 f0       	brcs	.+58     	; 0xc7e <chSchWakeupS+0x5c>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c44:	1f 96       	adiw	r26, 0x0f	; 15
     c46:	1c 92       	st	X, r1
     c48:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
     c4a:	1b 96       	adiw	r26, 0x0b	; 11
     c4c:	ed 91       	ld	r30, X+
     c4e:	fc 91       	ld	r31, X
     c50:	1c 97       	sbiw	r26, 0x0c	; 12
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c52:	01 90       	ld	r0, Z+
     c54:	f0 81       	ld	r31, Z
     c56:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio >= p->prio));
     c58:	94 81       	ldd	r25, Z+4	; 0x04
     c5a:	92 17       	cp	r25, r18
     c5c:	d0 f7       	brcc	.-12     	; 0xc52 <chSchWakeupS+0x30>

  /* Insertion on prev.*/
  p->next       = pqp;
     c5e:	11 96       	adiw	r26, 0x01	; 1
     c60:	fc 93       	st	X, r31
     c62:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     c64:	c2 81       	ldd	r28, Z+2	; 0x02
     c66:	d3 81       	ldd	r29, Z+3	; 0x03
     c68:	13 96       	adiw	r26, 0x03	; 3
     c6a:	dc 93       	st	X, r29
     c6c:	ce 93       	st	-X, r28
     c6e:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     c70:	b9 83       	std	Y+1, r27	; 0x01
     c72:	a8 83       	st	Y, r26
  pqp->prev     = p;
     c74:	b3 83       	std	Z+3, r27	; 0x03
     c76:	a2 83       	std	Z+2, r26	; 0x02
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     c7e:	1f 86       	std	Y+15, r1	; 0x0f

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     c80:	eb 85       	ldd	r30, Y+11	; 0x0b
     c82:	fc 85       	ldd	r31, Y+12	; 0x0c
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     c84:	01 90       	ld	r0, Z+
     c86:	f0 81       	ld	r31, Z
     c88:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     c8a:	94 81       	ldd	r25, Z+4	; 0x04
     c8c:	89 17       	cp	r24, r25
     c8e:	d0 f3       	brcs	.-12     	; 0xc84 <chSchWakeupS+0x62>
     c90:	cd 01       	movw	r24, r26

  /* Insertion on prev.*/
  p->next       = pqp;
     c92:	f9 83       	std	Y+1, r31	; 0x01
     c94:	e8 83       	st	Y, r30
  p->prev       = pqp->prev;
     c96:	a2 81       	ldd	r26, Z+2	; 0x02
     c98:	b3 81       	ldd	r27, Z+3	; 0x03
     c9a:	bb 83       	std	Y+3, r27	; 0x03
     c9c:	aa 83       	std	Y+2, r26	; 0x02
  p->prev->next = p;
     c9e:	cd 93       	st	X+, r28
     ca0:	dc 93       	st	X, r29
  pqp->prev     = p;
     ca2:	d3 83       	std	Z+3, r29	; 0x03
     ca4:	c2 83       	std	Z+2, r28	; 0x02
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
     ca6:	21 e0       	ldi	r18, 0x01	; 1
     ca8:	fc 01       	movw	r30, r24
     caa:	27 87       	std	Z+15, r18	; 0x0f
    __instance_set_currthread(oip, ntp);
     cac:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <ch0+0x6>
     cb0:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <ch0+0x5>

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
     cb4:	be 01       	movw	r22, r28
     cb6:	e3 d3       	rcall	.+1990   	; 0x147e <_port_switch>
  }
}
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	08 95       	ret

00000cbe <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     cbe:	a0 91 83 04 	lds	r26, 0x0483	; 0x800483 <ch0>
     cc2:	b0 91 84 04 	lds	r27, 0x0484	; 0x800484 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     cc6:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
     cca:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	14 96       	adiw	r26, 0x04	; 4
     cd2:	2c 91       	ld	r18, X
     cd4:	94 81       	ldd	r25, Z+4	; 0x04
     cd6:	92 17       	cp	r25, r18
     cd8:	08 f0       	brcs	.+2      	; 0xcdc <chSchIsPreemptionRequired+0x1e>
     cda:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     cdc:	08 95       	ret

00000cde <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
     ce2:	a0 91 88 04 	lds	r26, 0x0488	; 0x800488 <ch0+0x5>
     ce6:	b0 91 89 04 	lds	r27, 0x0489	; 0x800489 <ch0+0x6>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
     cea:	40 91 83 04 	lds	r20, 0x0483	; 0x800483 <ch0>
     cee:	50 91 84 04 	lds	r21, 0x0484	; 0x800484 <ch0+0x1>

  pqp->next       = p->next;
     cf2:	ea 01       	movw	r28, r20
     cf4:	e8 81       	ld	r30, Y
     cf6:	f9 81       	ldd	r31, Y+1	; 0x01
     cf8:	f0 93 84 04 	sts	0x0484, r31	; 0x800484 <ch0+0x1>
     cfc:	e0 93 83 04 	sts	0x0483, r30	; 0x800483 <ch0>
  pqp->next->prev = pqp;
     d00:	83 e8       	ldi	r24, 0x83	; 131
     d02:	94 e0       	ldi	r25, 0x04	; 4
     d04:	93 83       	std	Z+3, r25	; 0x03
     d06:	82 83       	std	Z+2, r24	; 0x02
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	8f 87       	std	Y+15, r24	; 0x0f
  __instance_set_currthread(oip, ntp);
     d0c:	50 93 89 04 	sts	0x0489, r21	; 0x800489 <ch0+0x6>
     d10:	40 93 88 04 	sts	0x0488, r20	; 0x800488 <ch0+0x5>

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
     d14:	1f 96       	adiw	r26, 0x0f	; 15
     d16:	1c 92       	st	X, r1
     d18:	1f 97       	sbiw	r26, 0x0f	; 15

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
     d1a:	1b 96       	adiw	r26, 0x0b	; 11
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X
     d20:	1c 97       	sbiw	r26, 0x0c	; 12
     d22:	14 96       	adiw	r26, 0x04	; 4
     d24:	2c 91       	ld	r18, X
     d26:	14 97       	sbiw	r26, 0x04	; 4
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
     d28:	01 90       	ld	r0, Z+
     d2a:	f0 81       	ld	r31, Z
     d2c:	e0 2d       	mov	r30, r0
  } while (unlikely(pqp->prio > p->prio));
     d2e:	94 81       	ldd	r25, Z+4	; 0x04
     d30:	29 17       	cp	r18, r25
     d32:	d0 f3       	brcs	.-12     	; 0xd28 <chSchDoPreemption+0x4a>

  /* Insertion on prev.*/
  p->next       = pqp;
     d34:	11 96       	adiw	r26, 0x01	; 1
     d36:	fc 93       	st	X, r31
     d38:	ee 93       	st	-X, r30
  p->prev       = pqp->prev;
     d3a:	82 81       	ldd	r24, Z+2	; 0x02
     d3c:	93 81       	ldd	r25, Z+3	; 0x03
     d3e:	13 96       	adiw	r26, 0x03	; 3
     d40:	9c 93       	st	X, r25
     d42:	8e 93       	st	-X, r24
     d44:	12 97       	sbiw	r26, 0x02	; 2
  p->prev->next = p;
     d46:	ec 01       	movw	r28, r24
     d48:	b9 83       	std	Y+1, r27	; 0x01
     d4a:	a8 83       	st	Y, r26
  pqp->prev     = p;
     d4c:	b3 83       	std	Z+3, r27	; 0x03
     d4e:	a2 83       	std	Z+2, r26	; 0x02
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
     d50:	bd 01       	movw	r22, r26
     d52:	ca 01       	movw	r24, r20
     d54:	94 d3       	rcall	.+1832   	; 0x147e <_port_switch>
}
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	08 95       	ret

00000d5c <chSchPreemption>:
 * @special
 */
void chSchPreemption(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
  tprio_t p1 = firstprio(&oip->rlist.pqueue);
     d5c:	a0 91 83 04 	lds	r26, 0x0483	; 0x800483 <ch0>
     d60:	b0 91 84 04 	lds	r27, 0x0484	; 0x800484 <ch0+0x1>
  tprio_t p2 = tp->hdr.pqueue.prio;
     d64:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
     d68:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
    if (likely(p1 >= p2)) {
      __sch_reschedule_behind();
    }
  }
#else /* CH_CFG_TIME_QUANTUM == 0 */
  if (likely(p1 > p2)) {
     d6c:	14 96       	adiw	r26, 0x04	; 4
     d6e:	9c 91       	ld	r25, X
     d70:	84 81       	ldd	r24, Z+4	; 0x04
     d72:	89 17       	cp	r24, r25
     d74:	08 f0       	brcs	.+2      	; 0xd78 <chSchPreemption+0x1c>
     d76:	08 95       	ret
    __sch_reschedule_ahead();
     d78:	b2 cf       	rjmp	.-156    	; 0xcde <chSchDoPreemption>

00000d7a <chSchRescheduleS>:
     d7a:	f0 cf       	rjmp	.-32     	; 0xd5c <chSchPreemption>

00000d7c <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
     d7c:	ff cf       	rjmp	.-2      	; 0xd7c <__idle_thread>

00000d7e <chInstanceObjectInit>:
 * @param[in] oicp      pointer to an @p os_instance_config_t object
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
     d7e:	df 92       	push	r13
     d80:	ef 92       	push	r14
     d82:	ff 92       	push	r15
     d84:	0f 93       	push	r16
     d86:	1f 93       	push	r17
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
     d90:	2b 97       	sbiw	r28, 0x0b	; 11
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	de bf       	out	0x3e, r29	; 62
     d98:	0f be       	out	0x3f, r0	; 63
     d9a:	cd bf       	out	0x3d, r28	; 61
     d9c:	8c 01       	movw	r16, r24
     d9e:	7b 01       	movw	r14, r22
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
     da0:	90 93 82 04 	sts	0x0482, r25	; 0x800482 <ch_system+0x2>
     da4:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <ch_system+0x1>

  /* Core associated to this instance.*/
  oip->core_id = core_id;
     da8:	fc 01       	movw	r30, r24
     daa:	14 8e       	std	Z+28, r1	; 0x1c
     dac:	13 8e       	std	Z+27, r1	; 0x1b

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
     dae:	72 a3       	std	Z+34, r23	; 0x22
     db0:	61 a3       	std	Z+33, r22	; 0x21

  /* Port initialization for the current instance.*/
  port_init(oip);
     db2:	dd 24       	eor	r13, r13
     db4:	d3 94       	inc	r13
     db6:	d0 92 ca 04 	sts	0x04CA, r13	; 0x8004ca <__avr_in_isr>
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
     dba:	91 83       	std	Z+1, r25	; 0x01
     dbc:	80 83       	st	Z, r24
  pqp->prev = pqp;
     dbe:	93 83       	std	Z+3, r25	; 0x03
     dc0:	82 83       	std	Z+2, r24	; 0x02
  pqp->prio = (tprio_t)0;
     dc2:	14 82       	std	Z+4, r1	; 0x04
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
     dc4:	47 96       	adiw	r24, 0x17	; 23
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
     dc6:	90 8f       	std	Z+24, r25	; 0x18
     dc8:	87 8b       	std	Z+23, r24	; 0x17
  qp->prev = qp;
     dca:	92 8f       	std	Z+26, r25	; 0x1a
     dcc:	81 8f       	std	Z+25, r24	; 0x19
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
     dce:	15 8e       	std	Z+29, r1	; 0x1d
     dd0:	16 8e       	std	Z+30, r1	; 0x1e
     dd2:	17 8e       	std	Z+31, r1	; 0x1f
     dd4:	10 a2       	std	Z+32, r1	; 0x20
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
     dd6:	40 97       	sbiw	r24, 0x10	; 16
 *
 * @notapi
 */
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {

  dlhp->next  = dlhp;
     dd8:	90 87       	std	Z+8, r25	; 0x08
     dda:	87 83       	std	Z+7, r24	; 0x07
  dlhp->prev  = dlhp;
     ddc:	92 87       	std	Z+10, r25	; 0x0a
     dde:	81 87       	std	Z+9, r24	; 0x09
  dlhp->delta = (sysinterval_t)-1;
     de0:	8f ef       	ldi	r24, 0xFF	; 255
     de2:	9f ef       	ldi	r25, 0xFF	; 255
     de4:	94 87       	std	Z+12, r25	; 0x0c
     de6:	83 87       	std	Z+11, r24	; 0x0b
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
     de8:	16 86       	std	Z+14, r1	; 0x0e
     dea:	15 86       	std	Z+13, r1	; 0x0d
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
     dec:	20 91 90 04 	lds	r18, 0x0490	; 0x800490 <ch0+0xd>
     df0:	30 91 91 04 	lds	r19, 0x0491	; 0x800491 <ch0+0xe>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
  vtlp->lastdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
     df4:	27 87       	std	Z+15, r18	; 0x0f
     df6:	30 8b       	std	Z+16, r19	; 0x10
     df8:	11 8a       	std	Z+17, r1	; 0x11
     dfa:	12 8a       	std	Z+18, r1	; 0x12
     dfc:	13 8a       	std	Z+19, r1	; 0x13
     dfe:	14 8a       	std	Z+20, r1	; 0x14
     e00:	15 8a       	std	Z+21, r1	; 0x15
     e02:	16 8a       	std	Z+22, r1	; 0x16
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
     e04:	ef 5b       	subi	r30, 0xBF	; 191
     e06:	ff 4f       	sbci	r31, 0xFF	; 255
     e08:	11 82       	std	Z+1, r1	; 0x01
     e0a:	10 82       	st	Z, r1
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
     e0c:	b8 01       	movw	r22, r16
     e0e:	6d 5d       	subi	r22, 0xDD	; 221
     e10:	7f 4f       	sbci	r23, 0xFF	; 255
     e12:	20 e8       	ldi	r18, 0x80	; 128
     e14:	4f e2       	ldi	r20, 0x2F	; 47
     e16:	51 e0       	ldi	r21, 0x01	; 1
     e18:	c8 01       	movw	r24, r16
     e1a:	2a d0       	rcall	.+84     	; 0xe70 <__thd_object_init>
     e1c:	f8 01       	movw	r30, r16
     e1e:	96 83       	std	Z+6, r25	; 0x06
     e20:	85 83       	std	Z+5, r24	; 0x05
  oip->rlist.current->wabase = oicp->mainthread_base;
  oip->rlist.current->waend  = oicp->mainthread_end;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
     e22:	fc 01       	movw	r30, r24
     e24:	d7 86       	std	Z+15, r13	; 0x0f
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
     e26:	83 e2       	ldi	r24, 0x23	; 35
     e28:	91 e0       	ldi	r25, 0x01	; 1
     e2a:	9a 83       	std	Y+2, r25	; 0x02
     e2c:	89 83       	std	Y+1, r24	; 0x01
     e2e:	f7 01       	movw	r30, r14
     e30:	82 81       	ldd	r24, Z+2	; 0x02
     e32:	93 81       	ldd	r25, Z+3	; 0x03
     e34:	9c 83       	std	Y+4, r25	; 0x04
     e36:	8b 83       	std	Y+3, r24	; 0x03
     e38:	84 81       	ldd	r24, Z+4	; 0x04
     e3a:	95 81       	ldd	r25, Z+5	; 0x05
     e3c:	9e 83       	std	Y+6, r25	; 0x06
     e3e:	8d 83       	std	Y+5, r24	; 0x05
     e40:	df 82       	std	Y+7, r13	; 0x07
     e42:	8e eb       	ldi	r24, 0xBE	; 190
     e44:	96 e0       	ldi	r25, 0x06	; 6
     e46:	99 87       	std	Y+9, r25	; 0x09
     e48:	88 87       	std	Y+8, r24	; 0x08
     e4a:	1b 86       	std	Y+11, r1	; 0x0b
     e4c:	1a 86       	std	Y+10, r1	; 0x0a
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
     e4e:	ce 01       	movw	r24, r28
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	9e d0       	rcall	.+316    	; 0xf90 <chThdCreateI>
  }
#endif
}
     e54:	2b 96       	adiw	r28, 0x0b	; 11
     e56:	0f b6       	in	r0, 0x3f	; 63
     e58:	f8 94       	cli
     e5a:	de bf       	out	0x3e, r29	; 62
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	cd bf       	out	0x3d, r28	; 61
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	ff 90       	pop	r15
     e6a:	ef 90       	pop	r14
     e6c:	df 90       	pop	r13
     e6e:	08 95       	ret

00000e70 <__thd_object_init>:
 *
 * @param[in] tqp       pointer to a @p threads_queue_t object
 *
 * @dispose
 */
void chThdQueueObjectDispose(threads_queue_t *tqp) {
     e70:	cf 93       	push	r28
     e72:	df 93       	push	r29
     e74:	fb 01       	movw	r30, r22
     e76:	24 83       	std	Z+4, r18	; 0x04
     e78:	32 e0       	ldi	r19, 0x02	; 2
     e7a:	37 87       	std	Z+15, r19	; 0x0f
     e7c:	10 8a       	std	Z+16, r1	; 0x10
     e7e:	94 87       	std	Z+12, r25	; 0x0c
     e80:	83 87       	std	Z+11, r24	; 0x0b
     e82:	25 8f       	std	Z+29, r18	; 0x1d
     e84:	14 8e       	std	Z+28, r1	; 0x1c
     e86:	13 8e       	std	Z+27, r1	; 0x1b
     e88:	12 8e       	std	Z+26, r1	; 0x1a
     e8a:	21 e0       	ldi	r18, 0x01	; 1
     e8c:	21 8b       	std	Z+17, r18	; 0x11
     e8e:	56 87       	std	Z+14, r21	; 0x0e
     e90:	45 87       	std	Z+13, r20	; 0x0d
     e92:	9b 01       	movw	r18, r22
     e94:	29 5f       	subi	r18, 0xF9	; 249
     e96:	3f 4f       	sbci	r19, 0xFF	; 255
     e98:	ac 01       	movw	r20, r24
     e9a:	49 5e       	subi	r20, 0xE9	; 233
     e9c:	5f 4f       	sbci	r21, 0xFF	; 255
     e9e:	50 87       	std	Z+8, r21	; 0x08
     ea0:	47 83       	std	Z+7, r20	; 0x07
     ea2:	ec 01       	movw	r28, r24
     ea4:	a9 8d       	ldd	r26, Y+25	; 0x19
     ea6:	ba 8d       	ldd	r27, Y+26	; 0x1a
     ea8:	b2 87       	std	Z+10, r27	; 0x0a
     eaa:	a1 87       	std	Z+9, r26	; 0x09
     eac:	2d 93       	st	X+, r18
     eae:	3c 93       	st	X, r19
     eb0:	3a 8f       	std	Y+26, r19	; 0x1a
     eb2:	29 8f       	std	Y+25, r18	; 0x19
     eb4:	cb 01       	movw	r24, r22
     eb6:	44 96       	adiw	r24, 0x14	; 20
     eb8:	95 8b       	std	Z+21, r25	; 0x15
     eba:	84 8b       	std	Z+20, r24	; 0x14
     ebc:	02 96       	adiw	r24, 0x02	; 2
     ebe:	97 8b       	std	Z+23, r25	; 0x17
     ec0:	86 8b       	std	Z+22, r24	; 0x16
     ec2:	91 8f       	std	Z+25, r25	; 0x19
     ec4:	80 8f       	std	Z+24, r24	; 0x18
     ec6:	cb 01       	movw	r24, r22
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	08 95       	ret

00000ece <chThdCreateSuspendedI>:
     ece:	cf 93       	push	r28
     ed0:	df 93       	push	r29
     ed2:	dc 01       	movw	r26, r24
     ed4:	14 96       	adiw	r26, 0x04	; 4
     ed6:	2d 91       	ld	r18, X+
     ed8:	3c 91       	ld	r19, X
     eda:	15 97       	sbiw	r26, 0x05	; 5
     edc:	f9 01       	movw	r30, r18
     ede:	7e 97       	sbiw	r30, 0x1e	; 30
     ee0:	e9 01       	movw	r28, r18
     ee2:	e3 97       	sbiw	r28, 0x33	; 51
     ee4:	d6 83       	std	Z+6, r29	; 0x06
     ee6:	c5 83       	std	Z+5, r28	; 0x05
     ee8:	17 96       	adiw	r26, 0x07	; 7
     eea:	8c 91       	ld	r24, X
     eec:	17 97       	sbiw	r26, 0x07	; 7
     eee:	8a 8b       	std	Y+18, r24	; 0x12
     ef0:	18 96       	adiw	r26, 0x08	; 8
     ef2:	8c 91       	ld	r24, X
     ef4:	18 97       	sbiw	r26, 0x08	; 8
     ef6:	89 8b       	std	Y+17, r24	; 0x11
     ef8:	19 96       	adiw	r26, 0x09	; 9
     efa:	8c 91       	ld	r24, X
     efc:	19 97       	sbiw	r26, 0x09	; 9
     efe:	88 8b       	std	Y+16, r24	; 0x10
     f00:	1a 96       	adiw	r26, 0x0a	; 10
     f02:	8c 91       	ld	r24, X
     f04:	1a 97       	sbiw	r26, 0x0a	; 10
     f06:	8f 87       	std	Y+15, r24	; 0x0f
     f08:	8e e6       	ldi	r24, 0x6E	; 110
     f0a:	9a e0       	ldi	r25, 0x0A	; 10
     f0c:	9b 8b       	std	Y+19, r25	; 0x13
     f0e:	8c 8b       	std	Y+20, r24	; 0x14
     f10:	16 96       	adiw	r26, 0x06	; 6
     f12:	8c 91       	ld	r24, X
     f14:	16 97       	sbiw	r26, 0x06	; 6
     f16:	4d 91       	ld	r20, X+
     f18:	5c 91       	ld	r21, X
     f1a:	84 83       	std	Z+4, r24	; 0x04
     f1c:	92 e0       	ldi	r25, 0x02	; 2
     f1e:	97 87       	std	Z+15, r25	; 0x0f
     f20:	10 8a       	std	Z+16, r1	; 0x10
     f22:	63 e8       	ldi	r22, 0x83	; 131
     f24:	74 e0       	ldi	r23, 0x04	; 4
     f26:	74 87       	std	Z+12, r23	; 0x0c
     f28:	63 87       	std	Z+11, r22	; 0x0b
     f2a:	85 8f       	std	Z+29, r24	; 0x1d
     f2c:	14 8e       	std	Z+28, r1	; 0x1c
     f2e:	13 8e       	std	Z+27, r1	; 0x1b
     f30:	12 8e       	std	Z+26, r1	; 0x1a
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	81 8b       	std	Z+17, r24	; 0x11
     f36:	56 87       	std	Z+14, r21	; 0x0e
     f38:	45 87       	std	Z+13, r20	; 0x0d
     f3a:	d9 01       	movw	r26, r18
     f3c:	57 97       	sbiw	r26, 0x17	; 23
     f3e:	8a e9       	ldi	r24, 0x9A	; 154
     f40:	94 e0       	ldi	r25, 0x04	; 4
     f42:	11 96       	adiw	r26, 0x01	; 1
     f44:	9c 93       	st	X, r25
     f46:	8e 93       	st	-X, r24
     f48:	eb 01       	movw	r28, r22
     f4a:	89 8d       	ldd	r24, Y+25	; 0x19
     f4c:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f4e:	13 96       	adiw	r26, 0x03	; 3
     f50:	9c 93       	st	X, r25
     f52:	8e 93       	st	-X, r24
     f54:	12 97       	sbiw	r26, 0x02	; 2
     f56:	ec 01       	movw	r28, r24
     f58:	b9 83       	std	Y+1, r27	; 0x01
     f5a:	a8 83       	st	Y, r26
     f5c:	eb 01       	movw	r28, r22
     f5e:	ba 8f       	std	Y+26, r27	; 0x1a
     f60:	a9 8f       	std	Y+25, r26	; 0x19
     f62:	1d 96       	adiw	r26, 0x0d	; 13
     f64:	0b 2e       	mov	r0, r27
     f66:	11 96       	adiw	r26, 0x01	; 1
     f68:	0c 92       	st	X, r0
     f6a:	11 97       	sbiw	r26, 0x01	; 1
     f6c:	ac 93       	st	X, r26
     f6e:	12 96       	adiw	r26, 0x02	; 2
     f70:	0b 2e       	mov	r0, r27
     f72:	11 96       	adiw	r26, 0x01	; 1
     f74:	0c 92       	st	X, r0
     f76:	11 97       	sbiw	r26, 0x01	; 1
     f78:	ac 93       	st	X, r26
     f7a:	0a 2e       	mov	r0, r26
     f7c:	1b 2e       	mov	r1, r27
     f7e:	13 96       	adiw	r26, 0x03	; 3
     f80:	1c 92       	st	X, r1
     f82:	0e 92       	st	-X, r0
     f84:	11 24       	eor	r1, r1
     f86:	12 97       	sbiw	r26, 0x02	; 2
     f88:	cf 01       	movw	r24, r30
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	08 95       	ret

00000f90 <chThdCreateI>:
     f90:	9e df       	rcall	.-196    	; 0xece <chThdCreateSuspendedI>
     f92:	d0 cd       	rjmp	.-1120   	; 0xb34 <chSchReadyI>

00000f94 <chThdCreateStatic>:
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	f8 94       	cli
     f9e:	6e 51       	subi	r22, 0x1E	; 30
     fa0:	71 09       	sbc	r23, r1
     fa2:	ec 01       	movw	r28, r24
     fa4:	c6 0f       	add	r28, r22
     fa6:	d7 1f       	adc	r29, r23
     fa8:	fe 01       	movw	r30, r28
     faa:	75 97       	sbiw	r30, 0x15	; 21
     fac:	fe 83       	std	Y+6, r31	; 0x06
     fae:	ed 83       	std	Y+5, r30	; 0x05
     fb0:	22 8b       	std	Z+18, r18	; 0x12
     fb2:	31 8b       	std	Z+17, r19	; 0x11
     fb4:	00 8b       	std	Z+16, r16	; 0x10
     fb6:	17 87       	std	Z+15, r17	; 0x0f
     fb8:	8e e6       	ldi	r24, 0x6E	; 110
     fba:	9a e0       	ldi	r25, 0x0A	; 10
     fbc:	93 8b       	std	Z+19, r25	; 0x13
     fbe:	84 8b       	std	Z+20, r24	; 0x14
     fc0:	4c 83       	std	Y+4, r20	; 0x04
     fc2:	82 e0       	ldi	r24, 0x02	; 2
     fc4:	8f 87       	std	Y+15, r24	; 0x0f
     fc6:	18 8a       	std	Y+16, r1	; 0x10
     fc8:	e3 e8       	ldi	r30, 0x83	; 131
     fca:	f4 e0       	ldi	r31, 0x04	; 4
     fcc:	fc 87       	std	Y+12, r31	; 0x0c
     fce:	eb 87       	std	Y+11, r30	; 0x0b
     fd0:	4d 8f       	std	Y+29, r20	; 0x1d
     fd2:	1c 8e       	std	Y+28, r1	; 0x1c
     fd4:	1b 8e       	std	Y+27, r1	; 0x1b
     fd6:	1a 8e       	std	Y+26, r1	; 0x1a
     fd8:	81 e0       	ldi	r24, 0x01	; 1
     fda:	89 8b       	std	Y+17, r24	; 0x11
     fdc:	88 e2       	ldi	r24, 0x28	; 40
     fde:	91 e0       	ldi	r25, 0x01	; 1
     fe0:	9e 87       	std	Y+14, r25	; 0x0e
     fe2:	8d 87       	std	Y+13, r24	; 0x0d
     fe4:	ce 01       	movw	r24, r28
     fe6:	07 96       	adiw	r24, 0x07	; 7
     fe8:	2a e9       	ldi	r18, 0x9A	; 154
     fea:	34 e0       	ldi	r19, 0x04	; 4
     fec:	38 87       	std	Y+8, r19	; 0x08
     fee:	2f 83       	std	Y+7, r18	; 0x07
     ff0:	a1 8d       	ldd	r26, Z+25	; 0x19
     ff2:	b2 8d       	ldd	r27, Z+26	; 0x1a
     ff4:	ba 87       	std	Y+10, r27	; 0x0a
     ff6:	a9 87       	std	Y+9, r26	; 0x09
     ff8:	8d 93       	st	X+, r24
     ffa:	9c 93       	st	X, r25
     ffc:	92 8f       	std	Z+26, r25	; 0x1a
     ffe:	81 8f       	std	Z+25, r24	; 0x19
    1000:	0d 96       	adiw	r24, 0x0d	; 13
    1002:	9d 8b       	std	Y+21, r25	; 0x15
    1004:	8c 8b       	std	Y+20, r24	; 0x14
    1006:	02 96       	adiw	r24, 0x02	; 2
    1008:	9f 8b       	std	Y+23, r25	; 0x17
    100a:	8e 8b       	std	Y+22, r24	; 0x16
    100c:	99 8f       	std	Y+25, r25	; 0x19
    100e:	88 8f       	std	Y+24, r24	; 0x18
    1010:	60 e0       	ldi	r22, 0x00	; 0
    1012:	70 e0       	ldi	r23, 0x00	; 0
    1014:	ce 01       	movw	r24, r28
    1016:	05 de       	rcall	.-1014   	; 0xc22 <chSchWakeupS>
    1018:	78 94       	sei
    101a:	ce 01       	movw	r24, r28
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	08 95       	ret

00001026 <chThdExitS>:
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
    1032:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
    1036:	9b 8b       	std	Y+19, r25	; 0x13
    1038:	8a 8b       	std	Y+18, r24	; 0x12
    103a:	8e 01       	movw	r16, r28
    103c:	0c 5e       	subi	r16, 0xEC	; 236
    103e:	1f 4f       	sbci	r17, 0xFF	; 255
    1040:	8c 89       	ldd	r24, Y+20	; 0x14
    1042:	9d 89       	ldd	r25, Y+21	; 0x15
    1044:	08 17       	cp	r16, r24
    1046:	19 07       	cpc	r17, r25
    1048:	59 f0       	breq	.+22     	; 0x1060 <chThdExitS+0x3a>
    104a:	fc 01       	movw	r30, r24
    104c:	20 81       	ld	r18, Z
    104e:	31 81       	ldd	r19, Z+1	; 0x01
    1050:	3d 8b       	std	Y+21, r19	; 0x15
    1052:	2c 8b       	std	Y+20, r18	; 0x14
    1054:	6f dd       	rcall	.-1314   	; 0xb34 <chSchReadyI>
    1056:	8c 89       	ldd	r24, Y+20	; 0x14
    1058:	9d 89       	ldd	r25, Y+21	; 0x15
    105a:	80 17       	cp	r24, r16
    105c:	91 07       	cpc	r25, r17
    105e:	a9 f7       	brne	.-22     	; 0x104a <chThdExitS+0x24>
    1060:	89 89       	ldd	r24, Y+17	; 0x11
    1062:	81 11       	cpse	r24, r1
    1064:	0c c0       	rjmp	.+24     	; 0x107e <chThdExitS+0x58>
    1066:	e9 85       	ldd	r30, Y+9	; 0x09
    1068:	fa 85       	ldd	r31, Y+10	; 0x0a
    106a:	8f 81       	ldd	r24, Y+7	; 0x07
    106c:	98 85       	ldd	r25, Y+8	; 0x08
    106e:	91 83       	std	Z+1, r25	; 0x01
    1070:	80 83       	st	Z, r24
    1072:	af 81       	ldd	r26, Y+7	; 0x07
    1074:	b8 85       	ldd	r27, Y+8	; 0x08
    1076:	13 96       	adiw	r26, 0x03	; 3
    1078:	fc 93       	st	X, r31
    107a:	ee 93       	st	-X, r30
    107c:	12 97       	sbiw	r26, 0x02	; 2
    107e:	8f e0       	ldi	r24, 0x0F	; 15
    1080:	df 91       	pop	r29
    1082:	cf 91       	pop	r28
    1084:	1f 91       	pop	r17
    1086:	0f 91       	pop	r16
    1088:	79 cd       	rjmp	.-1294   	; 0xb7c <chSchGoSleepS>

0000108a <chThdExit>:
    108a:	f8 94       	cli
    108c:	cc cf       	rjmp	.-104    	; 0x1026 <chThdExitS>

0000108e <chThdSleep>:
    108e:	f8 94       	cli
    1090:	bc 01       	movw	r22, r24
    1092:	88 e0       	ldi	r24, 0x08	; 8
    1094:	8f dd       	rcall	.-1250   	; 0xbb4 <chSchGoSleepTimeoutS>
    1096:	78 94       	sei
    1098:	08 95       	ret

0000109a <chThdQueueObjectInit>:
    109a:	fc 01       	movw	r30, r24
    109c:	91 83       	std	Z+1, r25	; 0x01
    109e:	80 83       	st	Z, r24
    10a0:	93 83       	std	Z+3, r25	; 0x03
    10a2:	82 83       	std	Z+2, r24	; 0x02
    10a4:	08 95       	ret

000010a6 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
    10a6:	cf 93       	push	r28
    10a8:	df 93       	push	r29
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    10aa:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
    10ae:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
    10b2:	61 15       	cp	r22, r1
    10b4:	71 05       	cpc	r23, r1
    10b6:	79 f0       	breq	.+30     	; 0x10d6 <chThdEnqueueTimeoutS+0x30>
 *
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {

  p->next       = qp;
    10b8:	91 83       	std	Z+1, r25	; 0x01
    10ba:	80 83       	st	Z, r24
  p->prev       = qp->prev;
    10bc:	ec 01       	movw	r28, r24
    10be:	aa 81       	ldd	r26, Y+2	; 0x02
    10c0:	bb 81       	ldd	r27, Y+3	; 0x03
    10c2:	b3 83       	std	Z+3, r27	; 0x03
    10c4:	a2 83       	std	Z+2, r26	; 0x02
  p->prev->next = p;
    10c6:	ed 93       	st	X+, r30
    10c8:	fc 93       	st	X, r31
  qp->prev      = p;
    10ca:	fb 83       	std	Y+3, r31	; 0x03
    10cc:	ea 83       	std	Y+2, r30	; 0x02
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    10ce:	84 e0       	ldi	r24, 0x04	; 4
}
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    10d4:	6f cd       	rjmp	.-1314   	; 0xbb4 <chSchGoSleepTimeoutS>
}
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	08 95       	ret

000010e0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to a @p threads_queue_t object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	fc 01       	movw	r30, r24
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    10e6:	80 81       	ld	r24, Z
    10e8:	91 81       	ldd	r25, Z+1	; 0x01

  if (ch_queue_notempty(&tqp->queue)) {
    10ea:	e8 17       	cp	r30, r24
    10ec:	f9 07       	cpc	r31, r25
    10ee:	71 f0       	breq	.+28     	; 0x110c <chThdDequeueNextI+0x2c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
    10f0:	ec 01       	movw	r28, r24
    10f2:	a8 81       	ld	r26, Y
    10f4:	b9 81       	ldd	r27, Y+1	; 0x01
    10f6:	b1 83       	std	Z+1, r27	; 0x01
    10f8:	a0 83       	st	Z, r26
  qp->next->prev = qp;
    10fa:	13 96       	adiw	r26, 0x03	; 3
    10fc:	fc 93       	st	X, r31
    10fe:	ee 93       	st	-X, r30
    1100:	12 97       	sbiw	r26, 0x02	; 2

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
    1102:	7b 8b       	std	Y+19, r23	; 0x13
    1104:	6a 8b       	std	Y+18, r22	; 0x12
    chThdDoDequeueNextI(tqp, msg);
  }
}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
    110a:	14 cd       	rjmp	.-1496   	; 0xb34 <chSchReadyI>
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	08 95       	ret

00001112 <chMtxObjectInit>:
  mp->cnt++;
#endif
  mp->owner = currtp;
  mp->next = currtp->mtxlist;
  currtp->mtxlist = mp;
  return true;
    1112:	fc 01       	movw	r30, r24
    1114:	91 83       	std	Z+1, r25	; 0x01
    1116:	80 83       	st	Z, r24
    1118:	93 83       	std	Z+3, r25	; 0x03
    111a:	82 83       	std	Z+2, r24	; 0x02
    111c:	15 82       	std	Z+5, r1	; 0x05
    111e:	14 82       	std	Z+4, r1	; 0x04
    1120:	08 95       	ret

00001122 <chMtxLockS>:
    1122:	0f 93       	push	r16
    1124:	1f 93       	push	r17
    1126:	cf 93       	push	r28
    1128:	df 93       	push	r29
    112a:	c0 91 88 04 	lds	r28, 0x0488	; 0x800488 <ch0+0x5>
    112e:	d0 91 89 04 	lds	r29, 0x0489	; 0x800489 <ch0+0x6>
    1132:	dc 01       	movw	r26, r24
    1134:	14 96       	adiw	r26, 0x04	; 4
    1136:	ed 91       	ld	r30, X+
    1138:	fc 91       	ld	r31, X
    113a:	15 97       	sbiw	r26, 0x05	; 5
    113c:	30 97       	sbiw	r30, 0x00	; 0
    113e:	09 f4       	brne	.+2      	; 0x1142 <chMtxLockS+0x20>
    1140:	a8 c0       	rjmp	.+336    	; 0x1292 <chMtxLockS+0x170>
    1142:	8c 01       	movw	r16, r24
    1144:	8c 81       	ldd	r24, Y+4	; 0x04
    1146:	94 81       	ldd	r25, Z+4	; 0x04
    1148:	98 17       	cp	r25, r24
    114a:	48 f4       	brcc	.+18     	; 0x115e <chMtxLockS+0x3c>
    114c:	84 83       	std	Z+4, r24	; 0x04
    114e:	87 85       	ldd	r24, Z+15	; 0x0f
    1150:	86 30       	cpi	r24, 0x06	; 6
    1152:	09 f4       	brne	.+2      	; 0x1156 <chMtxLockS+0x34>
    1154:	63 c0       	rjmp	.+198    	; 0x121c <chMtxLockS+0xfa>
    1156:	87 30       	cpi	r24, 0x07	; 7
    1158:	89 f1       	breq	.+98     	; 0x11bc <chMtxLockS+0x9a>
    115a:	88 23       	and	r24, r24
    115c:	f1 f0       	breq	.+60     	; 0x119a <chMtxLockS+0x78>
    115e:	f8 01       	movw	r30, r16
    1160:	04 c0       	rjmp	.+8      	; 0x116a <chMtxLockS+0x48>
    1162:	24 81       	ldd	r18, Z+4	; 0x04
    1164:	9c 81       	ldd	r25, Y+4	; 0x04
    1166:	29 17       	cp	r18, r25
    1168:	30 f0       	brcs	.+12     	; 0x1176 <chMtxLockS+0x54>
    116a:	01 90       	ld	r0, Z+
    116c:	f0 81       	ld	r31, Z
    116e:	e0 2d       	mov	r30, r0
    1170:	0e 17       	cp	r16, r30
    1172:	1f 07       	cpc	r17, r31
    1174:	b1 f7       	brne	.-20     	; 0x1162 <chMtxLockS+0x40>
    1176:	f9 83       	std	Y+1, r31	; 0x01
    1178:	e8 83       	st	Y, r30
    117a:	a2 81       	ldd	r26, Z+2	; 0x02
    117c:	b3 81       	ldd	r27, Z+3	; 0x03
    117e:	bb 83       	std	Y+3, r27	; 0x03
    1180:	aa 83       	std	Y+2, r26	; 0x02
    1182:	cd 93       	st	X+, r28
    1184:	dc 93       	st	X, r29
    1186:	d3 83       	std	Z+3, r29	; 0x03
    1188:	c2 83       	std	Z+2, r28	; 0x02
    118a:	1b 8b       	std	Y+19, r17	; 0x13
    118c:	0a 8b       	std	Y+18, r16	; 0x12
    118e:	86 e0       	ldi	r24, 0x06	; 6
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	1f 91       	pop	r17
    1196:	0f 91       	pop	r16
    1198:	f1 cc       	rjmp	.-1566   	; 0xb7c <chSchGoSleepS>
    119a:	22 81       	ldd	r18, Z+2	; 0x02
    119c:	33 81       	ldd	r19, Z+3	; 0x03
    119e:	80 81       	ld	r24, Z
    11a0:	91 81       	ldd	r25, Z+1	; 0x01
    11a2:	d9 01       	movw	r26, r18
    11a4:	8d 93       	st	X+, r24
    11a6:	9c 93       	st	X, r25
    11a8:	80 81       	ld	r24, Z
    11aa:	91 81       	ldd	r25, Z+1	; 0x01
    11ac:	dc 01       	movw	r26, r24
    11ae:	13 96       	adiw	r26, 0x03	; 3
    11b0:	3c 93       	st	X, r19
    11b2:	2e 93       	st	-X, r18
    11b4:	12 97       	sbiw	r26, 0x02	; 2
    11b6:	cf 01       	movw	r24, r30
    11b8:	bd dc       	rcall	.-1670   	; 0xb34 <chSchReadyI>
    11ba:	d1 cf       	rjmp	.-94     	; 0x115e <chMtxLockS+0x3c>
    11bc:	22 81       	ldd	r18, Z+2	; 0x02
    11be:	33 81       	ldd	r19, Z+3	; 0x03
    11c0:	80 81       	ld	r24, Z
    11c2:	91 81       	ldd	r25, Z+1	; 0x01
    11c4:	d9 01       	movw	r26, r18
    11c6:	8d 93       	st	X+, r24
    11c8:	9c 93       	st	X, r25
    11ca:	80 81       	ld	r24, Z
    11cc:	91 81       	ldd	r25, Z+1	; 0x01
    11ce:	dc 01       	movw	r26, r24
    11d0:	13 96       	adiw	r26, 0x03	; 3
    11d2:	3c 93       	st	X, r19
    11d4:	2e 93       	st	-X, r18
    11d6:	12 97       	sbiw	r26, 0x02	; 2
    11d8:	22 89       	ldd	r18, Z+18	; 0x12
    11da:	33 89       	ldd	r19, Z+19	; 0x13
    11dc:	a9 01       	movw	r20, r18
    11de:	06 c0       	rjmp	.+12     	; 0x11ec <chMtxLockS+0xca>
    11e0:	da 01       	movw	r26, r20
    11e2:	14 96       	adiw	r26, 0x04	; 4
    11e4:	9c 91       	ld	r25, X
    11e6:	84 81       	ldd	r24, Z+4	; 0x04
    11e8:	98 17       	cp	r25, r24
    11ea:	30 f0       	brcs	.+12     	; 0x11f8 <chMtxLockS+0xd6>
    11ec:	da 01       	movw	r26, r20
    11ee:	4d 91       	ld	r20, X+
    11f0:	5c 91       	ld	r21, X
    11f2:	24 17       	cp	r18, r20
    11f4:	35 07       	cpc	r19, r21
    11f6:	a1 f7       	brne	.-24     	; 0x11e0 <chMtxLockS+0xbe>
    11f8:	51 83       	std	Z+1, r21	; 0x01
    11fa:	40 83       	st	Z, r20
    11fc:	da 01       	movw	r26, r20
    11fe:	12 96       	adiw	r26, 0x02	; 2
    1200:	8d 91       	ld	r24, X+
    1202:	9c 91       	ld	r25, X
    1204:	13 97       	sbiw	r26, 0x03	; 3
    1206:	93 83       	std	Z+3, r25	; 0x03
    1208:	82 83       	std	Z+2, r24	; 0x02
    120a:	dc 01       	movw	r26, r24
    120c:	ed 93       	st	X+, r30
    120e:	fc 93       	st	X, r31
    1210:	da 01       	movw	r26, r20
    1212:	13 96       	adiw	r26, 0x03	; 3
    1214:	fc 93       	st	X, r31
    1216:	ee 93       	st	-X, r30
    1218:	12 97       	sbiw	r26, 0x02	; 2
    121a:	a1 cf       	rjmp	.-190    	; 0x115e <chMtxLockS+0x3c>
    121c:	22 81       	ldd	r18, Z+2	; 0x02
    121e:	33 81       	ldd	r19, Z+3	; 0x03
    1220:	80 81       	ld	r24, Z
    1222:	91 81       	ldd	r25, Z+1	; 0x01
    1224:	d9 01       	movw	r26, r18
    1226:	8d 93       	st	X+, r24
    1228:	9c 93       	st	X, r25
    122a:	80 81       	ld	r24, Z
    122c:	91 81       	ldd	r25, Z+1	; 0x01
    122e:	dc 01       	movw	r26, r24
    1230:	13 96       	adiw	r26, 0x03	; 3
    1232:	3c 93       	st	X, r19
    1234:	2e 93       	st	-X, r18
    1236:	12 97       	sbiw	r26, 0x02	; 2
    1238:	22 89       	ldd	r18, Z+18	; 0x12
    123a:	33 89       	ldd	r19, Z+19	; 0x13
    123c:	a9 01       	movw	r20, r18
    123e:	06 c0       	rjmp	.+12     	; 0x124c <chMtxLockS+0x12a>
    1240:	da 01       	movw	r26, r20
    1242:	14 96       	adiw	r26, 0x04	; 4
    1244:	9c 91       	ld	r25, X
    1246:	84 81       	ldd	r24, Z+4	; 0x04
    1248:	98 17       	cp	r25, r24
    124a:	30 f0       	brcs	.+12     	; 0x1258 <chMtxLockS+0x136>
    124c:	da 01       	movw	r26, r20
    124e:	4d 91       	ld	r20, X+
    1250:	5c 91       	ld	r21, X
    1252:	24 17       	cp	r18, r20
    1254:	35 07       	cpc	r19, r21
    1256:	a1 f7       	brne	.-24     	; 0x1240 <chMtxLockS+0x11e>
    1258:	51 83       	std	Z+1, r21	; 0x01
    125a:	40 83       	st	Z, r20
    125c:	da 01       	movw	r26, r20
    125e:	12 96       	adiw	r26, 0x02	; 2
    1260:	8d 91       	ld	r24, X+
    1262:	9c 91       	ld	r25, X
    1264:	13 97       	sbiw	r26, 0x03	; 3
    1266:	93 83       	std	Z+3, r25	; 0x03
    1268:	82 83       	std	Z+2, r24	; 0x02
    126a:	dc 01       	movw	r26, r24
    126c:	ed 93       	st	X+, r30
    126e:	fc 93       	st	X, r31
    1270:	da 01       	movw	r26, r20
    1272:	13 96       	adiw	r26, 0x03	; 3
    1274:	fc 93       	st	X, r31
    1276:	ee 93       	st	-X, r30
    1278:	12 97       	sbiw	r26, 0x02	; 2
    127a:	02 88       	ldd	r0, Z+18	; 0x12
    127c:	f3 89       	ldd	r31, Z+19	; 0x13
    127e:	e0 2d       	mov	r30, r0
    1280:	04 80       	ldd	r0, Z+4	; 0x04
    1282:	f5 81       	ldd	r31, Z+5	; 0x05
    1284:	e0 2d       	mov	r30, r0
    1286:	8c 81       	ldd	r24, Y+4	; 0x04
    1288:	94 81       	ldd	r25, Z+4	; 0x04
    128a:	98 17       	cp	r25, r24
    128c:	08 f4       	brcc	.+2      	; 0x1290 <chMtxLockS+0x16e>
    128e:	5e cf       	rjmp	.-324    	; 0x114c <chMtxLockS+0x2a>
    1290:	66 cf       	rjmp	.-308    	; 0x115e <chMtxLockS+0x3c>
    1292:	fc 01       	movw	r30, r24
    1294:	d5 83       	std	Z+5, r29	; 0x05
    1296:	c4 83       	std	Z+4, r28	; 0x04
    1298:	2b 8d       	ldd	r18, Y+27	; 0x1b
    129a:	3c 8d       	ldd	r19, Y+28	; 0x1c
    129c:	37 83       	std	Z+7, r19	; 0x07
    129e:	26 83       	std	Z+6, r18	; 0x06
    12a0:	9c 8f       	std	Y+28, r25	; 0x1c
    12a2:	8b 8f       	std	Y+27, r24	; 0x1b
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	1f 91       	pop	r17
    12aa:	0f 91       	pop	r16
    12ac:	08 95       	ret

000012ae <chMtxLock>:
    12ae:	f8 94       	cli
    12b0:	38 df       	rcall	.-400    	; 0x1122 <chMtxLockS>
    12b2:	78 94       	sei
    12b4:	08 95       	ret

000012b6 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to a @p mutex_t object
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	ec 01       	movw	r28, r24
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
    12bc:	40 91 88 04 	lds	r20, 0x0488	; 0x800488 <ch0+0x5>
    12c0:	50 91 89 04 	lds	r21, 0x0489	; 0x800489 <ch0+0x6>
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    12c4:	f8 94       	cli
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
    12c6:	ee 81       	ldd	r30, Y+6	; 0x06
    12c8:	ff 81       	ldd	r31, Y+7	; 0x07
    12ca:	da 01       	movw	r26, r20
    12cc:	5c 96       	adiw	r26, 0x1c	; 28
    12ce:	fc 93       	st	X, r31
    12d0:	ee 93       	st	-X, r30
    12d2:	5b 97       	sbiw	r26, 0x1b	; 27

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    12d4:	a8 81       	ld	r26, Y
    12d6:	b9 81       	ldd	r27, Y+1	; 0x01
    12d8:	a8 17       	cp	r26, r24
    12da:	b9 07       	cpc	r27, r25
    12dc:	a1 f1       	breq	.+104    	; 0x1346 <chMtxUnlock+0x90>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
    12de:	da 01       	movw	r26, r20
    12e0:	5d 96       	adiw	r26, 0x1d	; 29
    12e2:	2c 91       	ld	r18, X
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    12e4:	30 97       	sbiw	r30, 0x00	; 0
    12e6:	79 f0       	breq	.+30     	; 0x1306 <chMtxUnlock+0x50>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
    12e8:	a0 81       	ld	r26, Z
    12ea:	b1 81       	ldd	r27, Z+1	; 0x01
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    12ec:	ea 17       	cp	r30, r26
    12ee:	fb 07       	cpc	r31, r27
    12f0:	29 f0       	breq	.+10     	; 0x12fc <chMtxUnlock+0x46>
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
    12f2:	14 96       	adiw	r26, 0x04	; 4
    12f4:	9c 91       	ld	r25, X
    12f6:	29 17       	cp	r18, r25
    12f8:	08 f4       	brcc	.+2      	; 0x12fc <chMtxUnlock+0x46>
    12fa:	29 2f       	mov	r18, r25
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
    12fc:	06 80       	ldd	r0, Z+6	; 0x06
    12fe:	f7 81       	ldd	r31, Z+7	; 0x07
    1300:	e0 2d       	mov	r30, r0

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
    1302:	30 97       	sbiw	r30, 0x00	; 0
    1304:	89 f7       	brne	.-30     	; 0x12e8 <chMtxUnlock+0x32>
    1306:	fe 01       	movw	r30, r28
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
    1308:	da 01       	movw	r26, r20
    130a:	14 96       	adiw	r26, 0x04	; 4
    130c:	2c 93       	st	X, r18
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
    130e:	a8 81       	ld	r26, Y
    1310:	b9 81       	ldd	r27, Y+1	; 0x01

  qp->next       = p->next;
    1312:	cd 91       	ld	r28, X+
    1314:	dc 91       	ld	r29, X
    1316:	11 97       	sbiw	r26, 0x01	; 1
    1318:	d1 83       	std	Z+1, r29	; 0x01
    131a:	c0 83       	st	Z, r28
  qp->next->prev = qp;
    131c:	fb 83       	std	Y+3, r31	; 0x03
    131e:	ea 83       	std	Y+2, r30	; 0x02
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
    1320:	b5 83       	std	Z+5, r27	; 0x05
    1322:	a4 83       	std	Z+4, r26	; 0x04
      mp->next = tp->mtxlist;
    1324:	5b 96       	adiw	r26, 0x1b	; 27
    1326:	8d 91       	ld	r24, X+
    1328:	9c 91       	ld	r25, X
    132a:	5c 97       	sbiw	r26, 0x1c	; 28
    132c:	97 83       	std	Z+7, r25	; 0x07
    132e:	86 83       	std	Z+6, r24	; 0x06
      tp->mtxlist = mp;
    1330:	5c 96       	adiw	r26, 0x1c	; 28
    1332:	fc 93       	st	X, r31
    1334:	ee 93       	st	-X, r30
    1336:	5b 97       	sbiw	r26, 0x1b	; 27

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1338:	cd 01       	movw	r24, r26
    133a:	fc db       	rcall	.-2056   	; 0xb34 <chSchReadyI>
      chSchRescheduleS();
    133c:	1e dd       	rcall	.-1476   	; 0xd7a <chSchRescheduleS>
    133e:	78 94       	sei
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1340:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret
    1346:	15 96       	adiw	r26, 0x05	; 5
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
    1348:	1c 92       	st	X, r1
    134a:	1e 92       	st	-X, r1
    134c:	14 97       	sbiw	r26, 0x04	; 4
    134e:	78 94       	sei
    1350:	df 91       	pop	r29
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    1352:	cf 91       	pop	r28
    1354:	08 95       	ret

00001356 <chEvtObjectInit>:
    1356:	fc 01       	movw	r30, r24
    1358:	91 83       	std	Z+1, r25	; 0x01
    135a:	80 83       	st	Z, r24
    135c:	08 95       	ret

0000135e <chEvtSignalI>:
    135e:	fc 01       	movw	r30, r24
    1360:	92 8d       	ldd	r25, Z+26	; 0x1a
    1362:	69 2b       	or	r22, r25
    1364:	62 8f       	std	Z+26, r22	; 0x1a
    1366:	87 85       	ldd	r24, Z+15	; 0x0f
    1368:	8a 30       	cpi	r24, 0x0A	; 10
    136a:	59 f0       	breq	.+22     	; 0x1382 <chEvtSignalI+0x24>
    136c:	8b 30       	cpi	r24, 0x0B	; 11
    136e:	09 f0       	breq	.+2      	; 0x1372 <chEvtSignalI+0x14>
    1370:	08 95       	ret
    1372:	82 89       	ldd	r24, Z+18	; 0x12
    1374:	68 23       	and	r22, r24
    1376:	86 13       	cpse	r24, r22
    1378:	fb cf       	rjmp	.-10     	; 0x1370 <chEvtSignalI+0x12>
    137a:	13 8a       	std	Z+19, r1	; 0x13
    137c:	12 8a       	std	Z+18, r1	; 0x12
    137e:	cf 01       	movw	r24, r30
    1380:	d9 cb       	rjmp	.-2126   	; 0xb34 <chSchReadyI>
    1382:	82 89       	ldd	r24, Z+18	; 0x12
    1384:	68 23       	and	r22, r24
    1386:	c9 f7       	brne	.-14     	; 0x137a <chEvtSignalI+0x1c>
    1388:	08 95       	ret

0000138a <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t object
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    138a:	ef 92       	push	r14
    138c:	ff 92       	push	r15
    138e:	1f 93       	push	r17
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
    1394:	7c 01       	movw	r14, r24
    1396:	16 2f       	mov	r17, r22
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
    1398:	fc 01       	movw	r30, r24
    139a:	c0 81       	ld	r28, Z
    139c:	d1 81       	ldd	r29, Z+1	; 0x01
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    139e:	8c 17       	cp	r24, r28
    13a0:	9d 07       	cpc	r25, r29
    13a2:	91 f0       	breq	.+36     	; 0x13c8 <chEvtBroadcastFlagsI+0x3e>
  /*lint -restore*/
    elp->flags |= flags;
    13a4:	8d 81       	ldd	r24, Y+5	; 0x05
    13a6:	81 2b       	or	r24, r17
    13a8:	8d 83       	std	Y+5, r24	; 0x05
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
    13aa:	11 23       	and	r17, r17
    13ac:	19 f0       	breq	.+6      	; 0x13b4 <chEvtBroadcastFlagsI+0x2a>
    13ae:	8e 81       	ldd	r24, Y+6	; 0x06
    13b0:	81 23       	and	r24, r17
    13b2:	21 f0       	breq	.+8      	; 0x13bc <chEvtBroadcastFlagsI+0x32>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    13b4:	6c 81       	ldd	r22, Y+4	; 0x04
    13b6:	8a 81       	ldd	r24, Y+2	; 0x02
    13b8:	9b 81       	ldd	r25, Y+3	; 0x03
    13ba:	d1 df       	rcall	.-94     	; 0x135e <chEvtSignalI>
    }
    elp = elp->next;
    13bc:	09 90       	ld	r0, Y+
    13be:	d8 81       	ld	r29, Y
    13c0:	c0 2d       	mov	r28, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
    13c2:	ec 16       	cp	r14, r28
    13c4:	fd 06       	cpc	r15, r29
    13c6:	71 f7       	brne	.-36     	; 0x13a4 <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	1f 91       	pop	r17
    13ce:	ff 90       	pop	r15
    13d0:	ef 90       	pop	r14
    13d2:	08 95       	ret

000013d4 <__core_init>:
  chSysLock();
  p = chCoreAllocFromBaseI(size, align, offset);
  chSysUnlock();

  return p;
}
    13d4:	e6 ec       	ldi	r30, 0xC6	; 198
    13d6:	f4 e0       	ldi	r31, 0x04	; 4
    13d8:	87 ed       	ldi	r24, 0xD7	; 215
    13da:	91 e0       	ldi	r25, 0x01	; 1
    13dc:	91 83       	std	Z+1, r25	; 0x01
    13de:	80 83       	st	Z, r24
    13e0:	87 e5       	ldi	r24, 0x57	; 87
    13e2:	92 e0       	ldi	r25, 0x02	; 2
    13e4:	93 83       	std	Z+3, r25	; 0x03
    13e6:	82 83       	std	Z+2, r24	; 0x02
    13e8:	08 95       	ret

000013ea <chCoreAllocFromTop>:
 * @details Usually this function just disables interrupts but may perform more
 *          actions.
 */
static inline void port_lock(void) {

  asm volatile ("cli" : : : "memory");
    13ea:	f8 94       	cli
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
    13ec:	20 91 c8 04 	lds	r18, 0x04C8	; 0x8004c8 <ch_memcore+0x2>
    13f0:	30 91 c9 04 	lds	r19, 0x04C9	; 0x8004c9 <ch_memcore+0x3>
    13f4:	f9 01       	movw	r30, r18
    13f6:	e8 1b       	sub	r30, r24
    13f8:	f9 0b       	sbc	r31, r25
    13fa:	71 95       	neg	r23
    13fc:	61 95       	neg	r22
    13fe:	71 09       	sbc	r23, r1
    1400:	6e 23       	and	r22, r30
    1402:	7f 23       	and	r23, r31
  prev = p - offset;
    1404:	cb 01       	movw	r24, r22
    1406:	84 1b       	sub	r24, r20
    1408:	95 0b       	sbc	r25, r21

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    140a:	40 91 c6 04 	lds	r20, 0x04C6	; 0x8004c6 <ch_memcore>
    140e:	50 91 c7 04 	lds	r21, 0x04C7	; 0x8004c7 <ch_memcore+0x1>
    1412:	84 17       	cp	r24, r20
    1414:	95 07       	cpc	r25, r21
    1416:	50 f0       	brcs	.+20     	; 0x142c <chCoreAllocFromTop+0x42>
    1418:	28 17       	cp	r18, r24
    141a:	39 07       	cpc	r19, r25
    141c:	38 f0       	brcs	.+14     	; 0x142c <chCoreAllocFromTop+0x42>
    return NULL;
  }

  ch_memcore.topmem = prev;
    141e:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <ch_memcore+0x3>
    1422:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <ch_memcore+0x2>

  return p;
    1426:	cb 01       	movw	r24, r22
 * @details Usually this function just enables interrupts but may perform more
 *          actions.
 */
static inline void port_unlock(void) {

  asm volatile ("sei" : : : "memory");
    1428:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    142a:	08 95       	ret
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	78 94       	sei
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
    1432:	08 95       	ret

00001434 <chCoreGetStatusX>:
 *
 * @xclass
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
    1434:	e6 ec       	ldi	r30, 0xC6	; 198
    1436:	f4 e0       	ldi	r31, 0x04	; 4
    1438:	40 81       	ld	r20, Z
    143a:	51 81       	ldd	r21, Z+1	; 0x01
    143c:	dc 01       	movw	r26, r24
    143e:	11 96       	adiw	r26, 0x01	; 1
    1440:	5c 93       	st	X, r21
    1442:	4e 93       	st	-X, r20
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
    1444:	22 81       	ldd	r18, Z+2	; 0x02
    1446:	33 81       	ldd	r19, Z+3	; 0x03
    1448:	24 1b       	sub	r18, r20
    144a:	35 0b       	sbc	r19, r21
    144c:	13 96       	adiw	r26, 0x03	; 3
    144e:	3c 93       	st	X, r19
    1450:	2e 93       	st	-X, r18
    1452:	12 97       	sbiw	r26, 0x02	; 2
    1454:	08 95       	ret

00001456 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29

  default_heap.provider = chCoreAllocAlignedWithOffset;
    145a:	c7 e5       	ldi	r28, 0x57	; 87
    145c:	d2 e0       	ldi	r29, 0x02	; 2
    145e:	85 ef       	ldi	r24, 0xF5	; 245
    1460:	99 e0       	ldi	r25, 0x09	; 9
    1462:	99 83       	std	Y+1, r25	; 0x01
    1464:	88 83       	st	Y, r24
  chCoreGetStatusX(&default_heap.area);
    1466:	89 e5       	ldi	r24, 0x59	; 89
    1468:	92 e0       	ldi	r25, 0x02	; 2
    146a:	e4 df       	rcall	.-56     	; 0x1434 <chCoreGetStatusX>
  H_FREE_NEXT(&default_heap.header) = NULL;
    146c:	1f 82       	std	Y+7, r1	; 0x07
    146e:	1e 82       	std	Y+6, r1	; 0x06
  H_FREE_PAGES(&default_heap.header) = 0;
    1470:	19 86       	std	Y+9, r1	; 0x09
    1472:	18 86       	std	Y+8, r1	; 0x08
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    1474:	81 e6       	ldi	r24, 0x61	; 97
    1476:	92 e0       	ldi	r25, 0x02	; 2
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
    1478:	df 91       	pop	r29
  default_heap.provider = chCoreAllocAlignedWithOffset;
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    147a:	cf 91       	pop	r28
    147c:	4a ce       	rjmp	.-876    	; 0x1112 <chMtxObjectInit>

0000147e <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
    147e:	2f 92       	push	r2
  asm volatile ("push    r3");
    1480:	3f 92       	push	r3
  asm volatile ("push    r4");
    1482:	4f 92       	push	r4
  asm volatile ("push    r5");
    1484:	5f 92       	push	r5
  asm volatile ("push    r6");
    1486:	6f 92       	push	r6
  asm volatile ("push    r7");
    1488:	7f 92       	push	r7
  asm volatile ("push    r8");
    148a:	8f 92       	push	r8
  asm volatile ("push    r9");
    148c:	9f 92       	push	r9
  asm volatile ("push    r10");
    148e:	af 92       	push	r10
  asm volatile ("push    r11");
    1490:	bf 92       	push	r11
  asm volatile ("push    r12");
    1492:	cf 92       	push	r12
  asm volatile ("push    r13");
    1494:	df 92       	push	r13
  asm volatile ("push    r14");
    1496:	ef 92       	push	r14
  asm volatile ("push    r15");
    1498:	ff 92       	push	r15
  asm volatile ("push    r16");
    149a:	0f 93       	push	r16
  asm volatile ("push    r17");
    149c:	1f 93       	push	r17
  asm volatile ("push    r28");
    149e:	cf 93       	push	r28
  asm volatile ("push    r29");
    14a0:	df 93       	push	r29

#if defined(__CHIBIOS_RT__)
  asm volatile ("movw    r30, r22");
    14a2:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
    14a4:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
    14a6:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
    14a8:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
    14aa:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
    14ac:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
    14ae:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
    14b0:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
    14b2:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
    14b4:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
    14b6:	df 91       	pop	r29
  asm volatile ("pop     r28");
    14b8:	cf 91       	pop	r28
  asm volatile ("pop     r17");
    14ba:	1f 91       	pop	r17
  asm volatile ("pop     r16");
    14bc:	0f 91       	pop	r16
  asm volatile ("pop     r15");
    14be:	ff 90       	pop	r15
  asm volatile ("pop     r14");
    14c0:	ef 90       	pop	r14
  asm volatile ("pop     r13");
    14c2:	df 90       	pop	r13
  asm volatile ("pop     r12");
    14c4:	cf 90       	pop	r12
  asm volatile ("pop     r11");
    14c6:	bf 90       	pop	r11
  asm volatile ("pop     r10");
    14c8:	af 90       	pop	r10
  asm volatile ("pop     r9");
    14ca:	9f 90       	pop	r9
  asm volatile ("pop     r8");
    14cc:	8f 90       	pop	r8
  asm volatile ("pop     r7");
    14ce:	7f 90       	pop	r7
  asm volatile ("pop     r6");
    14d0:	6f 90       	pop	r6
  asm volatile ("pop     r5");
    14d2:	5f 90       	pop	r5
  asm volatile ("pop     r4");
    14d4:	4f 90       	pop	r4
  asm volatile ("pop     r3");
    14d6:	3f 90       	pop	r3
  asm volatile ("pop     r2");
    14d8:	2f 90       	pop	r2
  asm volatile ("ret");
    14da:	08 95       	ret

000014dc <_port_thread_start>:
    14dc:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
    14de:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
    14e0:	f1 01       	movw	r30, r2
  asm volatile ("icall");
    14e2:	09 95       	icall
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
    14e4:	d2 cd       	rjmp	.-1116   	; 0x108a <chThdExit>

000014e6 <Thread2>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
    14e6:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
    14ea:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
    14ee:	8a e5       	ldi	r24, 0x5A	; 90
    14f0:	91 e0       	ldi	r25, 0x01	; 1
    14f2:	96 87       	std	Z+14, r25	; 0x0e
    14f4:	85 87       	std	Z+13, r24	; 0x0d
static THD_FUNCTION(Thread2, arg) {
    (void)arg;
    chRegSetThreadName("Thread 2");

    while (true) {
        chMtxLock(&myMutex);  // Trava o mutex
    14f6:	8f e2       	ldi	r24, 0x2F	; 47
    14f8:	94 e0       	ldi	r25, 0x04	; 4
    14fa:	d9 de       	rcall	.-590    	; 0x12ae <chMtxLock>

        // Seo crtica - Acesso exclusivo
        palSetPad(IOPORT4, 7);  // Liga LED no pino PB4
    14fc:	5f 9a       	sbi	0x0b, 7	; 11
        chThdSleepMilliseconds(1000);
    14fe:	88 e0       	ldi	r24, 0x08	; 8
    1500:	9d e3       	ldi	r25, 0x3D	; 61
    1502:	c5 dd       	rcall	.-1142   	; 0x108e <chThdSleep>
        palClearPad(IOPORT4, 7);  // Desliga LED
    1504:	5f 98       	cbi	0x0b, 7	; 11
        chThdSleepMilliseconds(1000);
    1506:	88 e0       	ldi	r24, 0x08	; 8
    1508:	9d e3       	ldi	r25, 0x3D	; 61
    150a:	c1 dd       	rcall	.-1150   	; 0x108e <chThdSleep>

        chMtxUnlock(&myMutex);  // Libera o mutex
    150c:	8f e2       	ldi	r24, 0x2F	; 47
    150e:	94 e0       	ldi	r25, 0x04	; 4
    1510:	d2 de       	rcall	.-604    	; 0x12b6 <chMtxUnlock>
        chThdSleepMilliseconds(100);  // Pausa antes da prxima iterao
    1512:	8b e1       	ldi	r24, 0x1B	; 27
    1514:	96 e0       	ldi	r25, 0x06	; 6
    1516:	bb dd       	rcall	.-1162   	; 0x108e <chThdSleep>
    1518:	ee cf       	rjmp	.-36     	; 0x14f6 <Thread2+0x10>

0000151a <Thread1>:
    151a:	e0 91 88 04 	lds	r30, 0x0488	; 0x800488 <ch0+0x5>
    151e:	f0 91 89 04 	lds	r31, 0x0489	; 0x800489 <ch0+0x6>
    1522:	83 e6       	ldi	r24, 0x63	; 99
    1524:	91 e0       	ldi	r25, 0x01	; 1
    1526:	96 87       	std	Z+14, r25	; 0x0e
    1528:	85 87       	std	Z+13, r24	; 0x0d
static THD_FUNCTION(Thread1, arg) {
    (void)arg;
    chRegSetThreadName("Thread 1");

    while (true) {
        chMtxLock(&myMutex);  // Trava o mutex
    152a:	8f e2       	ldi	r24, 0x2F	; 47
    152c:	94 e0       	ldi	r25, 0x04	; 4
    152e:	bf de       	rcall	.-642    	; 0x12ae <chMtxLock>

        // Seo crtica - Acesso exclusivo
        palSetPad(IOPORT2, 5);  // Liga LED no pino PB5
    1530:	2d 9a       	sbi	0x05, 5	; 5
        chThdSleepMilliseconds(200);
    1532:	85 e3       	ldi	r24, 0x35	; 53
    1534:	9c e0       	ldi	r25, 0x0C	; 12
    1536:	ab dd       	rcall	.-1194   	; 0x108e <chThdSleep>
        palClearPad(IOPORT2, 5);  // Desliga LED
    1538:	2d 98       	cbi	0x05, 5	; 5
        chThdSleepMilliseconds(200);
    153a:	85 e3       	ldi	r24, 0x35	; 53
    153c:	9c e0       	ldi	r25, 0x0C	; 12
    153e:	a7 dd       	rcall	.-1202   	; 0x108e <chThdSleep>

        chMtxUnlock(&myMutex);  // Libera o mutex
    1540:	8f e2       	ldi	r24, 0x2F	; 47
    1542:	94 e0       	ldi	r25, 0x04	; 4
    1544:	b8 de       	rcall	.-656    	; 0x12b6 <chMtxUnlock>
        chThdSleepMilliseconds(100);  // Pausa antes da prxima iterao
    1546:	8b e1       	ldi	r24, 0x1B	; 27
    1548:	96 e0       	ldi	r25, 0x06	; 6
    154a:	a1 dd       	rcall	.-1214   	; 0x108e <chThdSleep>
    154c:	ee cf       	rjmp	.-36     	; 0x152a <Thread1+0x10>

0000154e <main>:
    154e:	0e 94 63 00 	call	0xc6	; 0xc6 <halInit>

// Funo principal (main)
int main(void) {
    // Inicializa o ChibiOS
    halInit();
    chSysInit();
    1552:	b0 d9       	rcall	.-3232   	; 0x8b4 <chSysInit>
    
    // Configurao dos pinos
    palSetPadMode(IOPORT4, 7, PAL_MODE_OUTPUT_PUSHPULL);
    1554:	46 e0       	ldi	r20, 0x06	; 6
    1556:	60 e8       	ldi	r22, 0x80	; 128
    1558:	89 e2       	ldi	r24, 0x29	; 41
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	d0 d8       	rcall	.-3680   	; 0x6fe <_pal_lld_setgroupmode>
    palSetPadMode(IOPORT2, 5, PAL_MODE_OUTPUT_PUSHPULL);
    155e:	46 e0       	ldi	r20, 0x06	; 6
    1560:	60 e2       	ldi	r22, 0x20	; 32
    1562:	83 e2       	ldi	r24, 0x23	; 35
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	cb d8       	rcall	.-3690   	; 0x6fe <_pal_lld_setgroupmode>
    palClearPad(IOPORT4, 7);
    1568:	5f 98       	cbi	0x0b, 7	; 11
    palClearPad(IOPORT2, 5);

    // Inicializa o mutex
    chMtxObjectInit(&myMutex);
    156a:	2d 98       	cbi	0x05, 5	; 5
    156c:	8f e2       	ldi	r24, 0x2F	; 47
    156e:	94 e0       	ldi	r25, 0x04	; 4
    1570:	d0 dd       	rcall	.-1120   	; 0x1112 <chMtxObjectInit>

    // Cria as duas threads
    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    1572:	00 e0       	ldi	r16, 0x00	; 0
    1574:	10 e0       	ldi	r17, 0x00	; 0
    1576:	2d e8       	ldi	r18, 0x8D	; 141
    1578:	3a e0       	ldi	r19, 0x0A	; 10
    157a:	40 e8       	ldi	r20, 0x80	; 128
    157c:	63 ee       	ldi	r22, 0xE3	; 227
    157e:	70 e0       	ldi	r23, 0x00	; 0
    1580:	8c e4       	ldi	r24, 0x4C	; 76
    1582:	93 e0       	ldi	r25, 0x03	; 3
    1584:	07 dd       	rcall	.-1522   	; 0xf94 <chThdCreateStatic>
    chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
    1586:	23 e7       	ldi	r18, 0x73	; 115
    1588:	3a e0       	ldi	r19, 0x0A	; 10
    158a:	40 e8       	ldi	r20, 0x80	; 128
    158c:	63 ee       	ldi	r22, 0xE3	; 227
    158e:	70 e0       	ldi	r23, 0x00	; 0
    1590:	89 e6       	ldi	r24, 0x69	; 105
    1592:	92 e0       	ldi	r25, 0x02	; 2

    // Loop infinito para manter o sistema rodando
    while (true) {
        chThdSleepMilliseconds(1000);
    1594:	ff dc       	rcall	.-1538   	; 0xf94 <chThdCreateStatic>
    1596:	88 e0       	ldi	r24, 0x08	; 8
    1598:	9d e3       	ldi	r25, 0x3D	; 61
    159a:	79 dd       	rcall	.-1294   	; 0x108e <chThdSleep>
    159c:	fc cf       	rjmp	.-8      	; 0x1596 <main+0x48>

0000159e <vfprintf>:
    159e:	ab e0       	ldi	r26, 0x0B	; 11
    15a0:	b0 e0       	ldi	r27, 0x00	; 0
    15a2:	e4 ed       	ldi	r30, 0xD4	; 212
    15a4:	fa e0       	ldi	r31, 0x0A	; 10
    15a6:	d3 c2       	rjmp	.+1446   	; 0x1b4e <__prologue_saves__+0x8>
    15a8:	6c 01       	movw	r12, r24
    15aa:	7b 01       	movw	r14, r22
    15ac:	3a 01       	movw	r6, r20
    15ae:	fc 01       	movw	r30, r24
    15b0:	17 82       	std	Z+7, r1	; 0x07
    15b2:	16 82       	std	Z+6, r1	; 0x06
    15b4:	83 81       	ldd	r24, Z+3	; 0x03
    15b6:	81 ff       	sbrs	r24, 1
    15b8:	f9 c0       	rjmp	.+498    	; 0x17ac <vfprintf+0x20e>
    15ba:	ce 01       	movw	r24, r28
    15bc:	01 96       	adiw	r24, 0x01	; 1
    15be:	4c 01       	movw	r8, r24
    15c0:	f6 01       	movw	r30, r12
    15c2:	b3 80       	ldd	r11, Z+3	; 0x03
    15c4:	f7 01       	movw	r30, r14
    15c6:	b3 fc       	sbrc	r11, 3
    15c8:	05 91       	lpm	r16, Z+
    15ca:	b3 fe       	sbrs	r11, 3
    15cc:	01 91       	ld	r16, Z+
    15ce:	7f 01       	movw	r14, r30
    15d0:	00 23       	and	r16, r16
    15d2:	09 f4       	brne	.+2      	; 0x15d6 <vfprintf+0x38>
    15d4:	e7 c0       	rjmp	.+462    	; 0x17a4 <vfprintf+0x206>
    15d6:	05 32       	cpi	r16, 0x25	; 37
    15d8:	49 f4       	brne	.+18     	; 0x15ec <vfprintf+0x4e>
    15da:	b3 fc       	sbrc	r11, 3
    15dc:	05 91       	lpm	r16, Z+
    15de:	b3 fe       	sbrs	r11, 3
    15e0:	01 91       	ld	r16, Z+
    15e2:	7f 01       	movw	r14, r30
    15e4:	05 32       	cpi	r16, 0x25	; 37
    15e6:	11 f0       	breq	.+4      	; 0x15ec <vfprintf+0x4e>
    15e8:	10 e0       	ldi	r17, 0x00	; 0
    15ea:	17 c0       	rjmp	.+46     	; 0x161a <vfprintf+0x7c>
    15ec:	b6 01       	movw	r22, r12
    15ee:	80 2f       	mov	r24, r16
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	3a d3       	rcall	.+1652   	; 0x1c68 <fputc>
    15f4:	53 01       	movw	r10, r6
    15f6:	35 01       	movw	r6, r10
    15f8:	e3 cf       	rjmp	.-58     	; 0x15c0 <vfprintf+0x22>
    15fa:	00 23       	and	r16, r16
    15fc:	09 f4       	brne	.+2      	; 0x1600 <vfprintf+0x62>
    15fe:	d2 c0       	rjmp	.+420    	; 0x17a4 <vfprintf+0x206>
    1600:	60 2f       	mov	r22, r16
    1602:	70 e0       	ldi	r23, 0x00	; 0
    1604:	8f e6       	ldi	r24, 0x6F	; 111
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	dd d2       	rcall	.+1466   	; 0x1bc4 <strchr_P>
    160a:	89 2b       	or	r24, r25
    160c:	49 f0       	breq	.+18     	; 0x1620 <vfprintf+0x82>
    160e:	f7 01       	movw	r30, r14
    1610:	b3 fc       	sbrc	r11, 3
    1612:	05 91       	lpm	r16, Z+
    1614:	b3 fe       	sbrs	r11, 3
    1616:	01 91       	ld	r16, Z+
    1618:	7f 01       	movw	r14, r30
    161a:	17 ff       	sbrs	r17, 7
    161c:	ee cf       	rjmp	.-36     	; 0x15fa <vfprintf+0x5c>
    161e:	04 c0       	rjmp	.+8      	; 0x1628 <vfprintf+0x8a>
    1620:	03 32       	cpi	r16, 0x23	; 35
    1622:	39 f0       	breq	.+14     	; 0x1632 <vfprintf+0x94>
    1624:	0c 36       	cpi	r16, 0x6C	; 108
    1626:	19 f0       	breq	.+6      	; 0x162e <vfprintf+0x90>
    1628:	01 11       	cpse	r16, r1
    162a:	05 c0       	rjmp	.+10     	; 0x1636 <vfprintf+0x98>
    162c:	bb c0       	rjmp	.+374    	; 0x17a4 <vfprintf+0x206>
    162e:	10 68       	ori	r17, 0x80	; 128
    1630:	ee cf       	rjmp	.-36     	; 0x160e <vfprintf+0x70>
    1632:	10 e1       	ldi	r17, 0x10	; 16
    1634:	ec cf       	rjmp	.-40     	; 0x160e <vfprintf+0x70>
    1636:	60 2f       	mov	r22, r16
    1638:	70 e0       	ldi	r23, 0x00	; 0
    163a:	88 e6       	ldi	r24, 0x68	; 104
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	c2 d2       	rcall	.+1412   	; 0x1bc4 <strchr_P>
    1640:	89 2b       	or	r24, r25
    1642:	41 f0       	breq	.+16     	; 0x1654 <vfprintf+0xb6>
    1644:	53 01       	movw	r10, r6
    1646:	f4 e0       	ldi	r31, 0x04	; 4
    1648:	af 0e       	add	r10, r31
    164a:	b1 1c       	adc	r11, r1
    164c:	b6 01       	movw	r22, r12
    164e:	8f e3       	ldi	r24, 0x3F	; 63
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	10 c0       	rjmp	.+32     	; 0x1674 <vfprintf+0xd6>
    1654:	03 36       	cpi	r16, 0x63	; 99
    1656:	31 f0       	breq	.+12     	; 0x1664 <vfprintf+0xc6>
    1658:	03 37       	cpi	r16, 0x73	; 115
    165a:	71 f0       	breq	.+28     	; 0x1678 <vfprintf+0xda>
    165c:	03 35       	cpi	r16, 0x53	; 83
    165e:	01 f5       	brne	.+64     	; 0x16a0 <vfprintf+0x102>
    1660:	11 60       	ori	r17, 0x01	; 1
    1662:	0a c0       	rjmp	.+20     	; 0x1678 <vfprintf+0xda>
    1664:	53 01       	movw	r10, r6
    1666:	82 e0       	ldi	r24, 0x02	; 2
    1668:	a8 0e       	add	r10, r24
    166a:	b1 1c       	adc	r11, r1
    166c:	b6 01       	movw	r22, r12
    166e:	f3 01       	movw	r30, r6
    1670:	80 81       	ld	r24, Z
    1672:	91 81       	ldd	r25, Z+1	; 0x01
    1674:	f9 d2       	rcall	.+1522   	; 0x1c68 <fputc>
    1676:	bf cf       	rjmp	.-130    	; 0x15f6 <vfprintf+0x58>
    1678:	53 01       	movw	r10, r6
    167a:	f2 e0       	ldi	r31, 0x02	; 2
    167c:	af 0e       	add	r10, r31
    167e:	b1 1c       	adc	r11, r1
    1680:	f3 01       	movw	r30, r6
    1682:	60 80       	ld	r6, Z
    1684:	71 80       	ldd	r7, Z+1	; 0x01
    1686:	f3 01       	movw	r30, r6
    1688:	10 fd       	sbrc	r17, 0
    168a:	85 91       	lpm	r24, Z+
    168c:	10 ff       	sbrs	r17, 0
    168e:	81 91       	ld	r24, Z+
    1690:	3f 01       	movw	r6, r30
    1692:	88 23       	and	r24, r24
    1694:	09 f4       	brne	.+2      	; 0x1698 <vfprintf+0xfa>
    1696:	af cf       	rjmp	.-162    	; 0x15f6 <vfprintf+0x58>
    1698:	b6 01       	movw	r22, r12
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	e5 d2       	rcall	.+1482   	; 0x1c68 <fputc>
    169e:	f3 cf       	rjmp	.-26     	; 0x1686 <vfprintf+0xe8>
    16a0:	04 36       	cpi	r16, 0x64	; 100
    16a2:	11 f0       	breq	.+4      	; 0x16a8 <vfprintf+0x10a>
    16a4:	09 36       	cpi	r16, 0x69	; 105
    16a6:	21 f5       	brne	.+72     	; 0x16f0 <vfprintf+0x152>
    16a8:	53 01       	movw	r10, r6
    16aa:	17 ff       	sbrs	r17, 7
    16ac:	09 c0       	rjmp	.+18     	; 0x16c0 <vfprintf+0x122>
    16ae:	f4 e0       	ldi	r31, 0x04	; 4
    16b0:	af 0e       	add	r10, r31
    16b2:	b1 1c       	adc	r11, r1
    16b4:	f3 01       	movw	r30, r6
    16b6:	60 81       	ld	r22, Z
    16b8:	71 81       	ldd	r23, Z+1	; 0x01
    16ba:	82 81       	ldd	r24, Z+2	; 0x02
    16bc:	93 81       	ldd	r25, Z+3	; 0x03
    16be:	0a c0       	rjmp	.+20     	; 0x16d4 <vfprintf+0x136>
    16c0:	f2 e0       	ldi	r31, 0x02	; 2
    16c2:	af 0e       	add	r10, r31
    16c4:	b1 1c       	adc	r11, r1
    16c6:	f3 01       	movw	r30, r6
    16c8:	60 81       	ld	r22, Z
    16ca:	71 81       	ldd	r23, Z+1	; 0x01
    16cc:	07 2e       	mov	r0, r23
    16ce:	00 0c       	add	r0, r0
    16d0:	88 0b       	sbc	r24, r24
    16d2:	99 0b       	sbc	r25, r25
    16d4:	1f 7e       	andi	r17, 0xEF	; 239
    16d6:	97 ff       	sbrs	r25, 7
    16d8:	08 c0       	rjmp	.+16     	; 0x16ea <vfprintf+0x14c>
    16da:	90 95       	com	r25
    16dc:	80 95       	com	r24
    16de:	70 95       	com	r23
    16e0:	61 95       	neg	r22
    16e2:	7f 4f       	sbci	r23, 0xFF	; 255
    16e4:	8f 4f       	sbci	r24, 0xFF	; 255
    16e6:	9f 4f       	sbci	r25, 0xFF	; 255
    16e8:	10 64       	ori	r17, 0x40	; 64
    16ea:	2a e0       	ldi	r18, 0x0A	; 10
    16ec:	30 e0       	ldi	r19, 0x00	; 0
    16ee:	30 c0       	rjmp	.+96     	; 0x1750 <vfprintf+0x1b2>
    16f0:	00 37       	cpi	r16, 0x70	; 112
    16f2:	91 f0       	breq	.+36     	; 0x1718 <vfprintf+0x17a>
    16f4:	40 f4       	brcc	.+16     	; 0x1706 <vfprintf+0x168>
    16f6:	08 35       	cpi	r16, 0x58	; 88
    16f8:	a1 f0       	breq	.+40     	; 0x1722 <vfprintf+0x184>
    16fa:	0f 36       	cpi	r16, 0x6F	; 111
    16fc:	09 f0       	breq	.+2      	; 0x1700 <vfprintf+0x162>
    16fe:	52 c0       	rjmp	.+164    	; 0x17a4 <vfprintf+0x206>
    1700:	28 e0       	ldi	r18, 0x08	; 8
    1702:	30 e0       	ldi	r19, 0x00	; 0
    1704:	11 c0       	rjmp	.+34     	; 0x1728 <vfprintf+0x18a>
    1706:	05 37       	cpi	r16, 0x75	; 117
    1708:	19 f0       	breq	.+6      	; 0x1710 <vfprintf+0x172>
    170a:	08 37       	cpi	r16, 0x78	; 120
    170c:	31 f0       	breq	.+12     	; 0x171a <vfprintf+0x17c>
    170e:	4a c0       	rjmp	.+148    	; 0x17a4 <vfprintf+0x206>
    1710:	1f 7e       	andi	r17, 0xEF	; 239
    1712:	2a e0       	ldi	r18, 0x0A	; 10
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	08 c0       	rjmp	.+16     	; 0x1728 <vfprintf+0x18a>
    1718:	10 61       	ori	r17, 0x10	; 16
    171a:	14 62       	ori	r17, 0x24	; 36
    171c:	20 e1       	ldi	r18, 0x10	; 16
    171e:	30 e0       	ldi	r19, 0x00	; 0
    1720:	03 c0       	rjmp	.+6      	; 0x1728 <vfprintf+0x18a>
    1722:	14 60       	ori	r17, 0x04	; 4
    1724:	20 e1       	ldi	r18, 0x10	; 16
    1726:	32 e0       	ldi	r19, 0x02	; 2
    1728:	53 01       	movw	r10, r6
    172a:	17 ff       	sbrs	r17, 7
    172c:	09 c0       	rjmp	.+18     	; 0x1740 <vfprintf+0x1a2>
    172e:	f4 e0       	ldi	r31, 0x04	; 4
    1730:	af 0e       	add	r10, r31
    1732:	b1 1c       	adc	r11, r1
    1734:	f3 01       	movw	r30, r6
    1736:	60 81       	ld	r22, Z
    1738:	71 81       	ldd	r23, Z+1	; 0x01
    173a:	82 81       	ldd	r24, Z+2	; 0x02
    173c:	93 81       	ldd	r25, Z+3	; 0x03
    173e:	08 c0       	rjmp	.+16     	; 0x1750 <vfprintf+0x1b2>
    1740:	f2 e0       	ldi	r31, 0x02	; 2
    1742:	af 0e       	add	r10, r31
    1744:	b1 1c       	adc	r11, r1
    1746:	f3 01       	movw	r30, r6
    1748:	60 81       	ld	r22, Z
    174a:	71 81       	ldd	r23, Z+1	; 0x01
    174c:	80 e0       	ldi	r24, 0x00	; 0
    174e:	90 e0       	ldi	r25, 0x00	; 0
    1750:	a4 01       	movw	r20, r8
    1752:	df d2       	rcall	.+1470   	; 0x1d12 <__ultoa_invert>
    1754:	08 2f       	mov	r16, r24
    1756:	08 19       	sub	r16, r8
    1758:	16 ff       	sbrs	r17, 6
    175a:	04 c0       	rjmp	.+8      	; 0x1764 <vfprintf+0x1c6>
    175c:	b6 01       	movw	r22, r12
    175e:	8d e2       	ldi	r24, 0x2D	; 45
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	82 d2       	rcall	.+1284   	; 0x1c68 <fputc>
    1764:	14 ff       	sbrs	r17, 4
    1766:	13 c0       	rjmp	.+38     	; 0x178e <vfprintf+0x1f0>
    1768:	fe 01       	movw	r30, r28
    176a:	e0 0f       	add	r30, r16
    176c:	f1 1d       	adc	r31, r1
    176e:	80 81       	ld	r24, Z
    1770:	80 33       	cpi	r24, 0x30	; 48
    1772:	69 f0       	breq	.+26     	; 0x178e <vfprintf+0x1f0>
    1774:	b6 01       	movw	r22, r12
    1776:	80 e3       	ldi	r24, 0x30	; 48
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	76 d2       	rcall	.+1260   	; 0x1c68 <fputc>
    177c:	12 ff       	sbrs	r17, 2
    177e:	07 c0       	rjmp	.+14     	; 0x178e <vfprintf+0x1f0>
    1780:	10 72       	andi	r17, 0x20	; 32
    1782:	81 2f       	mov	r24, r17
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	b6 01       	movw	r22, r12
    1788:	88 5a       	subi	r24, 0xA8	; 168
    178a:	9f 4f       	sbci	r25, 0xFF	; 255
    178c:	6d d2       	rcall	.+1242   	; 0x1c68 <fputc>
    178e:	01 50       	subi	r16, 0x01	; 1
    1790:	f4 01       	movw	r30, r8
    1792:	e0 0f       	add	r30, r16
    1794:	f1 1d       	adc	r31, r1
    1796:	80 81       	ld	r24, Z
    1798:	b6 01       	movw	r22, r12
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	65 d2       	rcall	.+1226   	; 0x1c68 <fputc>
    179e:	01 11       	cpse	r16, r1
    17a0:	f6 cf       	rjmp	.-20     	; 0x178e <vfprintf+0x1f0>
    17a2:	29 cf       	rjmp	.-430    	; 0x15f6 <vfprintf+0x58>
    17a4:	f6 01       	movw	r30, r12
    17a6:	86 81       	ldd	r24, Z+6	; 0x06
    17a8:	97 81       	ldd	r25, Z+7	; 0x07
    17aa:	02 c0       	rjmp	.+4      	; 0x17b0 <vfprintf+0x212>
    17ac:	8f ef       	ldi	r24, 0xFF	; 255
    17ae:	9f ef       	ldi	r25, 0xFF	; 255
    17b0:	2b 96       	adiw	r28, 0x0b	; 11
    17b2:	ee e0       	ldi	r30, 0x0E	; 14
    17b4:	e8 c1       	rjmp	.+976    	; 0x1b86 <__epilogue_restores__+0x8>

000017b6 <putval>:
    17b6:	20 fd       	sbrc	r18, 0
    17b8:	09 c0       	rjmp	.+18     	; 0x17cc <putval+0x16>
    17ba:	fc 01       	movw	r30, r24
    17bc:	23 fd       	sbrc	r18, 3
    17be:	05 c0       	rjmp	.+10     	; 0x17ca <putval+0x14>
    17c0:	22 ff       	sbrs	r18, 2
    17c2:	02 c0       	rjmp	.+4      	; 0x17c8 <putval+0x12>
    17c4:	73 83       	std	Z+3, r23	; 0x03
    17c6:	62 83       	std	Z+2, r22	; 0x02
    17c8:	51 83       	std	Z+1, r21	; 0x01
    17ca:	40 83       	st	Z, r20
    17cc:	08 95       	ret

000017ce <mulacc>:
    17ce:	44 fd       	sbrc	r20, 4
    17d0:	17 c0       	rjmp	.+46     	; 0x1800 <mulacc+0x32>
    17d2:	46 fd       	sbrc	r20, 6
    17d4:	17 c0       	rjmp	.+46     	; 0x1804 <mulacc+0x36>
    17d6:	ab 01       	movw	r20, r22
    17d8:	bc 01       	movw	r22, r24
    17da:	da 01       	movw	r26, r20
    17dc:	fb 01       	movw	r30, r22
    17de:	aa 0f       	add	r26, r26
    17e0:	bb 1f       	adc	r27, r27
    17e2:	ee 1f       	adc	r30, r30
    17e4:	ff 1f       	adc	r31, r31
    17e6:	10 94       	com	r1
    17e8:	d1 f7       	brne	.-12     	; 0x17de <mulacc+0x10>
    17ea:	4a 0f       	add	r20, r26
    17ec:	5b 1f       	adc	r21, r27
    17ee:	6e 1f       	adc	r22, r30
    17f0:	7f 1f       	adc	r23, r31
    17f2:	cb 01       	movw	r24, r22
    17f4:	ba 01       	movw	r22, r20
    17f6:	66 0f       	add	r22, r22
    17f8:	77 1f       	adc	r23, r23
    17fa:	88 1f       	adc	r24, r24
    17fc:	99 1f       	adc	r25, r25
    17fe:	09 c0       	rjmp	.+18     	; 0x1812 <mulacc+0x44>
    1800:	33 e0       	ldi	r19, 0x03	; 3
    1802:	01 c0       	rjmp	.+2      	; 0x1806 <mulacc+0x38>
    1804:	34 e0       	ldi	r19, 0x04	; 4
    1806:	66 0f       	add	r22, r22
    1808:	77 1f       	adc	r23, r23
    180a:	88 1f       	adc	r24, r24
    180c:	99 1f       	adc	r25, r25
    180e:	31 50       	subi	r19, 0x01	; 1
    1810:	d1 f7       	brne	.-12     	; 0x1806 <mulacc+0x38>
    1812:	62 0f       	add	r22, r18
    1814:	71 1d       	adc	r23, r1
    1816:	81 1d       	adc	r24, r1
    1818:	91 1d       	adc	r25, r1
    181a:	08 95       	ret

0000181c <skip_spaces>:
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	cf 93       	push	r28
    1822:	df 93       	push	r29
    1824:	8c 01       	movw	r16, r24
    1826:	c8 01       	movw	r24, r16
    1828:	e1 d1       	rcall	.+962    	; 0x1bec <fgetc>
    182a:	ec 01       	movw	r28, r24
    182c:	97 fd       	sbrc	r25, 7
    182e:	06 c0       	rjmp	.+12     	; 0x183c <skip_spaces+0x20>
    1830:	c1 d1       	rcall	.+898    	; 0x1bb4 <isspace>
    1832:	89 2b       	or	r24, r25
    1834:	c1 f7       	brne	.-16     	; 0x1826 <skip_spaces+0xa>
    1836:	b8 01       	movw	r22, r16
    1838:	ce 01       	movw	r24, r28
    183a:	52 d2       	rcall	.+1188   	; 0x1ce0 <ungetc>
    183c:	ce 01       	movw	r24, r28
    183e:	df 91       	pop	r29
    1840:	cf 91       	pop	r28
    1842:	1f 91       	pop	r17
    1844:	0f 91       	pop	r16
    1846:	08 95       	ret

00001848 <conv_int>:
    1848:	8f 92       	push	r8
    184a:	9f 92       	push	r9
    184c:	af 92       	push	r10
    184e:	bf 92       	push	r11
    1850:	ef 92       	push	r14
    1852:	ff 92       	push	r15
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	8c 01       	movw	r16, r24
    185e:	d6 2f       	mov	r29, r22
    1860:	7a 01       	movw	r14, r20
    1862:	b2 2e       	mov	r11, r18
    1864:	c3 d1       	rcall	.+902    	; 0x1bec <fgetc>
    1866:	9c 01       	movw	r18, r24
    1868:	33 27       	eor	r19, r19
    186a:	2b 32       	cpi	r18, 0x2B	; 43
    186c:	31 05       	cpc	r19, r1
    186e:	31 f0       	breq	.+12     	; 0x187c <conv_int+0x34>
    1870:	2d 32       	cpi	r18, 0x2D	; 45
    1872:	31 05       	cpc	r19, r1
    1874:	59 f4       	brne	.+22     	; 0x188c <conv_int+0x44>
    1876:	8b 2d       	mov	r24, r11
    1878:	80 68       	ori	r24, 0x80	; 128
    187a:	b8 2e       	mov	r11, r24
    187c:	d1 50       	subi	r29, 0x01	; 1
    187e:	11 f4       	brne	.+4      	; 0x1884 <conv_int+0x3c>
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	61 c0       	rjmp	.+194    	; 0x1946 <conv_int+0xfe>
    1884:	c8 01       	movw	r24, r16
    1886:	b2 d1       	rcall	.+868    	; 0x1bec <fgetc>
    1888:	97 fd       	sbrc	r25, 7
    188a:	fa cf       	rjmp	.-12     	; 0x1880 <conv_int+0x38>
    188c:	cb 2d       	mov	r28, r11
    188e:	cd 7f       	andi	r28, 0xFD	; 253
    1890:	2b 2d       	mov	r18, r11
    1892:	20 73       	andi	r18, 0x30	; 48
    1894:	f9 f4       	brne	.+62     	; 0x18d4 <conv_int+0x8c>
    1896:	80 33       	cpi	r24, 0x30	; 48
    1898:	e9 f4       	brne	.+58     	; 0x18d4 <conv_int+0x8c>
    189a:	aa 24       	eor	r10, r10
    189c:	aa 94       	dec	r10
    189e:	ad 0e       	add	r10, r29
    18a0:	09 f4       	brne	.+2      	; 0x18a4 <conv_int+0x5c>
    18a2:	3e c0       	rjmp	.+124    	; 0x1920 <conv_int+0xd8>
    18a4:	c8 01       	movw	r24, r16
    18a6:	a2 d1       	rcall	.+836    	; 0x1bec <fgetc>
    18a8:	97 fd       	sbrc	r25, 7
    18aa:	3a c0       	rjmp	.+116    	; 0x1920 <conv_int+0xd8>
    18ac:	9c 01       	movw	r18, r24
    18ae:	2f 7d       	andi	r18, 0xDF	; 223
    18b0:	33 27       	eor	r19, r19
    18b2:	28 35       	cpi	r18, 0x58	; 88
    18b4:	31 05       	cpc	r19, r1
    18b6:	41 f4       	brne	.+16     	; 0x18c8 <conv_int+0x80>
    18b8:	c2 64       	ori	r28, 0x42	; 66
    18ba:	d2 50       	subi	r29, 0x02	; 2
    18bc:	89 f1       	breq	.+98     	; 0x1920 <conv_int+0xd8>
    18be:	c8 01       	movw	r24, r16
    18c0:	95 d1       	rcall	.+810    	; 0x1bec <fgetc>
    18c2:	97 ff       	sbrs	r25, 7
    18c4:	07 c0       	rjmp	.+14     	; 0x18d4 <conv_int+0x8c>
    18c6:	2c c0       	rjmp	.+88     	; 0x1920 <conv_int+0xd8>
    18c8:	b6 fe       	sbrs	r11, 6
    18ca:	02 c0       	rjmp	.+4      	; 0x18d0 <conv_int+0x88>
    18cc:	c2 60       	ori	r28, 0x02	; 2
    18ce:	01 c0       	rjmp	.+2      	; 0x18d2 <conv_int+0x8a>
    18d0:	c2 61       	ori	r28, 0x12	; 18
    18d2:	da 2d       	mov	r29, r10
    18d4:	81 2c       	mov	r8, r1
    18d6:	91 2c       	mov	r9, r1
    18d8:	54 01       	movw	r10, r8
    18da:	20 ed       	ldi	r18, 0xD0	; 208
    18dc:	28 0f       	add	r18, r24
    18de:	28 30       	cpi	r18, 0x08	; 8
    18e0:	78 f0       	brcs	.+30     	; 0x1900 <conv_int+0xb8>
    18e2:	c4 ff       	sbrs	r28, 4
    18e4:	03 c0       	rjmp	.+6      	; 0x18ec <conv_int+0xa4>
    18e6:	b8 01       	movw	r22, r16
    18e8:	fb d1       	rcall	.+1014   	; 0x1ce0 <ungetc>
    18ea:	17 c0       	rjmp	.+46     	; 0x191a <conv_int+0xd2>
    18ec:	2a 30       	cpi	r18, 0x0A	; 10
    18ee:	40 f0       	brcs	.+16     	; 0x1900 <conv_int+0xb8>
    18f0:	c6 ff       	sbrs	r28, 6
    18f2:	f9 cf       	rjmp	.-14     	; 0x18e6 <conv_int+0x9e>
    18f4:	2f 7d       	andi	r18, 0xDF	; 223
    18f6:	3f ee       	ldi	r19, 0xEF	; 239
    18f8:	32 0f       	add	r19, r18
    18fa:	36 30       	cpi	r19, 0x06	; 6
    18fc:	a0 f7       	brcc	.-24     	; 0x18e6 <conv_int+0x9e>
    18fe:	27 50       	subi	r18, 0x07	; 7
    1900:	4c 2f       	mov	r20, r28
    1902:	c5 01       	movw	r24, r10
    1904:	b4 01       	movw	r22, r8
    1906:	63 df       	rcall	.-314    	; 0x17ce <mulacc>
    1908:	4b 01       	movw	r8, r22
    190a:	5c 01       	movw	r10, r24
    190c:	c2 60       	ori	r28, 0x02	; 2
    190e:	d1 50       	subi	r29, 0x01	; 1
    1910:	51 f0       	breq	.+20     	; 0x1926 <conv_int+0xde>
    1912:	c8 01       	movw	r24, r16
    1914:	6b d1       	rcall	.+726    	; 0x1bec <fgetc>
    1916:	97 ff       	sbrs	r25, 7
    1918:	e0 cf       	rjmp	.-64     	; 0x18da <conv_int+0x92>
    191a:	c1 fd       	sbrc	r28, 1
    191c:	04 c0       	rjmp	.+8      	; 0x1926 <conv_int+0xde>
    191e:	b0 cf       	rjmp	.-160    	; 0x1880 <conv_int+0x38>
    1920:	81 2c       	mov	r8, r1
    1922:	91 2c       	mov	r9, r1
    1924:	54 01       	movw	r10, r8
    1926:	c7 ff       	sbrs	r28, 7
    1928:	08 c0       	rjmp	.+16     	; 0x193a <conv_int+0xf2>
    192a:	b0 94       	com	r11
    192c:	a0 94       	com	r10
    192e:	90 94       	com	r9
    1930:	80 94       	com	r8
    1932:	81 1c       	adc	r8, r1
    1934:	91 1c       	adc	r9, r1
    1936:	a1 1c       	adc	r10, r1
    1938:	b1 1c       	adc	r11, r1
    193a:	2c 2f       	mov	r18, r28
    193c:	b5 01       	movw	r22, r10
    193e:	a4 01       	movw	r20, r8
    1940:	c7 01       	movw	r24, r14
    1942:	39 df       	rcall	.-398    	; 0x17b6 <putval>
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	df 91       	pop	r29
    1948:	cf 91       	pop	r28
    194a:	1f 91       	pop	r17
    194c:	0f 91       	pop	r16
    194e:	ff 90       	pop	r15
    1950:	ef 90       	pop	r14
    1952:	bf 90       	pop	r11
    1954:	af 90       	pop	r10
    1956:	9f 90       	pop	r9
    1958:	8f 90       	pop	r8
    195a:	08 95       	ret

0000195c <vfscanf>:
    195c:	a0 e0       	ldi	r26, 0x00	; 0
    195e:	b0 e0       	ldi	r27, 0x00	; 0
    1960:	e3 eb       	ldi	r30, 0xB3	; 179
    1962:	fc e0       	ldi	r31, 0x0C	; 12
    1964:	f3 c0       	rjmp	.+486    	; 0x1b4c <__prologue_saves__+0x6>
    1966:	6c 01       	movw	r12, r24
    1968:	eb 01       	movw	r28, r22
    196a:	5a 01       	movw	r10, r20
    196c:	fc 01       	movw	r30, r24
    196e:	17 82       	std	Z+7, r1	; 0x07
    1970:	16 82       	std	Z+6, r1	; 0x06
    1972:	51 2c       	mov	r5, r1
    1974:	f6 01       	movw	r30, r12
    1976:	f3 80       	ldd	r15, Z+3	; 0x03
    1978:	fe 01       	movw	r30, r28
    197a:	f3 fc       	sbrc	r15, 3
    197c:	85 91       	lpm	r24, Z+
    197e:	f3 fe       	sbrs	r15, 3
    1980:	81 91       	ld	r24, Z+
    1982:	18 2f       	mov	r17, r24
    1984:	ef 01       	movw	r28, r30
    1986:	88 23       	and	r24, r24
    1988:	09 f4       	brne	.+2      	; 0x198c <vfscanf+0x30>
    198a:	d4 c0       	rjmp	.+424    	; 0x1b34 <vfscanf+0x1d8>
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	12 d1       	rcall	.+548    	; 0x1bb4 <isspace>
    1990:	89 2b       	or	r24, r25
    1992:	19 f0       	breq	.+6      	; 0x199a <vfscanf+0x3e>
    1994:	c6 01       	movw	r24, r12
    1996:	42 df       	rcall	.-380    	; 0x181c <skip_spaces>
    1998:	ed cf       	rjmp	.-38     	; 0x1974 <vfscanf+0x18>
    199a:	15 32       	cpi	r17, 0x25	; 37
    199c:	41 f4       	brne	.+16     	; 0x19ae <vfscanf+0x52>
    199e:	fe 01       	movw	r30, r28
    19a0:	f3 fc       	sbrc	r15, 3
    19a2:	15 91       	lpm	r17, Z+
    19a4:	f3 fe       	sbrs	r15, 3
    19a6:	11 91       	ld	r17, Z+
    19a8:	ef 01       	movw	r28, r30
    19aa:	15 32       	cpi	r17, 0x25	; 37
    19ac:	71 f4       	brne	.+28     	; 0x19ca <vfscanf+0x6e>
    19ae:	c6 01       	movw	r24, r12
    19b0:	1d d1       	rcall	.+570    	; 0x1bec <fgetc>
    19b2:	97 fd       	sbrc	r25, 7
    19b4:	bd c0       	rjmp	.+378    	; 0x1b30 <vfscanf+0x1d4>
    19b6:	41 2f       	mov	r20, r17
    19b8:	50 e0       	ldi	r21, 0x00	; 0
    19ba:	9c 01       	movw	r18, r24
    19bc:	33 27       	eor	r19, r19
    19be:	24 17       	cp	r18, r20
    19c0:	35 07       	cpc	r19, r21
    19c2:	c1 f2       	breq	.-80     	; 0x1974 <vfscanf+0x18>
    19c4:	b6 01       	movw	r22, r12
    19c6:	8c d1       	rcall	.+792    	; 0x1ce0 <ungetc>
    19c8:	b5 c0       	rjmp	.+362    	; 0x1b34 <vfscanf+0x1d8>
    19ca:	1a 32       	cpi	r17, 0x2A	; 42
    19cc:	39 f4       	brne	.+14     	; 0x19dc <vfscanf+0x80>
    19ce:	f3 fc       	sbrc	r15, 3
    19d0:	15 91       	lpm	r17, Z+
    19d2:	f3 fe       	sbrs	r15, 3
    19d4:	11 91       	ld	r17, Z+
    19d6:	ef 01       	movw	r28, r30
    19d8:	01 e0       	ldi	r16, 0x01	; 1
    19da:	01 c0       	rjmp	.+2      	; 0x19de <vfscanf+0x82>
    19dc:	00 e0       	ldi	r16, 0x00	; 0
    19de:	e1 2c       	mov	r14, r1
    19e0:	20 ed       	ldi	r18, 0xD0	; 208
    19e2:	21 0f       	add	r18, r17
    19e4:	2a 30       	cpi	r18, 0x0A	; 10
    19e6:	78 f4       	brcc	.+30     	; 0x1a06 <vfscanf+0xaa>
    19e8:	02 60       	ori	r16, 0x02	; 2
    19ea:	6e 2d       	mov	r22, r14
    19ec:	70 e0       	ldi	r23, 0x00	; 0
    19ee:	80 e0       	ldi	r24, 0x00	; 0
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	40 e2       	ldi	r20, 0x20	; 32
    19f4:	ec de       	rcall	.-552    	; 0x17ce <mulacc>
    19f6:	e6 2e       	mov	r14, r22
    19f8:	fe 01       	movw	r30, r28
    19fa:	f3 fc       	sbrc	r15, 3
    19fc:	15 91       	lpm	r17, Z+
    19fe:	f3 fe       	sbrs	r15, 3
    1a00:	11 91       	ld	r17, Z+
    1a02:	ef 01       	movw	r28, r30
    1a04:	ed cf       	rjmp	.-38     	; 0x19e0 <vfscanf+0x84>
    1a06:	01 ff       	sbrs	r16, 1
    1a08:	03 c0       	rjmp	.+6      	; 0x1a10 <vfscanf+0xb4>
    1a0a:	e1 10       	cpse	r14, r1
    1a0c:	03 c0       	rjmp	.+6      	; 0x1a14 <vfscanf+0xb8>
    1a0e:	92 c0       	rjmp	.+292    	; 0x1b34 <vfscanf+0x1d8>
    1a10:	ee 24       	eor	r14, r14
    1a12:	ea 94       	dec	r14
    1a14:	18 36       	cpi	r17, 0x68	; 104
    1a16:	19 f0       	breq	.+6      	; 0x1a1e <vfscanf+0xc2>
    1a18:	1c 36       	cpi	r17, 0x6C	; 108
    1a1a:	51 f0       	breq	.+20     	; 0x1a30 <vfscanf+0xd4>
    1a1c:	10 c0       	rjmp	.+32     	; 0x1a3e <vfscanf+0xe2>
    1a1e:	fe 01       	movw	r30, r28
    1a20:	f3 fc       	sbrc	r15, 3
    1a22:	15 91       	lpm	r17, Z+
    1a24:	f3 fe       	sbrs	r15, 3
    1a26:	11 91       	ld	r17, Z+
    1a28:	ef 01       	movw	r28, r30
    1a2a:	18 36       	cpi	r17, 0x68	; 104
    1a2c:	41 f4       	brne	.+16     	; 0x1a3e <vfscanf+0xe2>
    1a2e:	08 60       	ori	r16, 0x08	; 8
    1a30:	04 60       	ori	r16, 0x04	; 4
    1a32:	fe 01       	movw	r30, r28
    1a34:	f3 fc       	sbrc	r15, 3
    1a36:	15 91       	lpm	r17, Z+
    1a38:	f3 fe       	sbrs	r15, 3
    1a3a:	11 91       	ld	r17, Z+
    1a3c:	ef 01       	movw	r28, r30
    1a3e:	11 23       	and	r17, r17
    1a40:	09 f4       	brne	.+2      	; 0x1a44 <vfscanf+0xe8>
    1a42:	78 c0       	rjmp	.+240    	; 0x1b34 <vfscanf+0x1d8>
    1a44:	61 2f       	mov	r22, r17
    1a46:	70 e0       	ldi	r23, 0x00	; 0
    1a48:	8f e7       	ldi	r24, 0x7F	; 127
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	bb d0       	rcall	.+374    	; 0x1bc4 <strchr_P>
    1a4e:	89 2b       	or	r24, r25
    1a50:	09 f4       	brne	.+2      	; 0x1a54 <vfscanf+0xf8>
    1a52:	70 c0       	rjmp	.+224    	; 0x1b34 <vfscanf+0x1d8>
    1a54:	00 fd       	sbrc	r16, 0
    1a56:	07 c0       	rjmp	.+14     	; 0x1a66 <vfscanf+0x10a>
    1a58:	f5 01       	movw	r30, r10
    1a5a:	80 80       	ld	r8, Z
    1a5c:	91 80       	ldd	r9, Z+1	; 0x01
    1a5e:	c5 01       	movw	r24, r10
    1a60:	02 96       	adiw	r24, 0x02	; 2
    1a62:	5c 01       	movw	r10, r24
    1a64:	02 c0       	rjmp	.+4      	; 0x1a6a <vfscanf+0x10e>
    1a66:	81 2c       	mov	r8, r1
    1a68:	91 2c       	mov	r9, r1
    1a6a:	1e 36       	cpi	r17, 0x6E	; 110
    1a6c:	49 f4       	brne	.+18     	; 0x1a80 <vfscanf+0x124>
    1a6e:	f6 01       	movw	r30, r12
    1a70:	46 81       	ldd	r20, Z+6	; 0x06
    1a72:	57 81       	ldd	r21, Z+7	; 0x07
    1a74:	60 e0       	ldi	r22, 0x00	; 0
    1a76:	70 e0       	ldi	r23, 0x00	; 0
    1a78:	20 2f       	mov	r18, r16
    1a7a:	c4 01       	movw	r24, r8
    1a7c:	9c de       	rcall	.-712    	; 0x17b6 <putval>
    1a7e:	7a cf       	rjmp	.-268    	; 0x1974 <vfscanf+0x18>
    1a80:	13 36       	cpi	r17, 0x63	; 99
    1a82:	a1 f4       	brne	.+40     	; 0x1aac <vfscanf+0x150>
    1a84:	01 fd       	sbrc	r16, 1
    1a86:	02 c0       	rjmp	.+4      	; 0x1a8c <vfscanf+0x130>
    1a88:	ee 24       	eor	r14, r14
    1a8a:	e3 94       	inc	r14
    1a8c:	c6 01       	movw	r24, r12
    1a8e:	ae d0       	rcall	.+348    	; 0x1bec <fgetc>
    1a90:	97 fd       	sbrc	r25, 7
    1a92:	4e c0       	rjmp	.+156    	; 0x1b30 <vfscanf+0x1d4>
    1a94:	81 14       	cp	r8, r1
    1a96:	91 04       	cpc	r9, r1
    1a98:	29 f0       	breq	.+10     	; 0x1aa4 <vfscanf+0x148>
    1a9a:	f4 01       	movw	r30, r8
    1a9c:	80 83       	st	Z, r24
    1a9e:	c4 01       	movw	r24, r8
    1aa0:	01 96       	adiw	r24, 0x01	; 1
    1aa2:	4c 01       	movw	r8, r24
    1aa4:	ea 94       	dec	r14
    1aa6:	e1 10       	cpse	r14, r1
    1aa8:	f1 cf       	rjmp	.-30     	; 0x1a8c <vfscanf+0x130>
    1aaa:	3e c0       	rjmp	.+124    	; 0x1b28 <vfscanf+0x1cc>
    1aac:	c6 01       	movw	r24, r12
    1aae:	b6 de       	rcall	.-660    	; 0x181c <skip_spaces>
    1ab0:	97 fd       	sbrc	r25, 7
    1ab2:	3e c0       	rjmp	.+124    	; 0x1b30 <vfscanf+0x1d4>
    1ab4:	1f 36       	cpi	r17, 0x6F	; 111
    1ab6:	49 f1       	breq	.+82     	; 0x1b0a <vfscanf+0x1ae>
    1ab8:	28 f4       	brcc	.+10     	; 0x1ac4 <vfscanf+0x168>
    1aba:	14 36       	cpi	r17, 0x64	; 100
    1abc:	21 f1       	breq	.+72     	; 0x1b06 <vfscanf+0x1aa>
    1abe:	19 36       	cpi	r17, 0x69	; 105
    1ac0:	39 f1       	breq	.+78     	; 0x1b10 <vfscanf+0x1b4>
    1ac2:	25 c0       	rjmp	.+74     	; 0x1b0e <vfscanf+0x1b2>
    1ac4:	13 37       	cpi	r17, 0x73	; 115
    1ac6:	71 f0       	breq	.+28     	; 0x1ae4 <vfscanf+0x188>
    1ac8:	15 37       	cpi	r17, 0x75	; 117
    1aca:	e9 f0       	breq	.+58     	; 0x1b06 <vfscanf+0x1aa>
    1acc:	20 c0       	rjmp	.+64     	; 0x1b0e <vfscanf+0x1b2>
    1ace:	81 14       	cp	r8, r1
    1ad0:	91 04       	cpc	r9, r1
    1ad2:	29 f0       	breq	.+10     	; 0x1ade <vfscanf+0x182>
    1ad4:	f4 01       	movw	r30, r8
    1ad6:	60 82       	st	Z, r6
    1ad8:	c4 01       	movw	r24, r8
    1ada:	01 96       	adiw	r24, 0x01	; 1
    1adc:	4c 01       	movw	r8, r24
    1ade:	ea 94       	dec	r14
    1ae0:	ee 20       	and	r14, r14
    1ae2:	59 f0       	breq	.+22     	; 0x1afa <vfscanf+0x19e>
    1ae4:	c6 01       	movw	r24, r12
    1ae6:	82 d0       	rcall	.+260    	; 0x1bec <fgetc>
    1ae8:	3c 01       	movw	r6, r24
    1aea:	97 fd       	sbrc	r25, 7
    1aec:	06 c0       	rjmp	.+12     	; 0x1afa <vfscanf+0x19e>
    1aee:	62 d0       	rcall	.+196    	; 0x1bb4 <isspace>
    1af0:	89 2b       	or	r24, r25
    1af2:	69 f3       	breq	.-38     	; 0x1ace <vfscanf+0x172>
    1af4:	b6 01       	movw	r22, r12
    1af6:	c3 01       	movw	r24, r6
    1af8:	f3 d0       	rcall	.+486    	; 0x1ce0 <ungetc>
    1afa:	81 14       	cp	r8, r1
    1afc:	91 04       	cpc	r9, r1
    1afe:	a1 f0       	breq	.+40     	; 0x1b28 <vfscanf+0x1cc>
    1b00:	f4 01       	movw	r30, r8
    1b02:	10 82       	st	Z, r1
    1b04:	11 c0       	rjmp	.+34     	; 0x1b28 <vfscanf+0x1cc>
    1b06:	00 62       	ori	r16, 0x20	; 32
    1b08:	03 c0       	rjmp	.+6      	; 0x1b10 <vfscanf+0x1b4>
    1b0a:	00 61       	ori	r16, 0x10	; 16
    1b0c:	01 c0       	rjmp	.+2      	; 0x1b10 <vfscanf+0x1b4>
    1b0e:	00 64       	ori	r16, 0x40	; 64
    1b10:	20 2f       	mov	r18, r16
    1b12:	a4 01       	movw	r20, r8
    1b14:	6e 2d       	mov	r22, r14
    1b16:	c6 01       	movw	r24, r12
    1b18:	97 de       	rcall	.-722    	; 0x1848 <conv_int>
    1b1a:	81 11       	cpse	r24, r1
    1b1c:	05 c0       	rjmp	.+10     	; 0x1b28 <vfscanf+0x1cc>
    1b1e:	f6 01       	movw	r30, r12
    1b20:	83 81       	ldd	r24, Z+3	; 0x03
    1b22:	80 73       	andi	r24, 0x30	; 48
    1b24:	29 f4       	brne	.+10     	; 0x1b30 <vfscanf+0x1d4>
    1b26:	06 c0       	rjmp	.+12     	; 0x1b34 <vfscanf+0x1d8>
    1b28:	00 fd       	sbrc	r16, 0
    1b2a:	24 cf       	rjmp	.-440    	; 0x1974 <vfscanf+0x18>
    1b2c:	53 94       	inc	r5
    1b2e:	22 cf       	rjmp	.-444    	; 0x1974 <vfscanf+0x18>
    1b30:	55 20       	and	r5, r5
    1b32:	19 f0       	breq	.+6      	; 0x1b3a <vfscanf+0x1de>
    1b34:	85 2d       	mov	r24, r5
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	02 c0       	rjmp	.+4      	; 0x1b3e <vfscanf+0x1e2>
    1b3a:	8f ef       	ldi	r24, 0xFF	; 255
    1b3c:	9f ef       	ldi	r25, 0xFF	; 255
    1b3e:	cd b7       	in	r28, 0x3d	; 61
    1b40:	de b7       	in	r29, 0x3e	; 62
    1b42:	ef e0       	ldi	r30, 0x0F	; 15
    1b44:	1f c0       	rjmp	.+62     	; 0x1b84 <__epilogue_restores__+0x6>

00001b46 <__prologue_saves__>:
    1b46:	2f 92       	push	r2
    1b48:	3f 92       	push	r3
    1b4a:	4f 92       	push	r4
    1b4c:	5f 92       	push	r5
    1b4e:	6f 92       	push	r6
    1b50:	7f 92       	push	r7
    1b52:	8f 92       	push	r8
    1b54:	9f 92       	push	r9
    1b56:	af 92       	push	r10
    1b58:	bf 92       	push	r11
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    1b62:	0f 93       	push	r16
    1b64:	1f 93       	push	r17
    1b66:	cf 93       	push	r28
    1b68:	df 93       	push	r29
    1b6a:	cd b7       	in	r28, 0x3d	; 61
    1b6c:	de b7       	in	r29, 0x3e	; 62
    1b6e:	ca 1b       	sub	r28, r26
    1b70:	db 0b       	sbc	r29, r27
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	de bf       	out	0x3e, r29	; 62
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	cd bf       	out	0x3d, r28	; 61
    1b7c:	09 94       	ijmp

00001b7e <__epilogue_restores__>:
    1b7e:	2a 88       	ldd	r2, Y+18	; 0x12
    1b80:	39 88       	ldd	r3, Y+17	; 0x11
    1b82:	48 88       	ldd	r4, Y+16	; 0x10
    1b84:	5f 84       	ldd	r5, Y+15	; 0x0f
    1b86:	6e 84       	ldd	r6, Y+14	; 0x0e
    1b88:	7d 84       	ldd	r7, Y+13	; 0x0d
    1b8a:	8c 84       	ldd	r8, Y+12	; 0x0c
    1b8c:	9b 84       	ldd	r9, Y+11	; 0x0b
    1b8e:	aa 84       	ldd	r10, Y+10	; 0x0a
    1b90:	b9 84       	ldd	r11, Y+9	; 0x09
    1b92:	c8 84       	ldd	r12, Y+8	; 0x08
    1b94:	df 80       	ldd	r13, Y+7	; 0x07
    1b96:	ee 80       	ldd	r14, Y+6	; 0x06
    1b98:	fd 80       	ldd	r15, Y+5	; 0x05
    1b9a:	0c 81       	ldd	r16, Y+4	; 0x04
    1b9c:	1b 81       	ldd	r17, Y+3	; 0x03
    1b9e:	aa 81       	ldd	r26, Y+2	; 0x02
    1ba0:	b9 81       	ldd	r27, Y+1	; 0x01
    1ba2:	ce 0f       	add	r28, r30
    1ba4:	d1 1d       	adc	r29, r1
    1ba6:	0f b6       	in	r0, 0x3f	; 63
    1ba8:	f8 94       	cli
    1baa:	de bf       	out	0x3e, r29	; 62
    1bac:	0f be       	out	0x3f, r0	; 63
    1bae:	cd bf       	out	0x3d, r28	; 61
    1bb0:	ed 01       	movw	r28, r26
    1bb2:	08 95       	ret

00001bb4 <isspace>:
    1bb4:	91 11       	cpse	r25, r1
    1bb6:	0b c1       	rjmp	.+534    	; 0x1dce <__ctype_isfalse>
    1bb8:	80 32       	cpi	r24, 0x20	; 32
    1bba:	19 f0       	breq	.+6      	; 0x1bc2 <isspace+0xe>
    1bbc:	89 50       	subi	r24, 0x09	; 9
    1bbe:	85 50       	subi	r24, 0x05	; 5
    1bc0:	d0 f7       	brcc	.-12     	; 0x1bb6 <isspace+0x2>
    1bc2:	08 95       	ret

00001bc4 <strchr_P>:
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	05 90       	lpm	r0, Z+
    1bc8:	06 16       	cp	r0, r22
    1bca:	21 f0       	breq	.+8      	; 0x1bd4 <strchr_P+0x10>
    1bcc:	00 20       	and	r0, r0
    1bce:	d9 f7       	brne	.-10     	; 0x1bc6 <strchr_P+0x2>
    1bd0:	c0 01       	movw	r24, r0
    1bd2:	08 95       	ret
    1bd4:	31 97       	sbiw	r30, 0x01	; 1
    1bd6:	cf 01       	movw	r24, r30
    1bd8:	08 95       	ret

00001bda <memcpy>:
    1bda:	fb 01       	movw	r30, r22
    1bdc:	dc 01       	movw	r26, r24
    1bde:	02 c0       	rjmp	.+4      	; 0x1be4 <memcpy+0xa>
    1be0:	01 90       	ld	r0, Z+
    1be2:	0d 92       	st	X+, r0
    1be4:	41 50       	subi	r20, 0x01	; 1
    1be6:	50 40       	sbci	r21, 0x00	; 0
    1be8:	d8 f7       	brcc	.-10     	; 0x1be0 <memcpy+0x6>
    1bea:	08 95       	ret

00001bec <fgetc>:
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	ec 01       	movw	r28, r24
    1bf2:	2b 81       	ldd	r18, Y+3	; 0x03
    1bf4:	20 ff       	sbrs	r18, 0
    1bf6:	33 c0       	rjmp	.+102    	; 0x1c5e <fgetc+0x72>
    1bf8:	26 ff       	sbrs	r18, 6
    1bfa:	0a c0       	rjmp	.+20     	; 0x1c10 <fgetc+0x24>
    1bfc:	2f 7b       	andi	r18, 0xBF	; 191
    1bfe:	2b 83       	std	Y+3, r18	; 0x03
    1c00:	8e 81       	ldd	r24, Y+6	; 0x06
    1c02:	9f 81       	ldd	r25, Y+7	; 0x07
    1c04:	01 96       	adiw	r24, 0x01	; 1
    1c06:	9f 83       	std	Y+7, r25	; 0x07
    1c08:	8e 83       	std	Y+6, r24	; 0x06
    1c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	29 c0       	rjmp	.+82     	; 0x1c62 <fgetc+0x76>
    1c10:	22 ff       	sbrs	r18, 2
    1c12:	0f c0       	rjmp	.+30     	; 0x1c32 <fgetc+0x46>
    1c14:	e8 81       	ld	r30, Y
    1c16:	f9 81       	ldd	r31, Y+1	; 0x01
    1c18:	80 81       	ld	r24, Z
    1c1a:	08 2e       	mov	r0, r24
    1c1c:	00 0c       	add	r0, r0
    1c1e:	99 0b       	sbc	r25, r25
    1c20:	00 97       	sbiw	r24, 0x00	; 0
    1c22:	19 f4       	brne	.+6      	; 0x1c2a <fgetc+0x3e>
    1c24:	20 62       	ori	r18, 0x20	; 32
    1c26:	2b 83       	std	Y+3, r18	; 0x03
    1c28:	1a c0       	rjmp	.+52     	; 0x1c5e <fgetc+0x72>
    1c2a:	31 96       	adiw	r30, 0x01	; 1
    1c2c:	f9 83       	std	Y+1, r31	; 0x01
    1c2e:	e8 83       	st	Y, r30
    1c30:	0e c0       	rjmp	.+28     	; 0x1c4e <fgetc+0x62>
    1c32:	ea 85       	ldd	r30, Y+10	; 0x0a
    1c34:	fb 85       	ldd	r31, Y+11	; 0x0b
    1c36:	09 95       	icall
    1c38:	97 ff       	sbrs	r25, 7
    1c3a:	09 c0       	rjmp	.+18     	; 0x1c4e <fgetc+0x62>
    1c3c:	2b 81       	ldd	r18, Y+3	; 0x03
    1c3e:	01 96       	adiw	r24, 0x01	; 1
    1c40:	11 f0       	breq	.+4      	; 0x1c46 <fgetc+0x5a>
    1c42:	80 e2       	ldi	r24, 0x20	; 32
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <fgetc+0x5c>
    1c46:	80 e1       	ldi	r24, 0x10	; 16
    1c48:	82 2b       	or	r24, r18
    1c4a:	8b 83       	std	Y+3, r24	; 0x03
    1c4c:	08 c0       	rjmp	.+16     	; 0x1c5e <fgetc+0x72>
    1c4e:	2e 81       	ldd	r18, Y+6	; 0x06
    1c50:	3f 81       	ldd	r19, Y+7	; 0x07
    1c52:	2f 5f       	subi	r18, 0xFF	; 255
    1c54:	3f 4f       	sbci	r19, 0xFF	; 255
    1c56:	3f 83       	std	Y+7, r19	; 0x07
    1c58:	2e 83       	std	Y+6, r18	; 0x06
    1c5a:	99 27       	eor	r25, r25
    1c5c:	02 c0       	rjmp	.+4      	; 0x1c62 <fgetc+0x76>
    1c5e:	8f ef       	ldi	r24, 0xFF	; 255
    1c60:	9f ef       	ldi	r25, 0xFF	; 255
    1c62:	df 91       	pop	r29
    1c64:	cf 91       	pop	r28
    1c66:	08 95       	ret

00001c68 <fputc>:
    1c68:	0f 93       	push	r16
    1c6a:	1f 93       	push	r17
    1c6c:	cf 93       	push	r28
    1c6e:	df 93       	push	r29
    1c70:	fb 01       	movw	r30, r22
    1c72:	23 81       	ldd	r18, Z+3	; 0x03
    1c74:	21 fd       	sbrc	r18, 1
    1c76:	03 c0       	rjmp	.+6      	; 0x1c7e <fputc+0x16>
    1c78:	8f ef       	ldi	r24, 0xFF	; 255
    1c7a:	9f ef       	ldi	r25, 0xFF	; 255
    1c7c:	2c c0       	rjmp	.+88     	; 0x1cd6 <fputc+0x6e>
    1c7e:	22 ff       	sbrs	r18, 2
    1c80:	16 c0       	rjmp	.+44     	; 0x1cae <fputc+0x46>
    1c82:	46 81       	ldd	r20, Z+6	; 0x06
    1c84:	57 81       	ldd	r21, Z+7	; 0x07
    1c86:	24 81       	ldd	r18, Z+4	; 0x04
    1c88:	35 81       	ldd	r19, Z+5	; 0x05
    1c8a:	42 17       	cp	r20, r18
    1c8c:	53 07       	cpc	r21, r19
    1c8e:	44 f4       	brge	.+16     	; 0x1ca0 <fputc+0x38>
    1c90:	a0 81       	ld	r26, Z
    1c92:	b1 81       	ldd	r27, Z+1	; 0x01
    1c94:	9d 01       	movw	r18, r26
    1c96:	2f 5f       	subi	r18, 0xFF	; 255
    1c98:	3f 4f       	sbci	r19, 0xFF	; 255
    1c9a:	31 83       	std	Z+1, r19	; 0x01
    1c9c:	20 83       	st	Z, r18
    1c9e:	8c 93       	st	X, r24
    1ca0:	26 81       	ldd	r18, Z+6	; 0x06
    1ca2:	37 81       	ldd	r19, Z+7	; 0x07
    1ca4:	2f 5f       	subi	r18, 0xFF	; 255
    1ca6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca8:	37 83       	std	Z+7, r19	; 0x07
    1caa:	26 83       	std	Z+6, r18	; 0x06
    1cac:	14 c0       	rjmp	.+40     	; 0x1cd6 <fputc+0x6e>
    1cae:	8b 01       	movw	r16, r22
    1cb0:	ec 01       	movw	r28, r24
    1cb2:	fb 01       	movw	r30, r22
    1cb4:	00 84       	ldd	r0, Z+8	; 0x08
    1cb6:	f1 85       	ldd	r31, Z+9	; 0x09
    1cb8:	e0 2d       	mov	r30, r0
    1cba:	09 95       	icall
    1cbc:	89 2b       	or	r24, r25
    1cbe:	e1 f6       	brne	.-72     	; 0x1c78 <fputc+0x10>
    1cc0:	d8 01       	movw	r26, r16
    1cc2:	16 96       	adiw	r26, 0x06	; 6
    1cc4:	8d 91       	ld	r24, X+
    1cc6:	9c 91       	ld	r25, X
    1cc8:	17 97       	sbiw	r26, 0x07	; 7
    1cca:	01 96       	adiw	r24, 0x01	; 1
    1ccc:	17 96       	adiw	r26, 0x07	; 7
    1cce:	9c 93       	st	X, r25
    1cd0:	8e 93       	st	-X, r24
    1cd2:	16 97       	sbiw	r26, 0x06	; 6
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	1f 91       	pop	r17
    1cdc:	0f 91       	pop	r16
    1cde:	08 95       	ret

00001ce0 <ungetc>:
    1ce0:	fb 01       	movw	r30, r22
    1ce2:	23 81       	ldd	r18, Z+3	; 0x03
    1ce4:	20 ff       	sbrs	r18, 0
    1ce6:	12 c0       	rjmp	.+36     	; 0x1d0c <ungetc+0x2c>
    1ce8:	26 fd       	sbrc	r18, 6
    1cea:	10 c0       	rjmp	.+32     	; 0x1d0c <ungetc+0x2c>
    1cec:	8f 3f       	cpi	r24, 0xFF	; 255
    1cee:	3f ef       	ldi	r19, 0xFF	; 255
    1cf0:	93 07       	cpc	r25, r19
    1cf2:	61 f0       	breq	.+24     	; 0x1d0c <ungetc+0x2c>
    1cf4:	82 83       	std	Z+2, r24	; 0x02
    1cf6:	2f 7d       	andi	r18, 0xDF	; 223
    1cf8:	20 64       	ori	r18, 0x40	; 64
    1cfa:	23 83       	std	Z+3, r18	; 0x03
    1cfc:	26 81       	ldd	r18, Z+6	; 0x06
    1cfe:	37 81       	ldd	r19, Z+7	; 0x07
    1d00:	21 50       	subi	r18, 0x01	; 1
    1d02:	31 09       	sbc	r19, r1
    1d04:	37 83       	std	Z+7, r19	; 0x07
    1d06:	26 83       	std	Z+6, r18	; 0x06
    1d08:	99 27       	eor	r25, r25
    1d0a:	08 95       	ret
    1d0c:	8f ef       	ldi	r24, 0xFF	; 255
    1d0e:	9f ef       	ldi	r25, 0xFF	; 255
    1d10:	08 95       	ret

00001d12 <__ultoa_invert>:
    1d12:	fa 01       	movw	r30, r20
    1d14:	aa 27       	eor	r26, r26
    1d16:	28 30       	cpi	r18, 0x08	; 8
    1d18:	51 f1       	breq	.+84     	; 0x1d6e <__ultoa_invert+0x5c>
    1d1a:	20 31       	cpi	r18, 0x10	; 16
    1d1c:	81 f1       	breq	.+96     	; 0x1d7e <__ultoa_invert+0x6c>
    1d1e:	e8 94       	clt
    1d20:	6f 93       	push	r22
    1d22:	6e 7f       	andi	r22, 0xFE	; 254
    1d24:	6e 5f       	subi	r22, 0xFE	; 254
    1d26:	7f 4f       	sbci	r23, 0xFF	; 255
    1d28:	8f 4f       	sbci	r24, 0xFF	; 255
    1d2a:	9f 4f       	sbci	r25, 0xFF	; 255
    1d2c:	af 4f       	sbci	r26, 0xFF	; 255
    1d2e:	b1 e0       	ldi	r27, 0x01	; 1
    1d30:	3e d0       	rcall	.+124    	; 0x1dae <__ultoa_invert+0x9c>
    1d32:	b4 e0       	ldi	r27, 0x04	; 4
    1d34:	3c d0       	rcall	.+120    	; 0x1dae <__ultoa_invert+0x9c>
    1d36:	67 0f       	add	r22, r23
    1d38:	78 1f       	adc	r23, r24
    1d3a:	89 1f       	adc	r24, r25
    1d3c:	9a 1f       	adc	r25, r26
    1d3e:	a1 1d       	adc	r26, r1
    1d40:	68 0f       	add	r22, r24
    1d42:	79 1f       	adc	r23, r25
    1d44:	8a 1f       	adc	r24, r26
    1d46:	91 1d       	adc	r25, r1
    1d48:	a1 1d       	adc	r26, r1
    1d4a:	6a 0f       	add	r22, r26
    1d4c:	71 1d       	adc	r23, r1
    1d4e:	81 1d       	adc	r24, r1
    1d50:	91 1d       	adc	r25, r1
    1d52:	a1 1d       	adc	r26, r1
    1d54:	20 d0       	rcall	.+64     	; 0x1d96 <__ultoa_invert+0x84>
    1d56:	09 f4       	brne	.+2      	; 0x1d5a <__ultoa_invert+0x48>
    1d58:	68 94       	set
    1d5a:	3f 91       	pop	r19
    1d5c:	2a e0       	ldi	r18, 0x0A	; 10
    1d5e:	26 9f       	mul	r18, r22
    1d60:	11 24       	eor	r1, r1
    1d62:	30 19       	sub	r19, r0
    1d64:	30 5d       	subi	r19, 0xD0	; 208
    1d66:	31 93       	st	Z+, r19
    1d68:	de f6       	brtc	.-74     	; 0x1d20 <__ultoa_invert+0xe>
    1d6a:	cf 01       	movw	r24, r30
    1d6c:	08 95       	ret
    1d6e:	46 2f       	mov	r20, r22
    1d70:	47 70       	andi	r20, 0x07	; 7
    1d72:	40 5d       	subi	r20, 0xD0	; 208
    1d74:	41 93       	st	Z+, r20
    1d76:	b3 e0       	ldi	r27, 0x03	; 3
    1d78:	0f d0       	rcall	.+30     	; 0x1d98 <__ultoa_invert+0x86>
    1d7a:	c9 f7       	brne	.-14     	; 0x1d6e <__ultoa_invert+0x5c>
    1d7c:	f6 cf       	rjmp	.-20     	; 0x1d6a <__ultoa_invert+0x58>
    1d7e:	46 2f       	mov	r20, r22
    1d80:	4f 70       	andi	r20, 0x0F	; 15
    1d82:	40 5d       	subi	r20, 0xD0	; 208
    1d84:	4a 33       	cpi	r20, 0x3A	; 58
    1d86:	18 f0       	brcs	.+6      	; 0x1d8e <__ultoa_invert+0x7c>
    1d88:	49 5d       	subi	r20, 0xD9	; 217
    1d8a:	31 fd       	sbrc	r19, 1
    1d8c:	40 52       	subi	r20, 0x20	; 32
    1d8e:	41 93       	st	Z+, r20
    1d90:	02 d0       	rcall	.+4      	; 0x1d96 <__ultoa_invert+0x84>
    1d92:	a9 f7       	brne	.-22     	; 0x1d7e <__ultoa_invert+0x6c>
    1d94:	ea cf       	rjmp	.-44     	; 0x1d6a <__ultoa_invert+0x58>
    1d96:	b4 e0       	ldi	r27, 0x04	; 4
    1d98:	a6 95       	lsr	r26
    1d9a:	97 95       	ror	r25
    1d9c:	87 95       	ror	r24
    1d9e:	77 95       	ror	r23
    1da0:	67 95       	ror	r22
    1da2:	ba 95       	dec	r27
    1da4:	c9 f7       	brne	.-14     	; 0x1d98 <__ultoa_invert+0x86>
    1da6:	00 97       	sbiw	r24, 0x00	; 0
    1da8:	61 05       	cpc	r22, r1
    1daa:	71 05       	cpc	r23, r1
    1dac:	08 95       	ret
    1dae:	9b 01       	movw	r18, r22
    1db0:	ac 01       	movw	r20, r24
    1db2:	0a 2e       	mov	r0, r26
    1db4:	06 94       	lsr	r0
    1db6:	57 95       	ror	r21
    1db8:	47 95       	ror	r20
    1dba:	37 95       	ror	r19
    1dbc:	27 95       	ror	r18
    1dbe:	ba 95       	dec	r27
    1dc0:	c9 f7       	brne	.-14     	; 0x1db4 <__ultoa_invert+0xa2>
    1dc2:	62 0f       	add	r22, r18
    1dc4:	73 1f       	adc	r23, r19
    1dc6:	84 1f       	adc	r24, r20
    1dc8:	95 1f       	adc	r25, r21
    1dca:	a0 1d       	adc	r26, r0
    1dcc:	08 95       	ret

00001dce <__ctype_isfalse>:
    1dce:	99 27       	eor	r25, r25
    1dd0:	88 27       	eor	r24, r24

00001dd2 <__ctype_istrue>:
    1dd2:	08 95       	ret

00001dd4 <_exit>:
    1dd4:	f8 94       	cli

00001dd6 <__stop_program>:
    1dd6:	ff cf       	rjmp	.-2      	; 0x1dd6 <__stop_program>
